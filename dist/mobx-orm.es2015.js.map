{"version":3,"file":"mobx-orm.es2015.js","sources":["../src/query-base.ts","../src/query.ts","../src/query-page.ts","../src/model.ts","../src/adapters/adapter.ts","../src/adapters/local.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport Adapter from \"./adapters/adapter\"\nimport { Model } from \"./model\"\n\n\nexport default abstract class Query<M extends Model> {\n\n    @observable filters     : object  \n    @observable order_by    : string[]\n    @observable page        : number\n    @observable page_size   : number\n\n    get items      () { return this.__items }\n    get is_loading () { return this.__is_loading  }\n    get error      () { return this.__error       }\n    \n\treadonly __base_cache: any\n\treadonly __adapter: Adapter<M>\n    @observable __items: M[] = []\n    @observable __is_loading  : boolean = false \n    @observable __error       : string = '' \n\n    __disposers = []\n    __disposer_objects = {}\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n\t\tthis.__base_cache = base_cache\n\t\tthis.__adapter    = adapter\n        if (filters  ) this.filters   = filters\n        if (order_by ) this.order_by  = order_by\n\t\tif (page\t ) this.page      = page\n\t\tif (page_size) this.page_size = page_size\n        makeObservable(this)\n    }\n\n    destroy() {\n        for(let disposer of this.__disposers) disposer()\n        for(let __id in this.__disposer_objects) this.__disposer_objects[__id]()\n    }\n\n    abstract __load(objs: M[])\n\n    @action async load() {\n        this.__is_loading = true\n        try {\n            let objs = await this.__adapter.load(this.filters, this.order_by, this.page_size, this.page*this.page_size)\n\t\t\tthis.__load(objs)\n        }\n        catch(e) {\n            runInAction(() => this.__error = e)\n\t\t\tthrow e\n        }\n        finally {\n            runInAction(() => this.__is_loading = false)\n        }\n    }\n\n    ready(): Promise<Boolean> {\n        return new Promise((resolve, reject) => { \n            autorun((reaction) => {\n                if (!this.__is_loading) {\n                    reaction.dispose()\n                    resolve(!this.__is_loading) \n                }\n            })\n        })\n    }\n\n    __is_matched(obj) {\n        for(let key in this.filters) {\n            if (obj[key] != this.filters[key]) {\n                return false\n            }\n        }\n        return true\n    }\n}\n","import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QeuryBase from './query-base'\n\n\n/*\nReactive items:\n- delete from the cache -> delete from items\n- add to the cache \n    - the new obj is match the filters  -> add the obj to items\n- obj was changed \n    - не было но уже    попадание по фильтрам -> add the obj to items\n    -    было но уже не попадание по фильтрам -> remove the obj from items\n*/\n\nexport default class Query<M extends Model> extends QeuryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[]) {\n        super(adapter, base_cache, filters, order_by)\n\n        this.load() // load when query is created\n\n        // update if filters was changed\n        // watch only filters, if order was changed then we don't need to update, just resort\n        this.__disposers.push(reaction(\n            () => { filter: this.filters },\n            () => { this.load() }\n        ))\n\n        // watch the cache for changes, and update items if needed\n        this.__disposers.push(observe(this.__base_cache, (change: any) => {\n            if (change.type == 'add') {\n                this.watch_obj(change.newValue)\n            }\n            if (change.type == \"delete\") {\n                let __id = change.name\n                let obj  = change.oldValue\n                this.__disposer_objects[__id]()\n                delete this.__disposer_objects[__id]\n                let i = this.items.indexOf(obj)\n                if (i != -1)\n                    runInAction(() => {\n                        this.items.splice(i, 1)\n                    })\n            }\n        }))\n\n        // watch all exist objects of model \n        for(let [id, obj] of this.__base_cache) {\n            this.watch_obj(obj)\n        }\n    }\n\n    private watch_obj(obj) {\n        this.__disposer_objects[obj.__id] = autorun(\n            () => {\n                let should = this.__is_matched(obj)\n                let i = this.items.indexOf(obj)\n                // should be in the items and it is not in the items? add it to the items\n                if ( should && i == -1) runInAction(() => this.items.push(obj))\n                // should not be in the items and it is in the items? remove it from the items\n                if (!should && i != -1) runInAction(() => this.items.splice(i, 1))\n            })\n    }\n\n}\n","import { action, autorun, computed, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QueryBase from './query-base'\n\n/*\nПоведение реактивности items\n\nactions:\n    - удаление объекта который в items -> update() ? or just delete from items?\n    - добавление в кэш\n        - попадание по фильтрам -> update() ? or show `query should to update`?\n    - изменение в кэш\n        - не было но уже    попадание по фильтрам -> update()  ? or show `query should to update`?\n        -    было но уже не попадание по фильтрам -> update() ? or show `query should to update`?\n\nneed_to_update = \nauto_update = \n*/\n\n// TODO get total count - we need to count pages num\n\nexport default class Query<M extends Model> extends QueryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n        super(adapter, base_cache, filters, order_by)\n        if(this.page === undefined) this.page = 0\n        if(this.page_size === undefined) this.page_size = 50\n\n        this.load() // load when query is created\n\n        // update if query is changed\n        this.__disposers.push(reaction(\n            () => { return { \n                filter          : this.filters, \n                order_by        : this.order_by, \n                page            : this.page, \n                page_size       : this.page_size,\n             }},\n            () => { this.load() }\n        ))\n\n        // // watch the cache for changes, and update items if needed\n        // this.__disposers.push(observe(this.__base_cache, (change: any) => {\n        //     if (change.type == 'add') {\n        //         this.watch_obj(change.newValue)\n        //     }\n        //     if (change.type == \"delete\") {\n        //         let __id = change.name\n        //         let obj  = change.oldValue\n        //         this.__disposer_objects[__id]()\n        //         delete this.__disposer_objects[__id]\n        //         let i = this.items.indexOf(obj)\n        //         if (i != -1)\n        //             runInAction(() => {\n        //                 this.items.splice(i, 1)\n        //             })\n        //     }\n        // }))\n\n        // // watch all exist objects of model \n        // for(let [id, obj] of this.__base_cache) {\n        //     this.watch_obj(obj)\n        // }\n    }\n\n    //\n    private watch_obj(obj) {\n        this.__disposer_objects[obj.__id] = autorun(\n            () => {\n                let should_be_in_the_list = this.__is_matched(obj)\n                if (should_be_in_the_list) {\n                    let i = this.items.indexOf(obj)\n                    if (should_be_in_the_list && i == -1)\n                        runInAction(() => this.items.push(obj))\n                        \n                    if (!should_be_in_the_list && i != -1)\n                        runInAction(() => this.items.splice(i, 1))\n                }\n            })\n    }\n\n}\n\n","import { field } from 'dist/mobx-orm'\nimport { action, computed, makeObservable, observable, runInAction } from 'mobx'\nimport Adapter   from './adapters/adapter'\nimport QueryBase from './query-base'\nimport Query     from './query'\nimport QueryPage from './query-page'\n\n\nexport abstract class Model {\n    private static id_separator: string = '-'\n    // this private static properties will be copied to real model in the model decorator\n    private static adapter      : Adapter<Model>\n    private static cache        : Map<string, Model>\n    // we have 3 types of fields\n    // - ids (cannot be changed, order of keys is important)\n    // - fields\n    // - relations (not exist on outside)\n    private static ids: Map<string, {\n            // can decorator be different?\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }>\n    private static fields       : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }\n    }\n    // relateions is a list of field only foreign, one or many types\n    private static relations    : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any\n            // there is no serializer of deserializer because \n            // it is derivative and does not come from outside\n        }\n    }\n\n    // add obj to the cache\n    @action static inject(obj: Model) {\n        debugger\n        if (obj.__id === null)                    \n            throw new Error(`Object should have id!`)\n        if (this.cache.has(obj.__id)) {\n            throw new Error(`Object with id \"${obj.__id}\" already exist in the cache of model: \"${this.name}\")`)\n        }\n        this.cache.set(obj.__id, obj)\n    }\n\n    // remove obj from the cache\n    @action static eject(obj: Model) {\n        if (obj.__id === null)\n            return                   \n        if (!this.cache.has(obj.__id)) \n            throw new Error(`Object with id \"${obj.__id}\" not exist in the cache of model: ${this.name}\")`)\n        this.cache.delete(obj.__id)\n    }\n\n    static load(filters?, order_by?: string[]): QueryBase<Model>  {\n        return new Query<Model>(this.adapter, this.cache, filters, order_by)\n    }\n\n    static loadPage(filter?, order_by?: string[], page?: number, page_size?: number) {\n        return new QueryPage(this.adapter, this.cache, filter, order_by, page, page_size)\n    }\n\n    @action static updateCache(raw_obj): Model {\n        let __id = this.__id(raw_obj)\n        let obj\n        if (this.cache.has(__id)) {\n            runInAction(() => {\n                obj = this.cache.get(__id)\n                obj.updateFromRaw(raw_obj)\n            })\n        }\n        else {\n            obj = new (<any>this)(raw_obj)\n        }\n        return obj\n    }\n\n    static clearCache() {\n        // for clear cache we need just to set null into id fields\n        for (let obj of this.cache.values()) {\n            for (let id_field_name of this.ids.keys()) {\n                obj[id_field_name] = null\n            }\n        }\n    }\n\n    static __id(obj, ids?) : string | null {\n        let id = '' \n        if (ids === undefined) ids = Array.from(this.ids.keys()) \n        for (let id_field_name of ids) {\n            // if any id field is null then we should return null because id is not complite\n            if (obj[id_field_name] === null || obj[id_field_name] === undefined) \n                return null\n            id += `${obj[id_field_name]}${this.id_separator}`\n        }\n        id = id.slice(0, -(this.id_separator.length))\n        return id\n    }\n\n    private readonly __init_data: any \n    private disposers = new Map()\n\n    constructor (...args) { }\n\n    @computed get __id() : string | null {\n        return this.model.__id(this)\n    }\n\n    get model() : any {\n        return (<any>this.constructor).__proto__\n    }\n\n    get raw_obj() : any {\n        let raw_obj: any = {}\n        for(let id_field_name of this.model.ids.keys()) {\n            if(this[id_field_name] !== undefined) {\n                raw_obj[id_field_name] = this[id_field_name]\n            }\n        }\n        for(let field_name in this.model.fields) {\n            if(this[field_name] !== undefined) {\n                raw_obj[field_name] = this[field_name]\n            }\n        }\n        raw_obj.__id = this.__id\n        return raw_obj\n    }\n\n    get is_changed() : boolean {\n        let is_changed = false\n        for(let field_name in this.model.fields) {\n            if (this[field_name] != this.__init_data[field_name]) {\n                is_changed = true\n            }\n        }\n        return is_changed \n    }\n\n    async create() { return await this.model.adapter.create(this) }\n    async update() { return await this.model.adapter.update(this) }\n    async delete() { return await this.model.adapter.delete(this) }\n    async save  () { return this.__id === null ? this.create() : this.update() }\n\n    @action updateFromRaw(raw_obj) {\n        // keys\n        for (let id_field_name of this.model.ids.keys()) {\n            if (raw_obj[id_field_name] !== undefined && this[id_field_name] != raw_obj[id_field_name] ) {\n                this[id_field_name] = raw_obj[id_field_name]\n            }\n        }\n        // fields\n        for(let field_name in this.model.fields) {\n            if (raw_obj[field_name] !== undefined) {\n                this[field_name] = raw_obj[field_name]\n            }\n        }\n    }\n\n}\n\n\n// Decorator\nexport function model(constructor) {\n    var original = constructor\n\n    original.cache = observable(new Map())\n\n    // the new constructor\n    let f : any = function (...args) {\n        let c : any = class extends original { constructor (...args) { super(...args) } }\n            c.__proto__ = original\n\n        let obj   = new c()\n        let model = obj.model\n        makeObservable(obj)\n\n        if (model.ids === undefined) \n            throw(`No one id field was declared on model ${model.name}`)\n\n        // apply id-fields decorators\n        for (let id_field_name of model.ids.keys()) {\n            model.ids.get(id_field_name).decorator(obj, id_field_name)\n        }\n        // apply fields decorators\n        for (let field_name in model.fields) {\n            model.fields[field_name].decorator(obj, field_name)\n        }\n        // apply relations decorators\n        for (let field_name in model.relations) {\n            model.relations[field_name].decorator(obj, field_name)\n        }\n\n        runInAction(() => {\n            // update the object from args\n            if (args[0]) {\n                let raw_obj = args[0]\n                // id-fields\n                for (let id_field_name of model.ids.keys()) {\n                    if (raw_obj[id_field_name] !== undefined) {\n                        obj[id_field_name] = raw_obj[id_field_name]\n                    }\n                }\n                // fields \n                for (let field_name in model.fields) {\n                    if (raw_obj[field_name] !== undefined) {\n                        obj[field_name] = raw_obj[field_name]\n                    }\n                }\n            }\n            // save __init_data\n            obj.__init_data = {}\n            for (let field_name in model.fields) {\n                obj.__init_data[field_name] = obj[field_name]\n            }\n        })\n        return obj\n    }\n\n    f.__proto__ = original\n    f.prototype = original.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { Model } from '../model'\n\ntype RawObject = any \n\nexport default abstract class  Adapter<M extends Model> {\n\n    // abstract getTotalCount: (where?) => Promise<number>\n    abstract __create(obj: RawObject): Promise<object>\n    abstract __update(obj: RawObject): Promise<object>\n    abstract __delete(obj: RawObject): Promise<object>\n    abstract __load  (where?, order_by?, limit?, offset?): Promise<RawObject[]>\n\n    readonly model: any\n\n    constructor(model: any) {\n        this.model = model \n    }\n\n    async create(obj: M) : Promise<M> {\n        let raw_obj = await this.__create(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        return obj\n    }\n\n    async update(obj: M) : Promise<M> {\n        let raw_obj = await this.__update(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        return obj\n    }\n\n    async delete(obj: M) : Promise<M> {\n        let raw_obj = await this.__delete(obj.raw_obj)\n        // reset ids\n        debugger\n        for(let id_field_name of this.model.ids.keys())\n            obj[id_field_name] = null\n        return obj\n    }\n\n    async load(where?, order_by?, limit?, offset?):Promise<M[]> {\n        let raw_objs = await this.__load(where, order_by, limit, offset)\n        let objs: M[] = []\n        for (let raw_obj of raw_objs) {\n            objs.push(this.model.updateCache(raw_obj))\n        }\n        return objs\n    }\n}\n","import { Model } from '../model'\nimport Adapter  from './adapter'\n\n/*\nYou can use this adapter for mock data or for unit test\n*/\n\ntype RawObject = any \n\nexport let store: any = {}\n\nexport class LocalAdapter<M extends Model> extends Adapter<M> {\n\n    readonly store_name: string\n\n    constructor(model: any) {\n        super(model)\n        this.store_name = model.__proto__.name\n        store[this.store_name] = {}\n    }\n\n    async __create(obj: RawObject) : Promise<RawObject> {\n        if (obj.__id === null) {\n            // calculate and set new ID\n            let ids = [0]\n            for(let id of Object.keys(store[this.store_name])) {\n                ids.push(parseInt(id))\n            }\n            let max = Math.max.apply(null, ids)\n            for(let field_name_id of this.model.ids.keys()) {\n                obj[field_name_id] = max + 1\n            }\n        }\n        obj.__id = this.model.__id(obj)\n        store[this.store_name][this.model.__id(obj)] = obj\n        return obj\n    }\n\n    async __update(obj: RawObject) : Promise<RawObject> {\n        store[this.store_name][obj.__id] = obj\n        return obj\n    }\n\n    async __delete(obj: RawObject) : Promise<RawObject> {\n        delete store[this.store_name][obj.__id]\n        return obj\n    }\n\n    async __load (where?, order_by?, limit?, offset?) : Promise<RawObject[]> {\n        let raw_objs = Object.values(store[this.store_name])\n        if (limit !== undefined && offset !== undefined) {\n            raw_objs = raw_objs.slice(offset, offset+limit)\n        }\n        return raw_objs \n    }\n\n    // async getTotalCount(where?): Promise<number> {\n    //     return 100\n    // }\n}\n\n// model decorator\nexport function local() {\n    return (cls: any) => {\n        let adapter = new LocalAdapter(cls)\n        cls.__proto__.adapter = adapter \n    }\n}\n\nexport function init_local_data(model: any, data: RawObject[]) {\n    let objs = {} \n    for(let obj of data) {\n        objs[model.__id(obj)] = obj\n    }\n    store[model.__proto__.name] = objs\n}\n","import { observable, observe, intercept, extendObservable } from 'mobx'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to cache then you can use this \nnew Obj({id: x, ...})\n*/\n\nfunction field_ID (obj , field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // before changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && obj[field_name] !== null)\n            throw new Error(`You cannot change id field: ${field_name}. ${obj[field_name]} to ${change.newValue}`)\n        if (obj[field_name] !== null && change.newValue === null) {\n            try {\n                obj.model.eject(obj)\n            }\n            catch (err) {\n                let ignore_error = `Object with id \"${obj.__id}\" not exist in the model cache: ${obj.model.name}\")`\n                if (err.name !== ignore_error)\n                    throw err\n            }\n        }\n        return change\n    })\n\n    // after changes\n    observe(obj, field_name, (change) => {\n        // if id is complete\n        if (obj.__id !== null) \n            obj.model.inject(obj)\n    })\n\n}\n\n\nexport default function id(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.ids === undefined) model.ids = new Map()\n    model.ids.set(field_name, { decorator: field_ID })\n}\n","import { extendObservable } from 'mobx'\n\n\n\nexport function field_field(obj, field_name) {\n    // make observable and set default value\n    extendObservable(obj, { [field_name]: obj[field_name] })\n}\n\n\nexport default function field(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n\n    model.fields[field_name] = { decorator: field_field }  // register field \n}\n","// import 'reflect-metadata'\nimport {intercept, observe, extendObservable, observable, autorun, when, reaction} from 'mobx'\n\nfunction field_foreign(obj, field_name) {\n    let edit_mode = false\n    let settings = obj.model.relations[field_name].settings\n    let foreign_model     = settings.foreign_model\n    let foreign_ids_names = settings.foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    debugger\n    reaction(\n        // watch on foreign cache for foreign object\n        () => {\n            let id = foreign_model.__id(obj, foreign_ids_names)\n            return id ? foreign_model.cache.get(id) : null\n        },\n        // update foreign field\n        (foreign_obj, prev, reaction) => {\n            obj[field_name] = foreign_obj ? foreign_obj : null \n        })\n\n    // Setter\n    // 1. checks before set new changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model == foreign_model)) {\n            throw new Error(`You can set only instance of \"${foreign_model.name}\" or null`)\n        }\n        return change\n    })\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let new_foreign_obj = change.newValue\n        let old_foreign_obj = change.oldValue\n\n        if (new_foreign_obj === old_foreign_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n        edit_mode = true\n        try {\n            if (change.newValue === null) {\n                // if foreign set to null then reset ids on the obj\n                for (let id_name of foreign_ids_names) {\n                    obj[id_name] = null \n                }\n            }\n            else {\n                debugger\n                // if foreign set to obj then update ids from the obj's ids\n                let obj_ids: any = Array.from(change.newValue.model.ids.keys())\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    // do not touch if it the same\n                    if (obj[foreign_ids_names[i]] != change.newValue[obj_ids[i]])\n                        obj[foreign_ids_names[i]]  = change.newValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // rollback changes!\n            if (change.oldValue === null) {\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = null \n                }\n            }\n            else {\n                let obj_ids = change.oldValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n            throw e\n        }\n\n        // if foreign have the one then update the one\n        if (settings.one) {\n            if (old_foreign_obj) {\n                old_foreign_obj[settings.one] = null\n            }\n            if (new_foreign_obj) {\n                new_foreign_obj[settings.one] = obj \n            }\n        }\n\n    })\n}\n\n\nexport default function foreign(foreign_model: any, ...foreign_ids_names: string[]) {\n    foreign_model = foreign_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.constructor\n        if (model.relations === undefined) model.relations = {}\n        // register field \n        model.relations[field_name] = { \n            decorator: field_foreign,\n            settings: {\n                foreign_model: foreign_model,\n                // if it is empty then try auto detect it (it works only with single id) \n                foreign_ids_names: foreign_ids_names.length ? foreign_ids_names : [`${field_name}_id`]\n            } \n        } \n\n        // TODO finish it\n        // watch on the foreign cache \n        // if foreign obj was created then it should be attached to foreign\n        // if foreign obj was deleted then it should be removed from foreign\n        // e.i. update foreign obj when foreign ids was changed\n        // reaction(() => foreign_model.cache, (value, prev_value, reaction) => {\n        //     debugger\n        // })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_one(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // 1. checks before set new changes\n    intercept(obj, <any>field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model === remote_model))\n                throw new Error(`You can set only instance of \"${remote_model.name}\" or null`)\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let old_remote_obj = change.oldValue\n        let new_remote_obj = change.newValue\n\n        if (new_remote_obj === old_remote_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote obj\n            if (old_remote_obj) {\n                for (let id_name of remote_foreign_ids_name) {\n                    old_remote_obj[id_name] = null \n                }\n            }\n            // set foreign ids on the remote obj \n            if (new_remote_obj) {\n                let obj_ids: any = Array.from(obj.model.ids.keys())\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]] = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\n\nexport default function one(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    remote_model = remote_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_one,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`one ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            // TODO: is it not bad?\n                            // if (obj[field_name])\n                            //     // TODO better name of error\n                            //     // TODO add test for this case\n                            //     throw ('One: bad')\n                            runInAction(() => { obj[field_name] = remote_obj })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`one ${field_name}`)) {\n                        remote_obj.disposers.get(`one ${field_name}`)()\n                        remote_obj.disposers.delete(`one ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) \n                        runInAction(() => { obj[field_name] = null })\n                    break\n            }\n        })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_many(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: []\n    })\n\n    // 1. checks before set new changes\n    intercept(obj[field_name], (change: any) => {\n        // TODO\n        // if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor === remote_model.__proto__))\n        //         throw new Error(`You can set only instance of \"${remote_model.__proto__.name}\" or null`)\n\n        // TODO: if we push exist obj then ignore it? and not duplicate\n        // TODO: create a test for this case \n        // remote obj can be in the many \n        // for (let new_remote_obj of change.added) {\n        //     const i = obj[field_name].indexOf(new_remote_obj)\n        //     if (i == -1)\n        //         throw new Error(`\"${new_remote_obj.model.name}\" id:\"${new_remote_obj.__id}\" alredy in many \"${obj.model.name}\" id:\"${field_name}\"`)\n        // }\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj[field_name], (change:any) => {\n        if (change.type !== 'splice')\n            return \n\n        let old_remote_objs = change.removed\n        let new_remote_objs = change.added\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote objs\n            for(let old_remote_obj of old_remote_objs)\n                for (let id_name of remote_foreign_ids_name)\n                    old_remote_obj[id_name] = null \n            // set foreign ids on the remote objs \n            let obj_ids: any = Array.from(obj.model.ids.keys())\n            for(let new_remote_obj of new_remote_objs) {\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]]  = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\nexport default function many(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_many,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`many ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            const i = obj[field_name].indexOf(remote_obj)\n                            if (i == -1)\n                                runInAction(() => { obj[field_name].push(remote_obj) })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`many ${field_name}`)) {\n                        remote_obj.disposers.get(`many ${field_name}`)()\n                        remote_obj.disposers.delete(`many ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) {\n                        const i = obj[field_name].indexOf(remote_obj)\n                        if (i > -1)\n                            runInAction(() => { obj[field_name].splice(i, 1); })\n                    } \n                    break\n            }\n        })\n    }\n}"],"names":["Query","constructor","adapter","base_cache","filters","order_by","page","page_size","Object","this","__base_cache","__adapter","makeObservable","items","__items","is_loading","__is_loading","error","__error","destroy","disposer","__disposers","__id","__disposer_objects","async","objs","load","__load","e","runInAction","ready","Promise","resolve","reject","autorun","reaction","dispose","__is_matched","obj","key","__decorate","observable","action","QeuryBase","splice","length","push","super","observe","change","type","watch_obj","newValue","name","oldValue","i","indexOf","id","should","QueryBase","undefined","filter","should_be_in_the_list","Model","args","Map","static","Error","cache","has","set","delete","QueryPage","raw_obj","get","updateFromRaw","values","id_field_name","ids","keys","Array","from","id_separator","slice","model","__proto__","field_name","fields","is_changed","__init_data","create","update","original","f","c","decorator","relations","prototype","computed","Adapter","__create","__update","__delete","where","limit","offset","raw_objs","updateCache","store","LocalAdapter","store_name","parseInt","max","Math","apply","field_name_id","local","cls","field_ID","extendObservable","intercept","eject","err","ignore_error","inject","field_field","field","field_foreign","edit_mode","settings","foreign_model","foreign_ids_names","foreign_obj","prev","new_foreign_obj","old_foreign_obj","id_name","obj_ids","one","foreign","field_one","remote_model","remote_foreign_ids_name","remote_foreign_ids_names","old_remote_obj","new_remote_obj","toLowerCase","remote_change","remote_obj","disposers","field_many","old_remote_objs","removed","new_remote_objs","added","many"],"mappings":";;;;;;;;;;;;;;ygBAK8BA,EAoB1BC,YAAYC,EAAqBC,EAAiBC,EAAkBC,EAAqBC,EAAeC,GAlB5FC,+FACAA,gGACAA,4FACAA,iGAMfA,oGACAA,iGACeA,sFAAe,KACfA,4FAA0B,IAC1BA,sFAAyB,KAErCA,0FAAc,KACdA,iGAAqB,KAGvBC,KAAKC,aAAeP,EACpBM,KAAKE,UAAeT,EACVE,IAAWK,KAAKL,QAAYA,GAC5BC,IAAWI,KAAKJ,SAAYA,GAClCC,IAAQG,KAAKH,KAAYA,GACzBC,IAAWE,KAAKF,UAAYA,GAC1BK,EAAeH,MApBfI,YAAgB,OAAOJ,KAAKK,QAC5BC,iBAAgB,OAAON,KAAKO,aAC5BC,YAAgB,OAAOR,KAAKS,QAqBhCC,UACI,IAAI,IAAIC,KAAYX,KAAKY,YAAaD,IACtC,IAAI,IAAIE,KAAQb,KAAKc,mBAAoBd,KAAKc,mBAAmBD,KAK7DE,aACJf,KAAKO,cAAe,EACpB,IACI,IAAIS,QAAahB,KAAKE,UAAUe,KAAKjB,KAAKL,QAASK,KAAKJ,SAAUI,KAAKF,UAAWE,KAAKH,KAAKG,KAAKF,WAC1GE,KAAKkB,OAAOF,GAEP,MAAMG,GAEX,MADSC,GAAY,IAAMpB,KAAKS,QAAUU,IACpCA,UAGGC,GAAY,IAAMpB,KAAKO,cAAe,KAI9Cc,QACI,OAAO,IAAIC,SAAQ,CAACC,EAASC,KACzBC,GAASC,IACA1B,KAAKO,eACNmB,EAASC,UACTJ,GAASvB,KAAKO,qBAM9BqB,aAAaC,GACT,IAAI,IAAIC,KAAO9B,KAAKL,QAChB,GAAIkC,EAAIC,IAAQ9B,KAAKL,QAAQmC,GACzB,OAAO,EAGf,OAAO,GAnECC,GAAXC,yDACWD,GAAXC,yDACWD,GAAXC,sDACWD,GAAXC,2DAQWD,GAAXC,wDACWD,GAAXC,+DACWD,GAAXC,yDAsBOD,GAAPE,qHC1BgB1C,UAA+B2C,EAEhDhB,OAAOF,GACHI,GAAY,KACRpB,KAAKK,QAAQ8B,OAAO,EAAGnC,KAAKK,QAAQ+B,QACpCpC,KAAKK,QAAQgC,QAAQrB,MAI7BxB,YAAYC,EAAqBC,EAAiBC,EAAkBC,GAChE0C,MAAM7C,EAASC,EAAYC,EAASC,GAEpCI,KAAKiB,OAILjB,KAAKY,YAAYyB,KAAKX,GAClB,KAAgB1B,KAAKL,WACrB,KAAQK,KAAKiB,WAIjBjB,KAAKY,YAAYyB,KAAKE,EAAQvC,KAAKC,cAAeuC,IAI9C,GAHmB,OAAfA,EAAOC,MACPzC,KAAK0C,UAAUF,EAAOG,UAEP,UAAfH,EAAOC,KAAkB,CACzB,IAAI5B,EAAO2B,EAAOI,KACdf,EAAOW,EAAOK,SAClB7C,KAAKc,mBAAmBD,YACjBb,KAAKc,mBAAmBD,GAC/B,IAAIiC,EAAI9C,KAAKI,MAAM2C,QAAQlB,IACjB,GAANiB,GACA1B,GAAY,KACRpB,KAAKI,MAAM+B,OAAOW,EAAG,WAMrC,IAAI,IAAKE,EAAInB,KAAQ7B,KAAKC,aACtBD,KAAK0C,UAAUb,GAIfa,UAAUb,GACd7B,KAAKc,mBAAmBe,EAAIhB,MAAQY,GAChC,KACI,IAAIwB,EAASjD,KAAK4B,aAAaC,GAC3BiB,EAAI9C,KAAKI,MAAM2C,QAAQlB,GAEtBoB,IAAgB,GAANH,GAAS1B,GAAY,IAAMpB,KAAKI,MAAMiC,KAAKR,KAErDoB,IAAgB,GAANH,GAAS1B,GAAY,IAAMpB,KAAKI,MAAM+B,OAAOW,EAAG,eC/C1DvD,UAA+B2D,EAEhDhC,OAAOF,GACHI,GAAY,KACRpB,KAAKK,QAAQ8B,OAAO,EAAGnC,KAAKK,QAAQ+B,QACpCpC,KAAKK,QAAQgC,QAAQrB,MAI7BxB,YAAYC,EAAqBC,EAAiBC,EAAkBC,EAAqBC,EAAeC,GACpGwC,MAAM7C,EAASC,EAAYC,EAASC,QACnBuD,IAAdnD,KAAKH,OAAoBG,KAAKH,KAAO,QAClBsD,IAAnBnD,KAAKF,YAAyBE,KAAKF,UAAY,IAElDE,KAAKiB,OAGLjB,KAAKY,YAAYyB,KAAKX,GAClB,KAAe,CACX0B,OAAkBpD,KAAKL,QACvBC,SAAkBI,KAAKJ,SACvBC,KAAkBG,KAAKH,KACvBC,UAAkBE,KAAKF,cAE3B,KAAQE,KAAKiB,WA4BbyB,UAAUb,GACd7B,KAAKc,mBAAmBe,EAAIhB,MAAQY,GAChC,KACI,IAAI4B,EAAwBrD,KAAK4B,aAAaC,GAC9C,GAAIwB,EAAuB,CACvB,IAAIP,EAAI9C,KAAKI,MAAM2C,QAAQlB,GACvBwB,IAA+B,GAANP,GACzB1B,GAAY,IAAMpB,KAAKI,MAAMiC,KAAKR,KAEjCwB,IAA+B,GAANP,GAC1B1B,GAAY,IAAMpB,KAAKI,MAAM+B,OAAOW,EAAG,gBC5EzCQ,EAsGlB9D,eAAgB+D,GAHhBxD,mGACAA,wFAAoB,IAAIyD,MAjEhBC,cAAc5B,GAElB,GAAiB,OAAbA,EAAIhB,KACJ,MAAM,IAAI6C,MAAM,0BACpB,GAAI1D,KAAK2D,MAAMC,IAAI/B,EAAIhB,MACnB,MAAM,IAAI6C,MAAM,mBAAmB7B,EAAIhB,+CAA+Cb,KAAK4C,UAE/F5C,KAAK2D,MAAME,IAAIhC,EAAIhB,KAAMgB,GAIrB4B,aAAa5B,GACjB,GAAiB,OAAbA,EAAIhB,KAAR,CAEA,IAAKb,KAAK2D,MAAMC,IAAI/B,EAAIhB,MACpB,MAAM,IAAI6C,MAAM,mBAAmB7B,EAAIhB,0CAA0Cb,KAAK4C,UAC1F5C,KAAK2D,MAAMG,OAAOjC,EAAIhB,OAG1B4C,YAAY9D,EAAUC,GAClB,OAAO,IAAIL,EAAaS,KAAKP,QAASO,KAAK2D,MAAOhE,EAASC,GAG/D6D,gBAAgBL,EAASxD,EAAqBC,EAAeC,GACzD,OAAO,IAAIiE,EAAU/D,KAAKP,QAASO,KAAK2D,MAAOP,EAAQxD,EAAUC,EAAMC,GAGnE2D,mBAAmBO,GACvB,IACInC,EADAhB,EAAOb,KAAKa,KAAKmD,GAWrB,OATIhE,KAAK2D,MAAMC,IAAI/C,GACfO,GAAY,KACRS,EAAM7B,KAAK2D,MAAMM,IAAIpD,GACrBgB,EAAIqC,cAAcF,MAItBnC,EAAM,IAAU7B,KAAMgE,GAEnBnC,EAGX4B,oBAEI,IAAK,IAAI5B,KAAO7B,KAAK2D,MAAMQ,SACvB,IAAK,IAAIC,KAAiBpE,KAAKqE,IAAIC,OAC/BzC,EAAIuC,GAAiB,KAKjCX,YAAY5B,EAAKwC,GACb,IAAIrB,EAAK,QACGG,IAARkB,IAAmBA,EAAME,MAAMC,KAAKxE,KAAKqE,IAAIC,SACjD,IAAK,IAAIF,KAAiBC,EAAK,CAE3B,GAA2B,OAAvBxC,EAAIuC,SAAkDjB,IAAvBtB,EAAIuC,GACnC,OAAO,KACXpB,GAAM,GAAGnB,EAAIuC,KAAiBpE,KAAKyE,eAGvC,OADAzB,EAAKA,EAAG0B,MAAM,GAAK1E,KAAKyE,aAAmB,QACpCzB,EAQGnC,WACV,OAAOb,KAAK2E,MAAM9D,KAAKb,MAGvB2E,YACA,OAAa3E,KAAKR,YAAaoF,UAG/BZ,cACA,IAAIA,EAAe,GACnB,IAAI,IAAII,KAAiBpE,KAAK2E,MAAMN,IAAIC,YACTnB,IAAxBnD,KAAKoE,KACJJ,EAAQI,GAAiBpE,KAAKoE,IAGtC,IAAI,IAAIS,KAAc7E,KAAK2E,MAAMG,YACL3B,IAArBnD,KAAK6E,KACJb,EAAQa,GAAc7E,KAAK6E,IAInC,OADAb,EAAQnD,KAAOb,KAAKa,KACbmD,EAGPe,iBACA,IAAIA,GAAa,EACjB,IAAI,IAAIF,KAAc7E,KAAK2E,MAAMG,OACzB9E,KAAK6E,IAAe7E,KAAKgF,YAAYH,KACrCE,GAAa,GAGrB,OAAOA,EAGXhE,eAAiB,aAAaf,KAAK2E,MAAMlF,QAAQwF,OAAOjF,MACxDe,eAAiB,aAAaf,KAAK2E,MAAMlF,QAAQyF,OAAOlF,MACxDe,eAAiB,aAAaf,KAAK2E,MAAMlF,QAAQqE,OAAO9D,MACxDe,aAAiB,OAAqB,OAAdf,KAAKa,KAAgBb,KAAKiF,SAAWjF,KAAKkF,SAE1DhB,cAAcF,GAElB,IAAK,IAAII,KAAiBpE,KAAK2E,MAAMN,IAAIC,YACNnB,IAA3Ba,EAAQI,IAAgCpE,KAAKoE,IAAkBJ,EAAQI,KACvEpE,KAAKoE,GAAiBJ,EAAQI,IAItC,IAAI,IAAIS,KAAc7E,KAAK2E,MAAMG,YACD3B,IAAxBa,EAAQa,KACR7E,KAAK6E,GAAcb,EAAQa,cAS3BF,EAAMnF,GAClB,IAAI2F,EAAW3F,EAEf2F,EAASxB,MAAQ3B,EAAW,IAAIwB,KAGhC,IAAI4B,EAAU,YAAa7B,GACvB,IAAI8B,EAAU,cAAcF,EAAW3F,eAAgB+D,GAAQjB,SAASiB,KACpE8B,EAAET,UAAYO,EAElB,IAAItD,EAAQ,IAAIwD,EACZV,EAAQ9C,EAAI8C,MAGhB,GAFAxE,EAAe0B,QAEGsB,IAAdwB,EAAMN,IACN,8CAA+CM,EAAM/B,OAGzD,IAAK,IAAIwB,KAAiBO,EAAMN,IAAIC,OAChCK,EAAMN,IAAIJ,IAAIG,GAAekB,UAAUzD,EAAKuC,GAGhD,IAAK,IAAIS,KAAcF,EAAMG,OACzBH,EAAMG,OAAOD,GAAYS,UAAUzD,EAAKgD,GAG5C,IAAK,IAAIA,KAAcF,EAAMY,UACzBZ,EAAMY,UAAUV,GAAYS,UAAUzD,EAAKgD,GA0B/C,OAvBAzD,GAAY,KAER,GAAImC,EAAK,GAAI,CACT,IAAIS,EAAUT,EAAK,GAEnB,IAAK,IAAIa,KAAiBO,EAAMN,IAAIC,YACDnB,IAA3Ba,EAAQI,KACRvC,EAAIuC,GAAiBJ,EAAQI,IAIrC,IAAK,IAAIS,KAAcF,EAAMG,YACG3B,IAAxBa,EAAQa,KACRhD,EAAIgD,GAAcb,EAAQa,IAKtChD,EAAImD,YAAc,GAClB,IAAK,IAAIH,KAAcF,EAAMG,OACzBjD,EAAImD,YAAYH,GAAchD,EAAIgD,MAGnChD,GAKX,OAFAuD,EAAER,UAAYO,EACdC,EAAEI,UAAYL,EAASK,UAChBJ,EA3NPrF,wFAAsC,MAuG5BgC,GAAT0D,8EAuCO1D,GAAPE,6HA5GOF,GAAPE,mDAA0BqB,oDAWnBvB,GAAPE,mDAAyBqB,mDAgBlBvB,GAAPE,kFAAoCqB,gCClEVoC,EAU3BlG,YAAYmF,GAFZ5E,6FAGIC,KAAK2E,MAAQA,EAGjB5D,aAAac,GACT,IAAImC,QAAgBhE,KAAK2F,SAAS9D,EAAImC,SAEtC,OADAnC,EAAIqC,cAAcF,GACXnC,EAGXd,aAAac,GACT,IAAImC,QAAgBhE,KAAK4F,SAAS/D,EAAImC,SAEtC,OADAnC,EAAIqC,cAAcF,GACXnC,EAGXd,aAAac,SACW7B,KAAK6F,SAAShE,EAAImC,SAGtC,IAAI,IAAII,KAAiBpE,KAAK2E,MAAMN,IAAIC,OACpCzC,EAAIuC,GAAiB,KACzB,OAAOvC,EAGXd,WAAW+E,EAAQlG,EAAWmG,EAAQC,GAClC,IAAIC,QAAiBjG,KAAKkB,OAAO4E,EAAOlG,EAAUmG,EAAOC,GACrDhF,EAAY,GAChB,IAAK,IAAIgD,KAAWiC,EAChBjF,EAAKqB,KAAKrC,KAAK2E,MAAMuB,YAAYlC,IAErC,OAAOhD,GCpCR,IAAImF,EAAa,SAEXC,UAAsCV,EAI/ClG,YAAYmF,GACRrC,MAAMqC,GAHV5E,kGAIIC,KAAKqG,WAAa1B,EAAMC,UAAUhC,KAClCuD,EAAMnG,KAAKqG,YAAc,GAG7BtF,eAAec,GACX,GAAiB,OAAbA,EAAIhB,KAAe,CAEnB,IAAIwD,EAAM,CAAC,GACX,IAAI,IAAIrB,KAAMjD,OAAOuE,KAAK6B,EAAMnG,KAAKqG,aACjChC,EAAIhC,KAAKiE,SAAStD,IAEtB,IAAIuD,EAAMC,KAAKD,IAAIE,MAAM,KAAMpC,GAC/B,IAAI,IAAIqC,KAAiB1G,KAAK2E,MAAMN,IAAIC,OACpCzC,EAAI6E,GAAiBH,EAAM,EAKnC,OAFA1E,EAAIhB,KAAOb,KAAK2E,MAAM9D,KAAKgB,GAC3BsE,EAAMnG,KAAKqG,YAAYrG,KAAK2E,MAAM9D,KAAKgB,IAAQA,EACxCA,EAGXd,eAAec,GAEX,OADAsE,EAAMnG,KAAKqG,YAAYxE,EAAIhB,MAAQgB,EAC5BA,EAGXd,eAAec,GAEX,cADOsE,EAAMnG,KAAKqG,YAAYxE,EAAIhB,MAC3BgB,EAGXd,aAAc+E,EAAQlG,EAAWmG,EAAQC,GACrC,IAAIC,EAAWlG,OAAOoE,OAAOgC,EAAMnG,KAAKqG,aAIxC,YAHclD,IAAV4C,QAAkC5C,IAAX6C,IACvBC,EAAWA,EAASvB,MAAMsB,EAAQA,EAAOD,IAEtCE,YASCU,IACZ,OAAQC,IACJ,IAAInH,EAAU,IAAI2G,EAAaQ,GAC/BA,EAAIhC,UAAUnF,QAAUA,GCnDhC,SAASoH,EAAUhF,EAAMgD,GAErBiC,EAAiBjF,EAAK,CAClBgD,CAACA,GAAa,OAIlBkC,EAAUlF,EAAKgD,GAAarC,IACxB,GAAwB,OAApBA,EAAOG,UAAyC,OAApBd,EAAIgD,GAChC,MAAM,IAAInB,MAAM,+BAA+BmB,MAAehD,EAAIgD,SAAkBrC,EAAOG,YAC/F,GAAwB,OAApBd,EAAIgD,IAA4C,OAApBrC,EAAOG,SACnC,IACId,EAAI8C,MAAMqC,MAAMnF,GAEpB,MAAOoF,GACH,IAAIC,EAAe,mBAAmBrF,EAAIhB,uCAAuCgB,EAAI8C,MAAM/B,SAC3F,GAAIqE,EAAIrE,OAASsE,EACb,MAAMD,EAGlB,OAAOzE,KAIXD,EAAQV,EAAKgD,GAAarC,IAEL,OAAbX,EAAIhB,MACJgB,EAAI8C,MAAMwC,OAAOtF,eAMLmB,EAAG4D,EAAK/B,GAC5B,IAAIF,EAAQiC,EAAIpH,iBACE2D,IAAdwB,EAAMN,MAAmBM,EAAMN,IAAM,IAAIb,KAC7CmB,EAAMN,IAAIR,IAAIgB,EAAY,CAAES,UAAWuB,aC9C3BO,EAAYvF,EAAKgD,GAE7BiC,EAAiBjF,EAAK,CAAEgD,CAACA,GAAahD,EAAIgD,cAItBwC,EAAMT,EAAK/B,GAC/B,IAAIF,EAAQiC,EAAIpH,iBACK2D,IAAjBwB,EAAMG,SAAsBH,EAAMG,OAAS,IAE/CH,EAAMG,OAAOD,GAAc,CAAES,UAAW8B,GCX5C,SAASE,EAAczF,EAAKgD,GACxB,IAAI0C,GAAY,EACZC,EAAW3F,EAAI8C,MAAMY,UAAUV,GAAY2C,SAC3CC,EAAoBD,EAASC,cAC7BC,EAAoBF,EAASE,kBAGjCZ,EAAiBjF,EAAK,CAClBgD,CAACA,GAAa,OAIlBnD,GAEI,KACI,IAAIsB,EAAKyE,EAAc5G,KAAKgB,EAAK6F,GACjC,OAAO1E,EAAKyE,EAAc9D,MAAMM,IAAIjB,GAAM,QAG9C,CAAC2E,EAAaC,EAAMlG,KAChBG,EAAIgD,GAAc8C,GAA4B,QAKtDZ,EAAUlF,EAAKgD,GAAarC,IACxB,GAAwB,OAApBA,EAAOG,UAAuBH,EAAOG,SAASgC,OAAS8C,EACvD,MAAM,IAAI/D,MAAM,iCAAiC+D,EAAc7E,iBAEnE,OAAOJ,KAGXD,EAAQV,EAAKgD,GAAarC,IACtB,IAAIqF,EAAkBrF,EAAOG,SACzBmF,EAAkBtF,EAAOK,SAE7B,GAAIgF,IAAoBC,IAAmBP,EAA3C,CAGAA,GAAY,EACZ,IACI,GAAwB,OAApB/E,EAAOG,SAEP,IAAK,IAAIoF,KAAWL,EAChB7F,EAAIkG,GAAW,SAGlB,CAGD,IAAIC,EAAezD,MAAMC,KAAKhC,EAAOG,SAASgC,MAAMN,IAAIC,QACxD,IAAK,IAAIxB,EAAI,EAAGA,EAAI4E,EAAkBtF,OAAQU,IAEtCjB,EAAI6F,EAAkB5E,KAAON,EAAOG,SAASqF,EAAQlF,MACrDjB,EAAI6F,EAAkB5E,IAAON,EAAOG,SAASqF,EAAQlF,KAGjEyE,GAAY,EAEhB,MAAMpG,GAEF,GAAwB,OAApBqB,EAAOK,SACP,IAASC,EAAI,EAAGA,EAAI4E,EAAkBtF,OAAQU,IAC1CjB,EAAI6F,EAAkB5E,IAAM,SAG/B,CACD,IAAIkF,EAAUxF,EAAOK,SAAS8B,MAAMN,IACpC,IAASvB,EAAI,EAAGA,EAAI4E,EAAkBtF,OAAQU,IAC1CjB,EAAI6F,EAAkB5E,IAAMN,EAAOK,SAASmF,EAAQlF,IAI5D,MADAyE,GAAY,EACNpG,EAINqG,EAASS,MACLH,IACAA,EAAgBN,EAASS,KAAO,MAEhCJ,IACAA,EAAgBL,EAASS,KAAOpG,iBAQxBqG,EAAQT,KAAuBC,GAEnD,OADAD,EAAgBA,EAAc7C,UACvB,SAAUgC,EAAU/B,GACvB,IAAIF,EAAQiC,EAAIpH,iBACQ2D,IAApBwB,EAAMY,YAAyBZ,EAAMY,UAAY,IAErDZ,EAAMY,UAAUV,GAAc,CAC1BS,UAAWgC,EACXE,SAAU,CACNC,cAAeA,EAEfC,kBAAmBA,EAAkBtF,OAASsF,EAAoB,CAAC,GAAG7C,WCpGtF,SAASsD,EAAUtG,EAAYgD,GAE3B,IAAI0C,GAAY,EACZa,EAA0BvG,EAAI8C,MAAMY,UAAUV,GAAY2C,SAASY,aACnEC,EAA0BxG,EAAI8C,MAAMY,UAAUV,GAAY2C,SAASc,yBAGvExB,EAAiBjF,EAAK,CAClBgD,CAACA,GAAa,OAIlBkC,EAAUlF,EAAUgD,GAAarC,IAC7B,GAAwB,OAApBA,EAAOG,UAAuBH,EAAOG,SAASgC,QAAUyD,EACpD,MAAM,IAAI1E,MAAM,iCAAiC0E,EAAaxF,iBACtE,OAAOJ,KAIXD,EAAQV,EAAKgD,GAAarC,IACtB,IAAI+F,EAAiB/F,EAAOK,SACxB2F,EAAiBhG,EAAOG,SAE5B,GAAI6F,IAAmBD,IAAkBhB,EAAzC,CAGAA,GAAY,EACZ,IAEI,GAAIgB,EACA,IAAK,IAAIR,KAAWM,EAChBE,EAAeR,GAAW,KAIlC,GAAIS,EAAgB,CAChB,IAAIR,EAAezD,MAAMC,KAAK3C,EAAI8C,MAAMN,IAAIC,QAC5C,IAAK,IAAIxB,EAAI,EAAGA,EAAIuF,EAAwBjG,OAAQU,IAE5C0F,EAAeH,EAAwBvF,KAAOjB,EAAImG,EAAQlF,MAC1D0F,EAAeH,EAAwBvF,IAAMjB,EAAImG,EAAQlF,KAGrEyE,GAAY,EAEhB,MAAMpG,kBAqBU8G,EAAIG,KAAsBE,GAE9C,OADAF,EAAeA,EAAaxD,UACrB,SAAUgC,EAAU/B,GACvB,IAAIF,EAAQiC,EAAIpB,UAAUhG,iBACF2D,IAApBwB,EAAMY,YAAyBZ,EAAMY,UAAY,IAErD+C,EAA2BA,EAAyBlG,OAASkG,EAA0B,CAAC,GAAG3D,EAAM/B,KAAK6F,oBACtG9D,EAAMY,UAAUV,GAAc,CAC1BS,UAAW6C,EACXX,SAAU,CACNY,aAAcA,EACdE,yBAA0BA,IAKlC/F,EAAQ6F,EAAazE,OAAQ+E,IACzB,IAAIC,EACJ,OAAQD,EAAcjG,MAClB,IAAK,MACDkG,EAAaD,EAAc/F,SAC3BgG,EAAWC,UAAU/E,IAAI,OAAOgB,IAAcpD,GAAQ,KAClD,IAAII,EAAO8C,EAAMhB,MAAMM,IAAIU,EAAM9D,KAAK8H,EAAYL,IAC9CzG,GAMAT,GAAY,KAAQS,EAAIgD,GAAc8D,SAG9C,MACJ,IAAK,SACDA,EAAaD,EAAc7F,SACvB8F,EAAWC,UAAU3E,IAAI,OAAOY,OAChC8D,EAAWC,UAAU3E,IAAI,OAAOY,IAAhC8D,GACAA,EAAWC,UAAU9E,OAAO,OAAOe,MAEvC,IAAIhD,EAAO8C,EAAMhB,MAAMM,IAAIU,EAAM9D,KAAK8H,EAAYL,IAC9CzG,GACAT,GAAY,KAAQS,EAAIgD,GAAc,aC3G9D,SAASgE,EAAWhH,EAAYgD,GAE5B,IAAI0C,GAAY,EACc1F,EAAI8C,MAAMY,UAAUV,GAAY2C,SAASY,aACvE,IAAIC,EAA0BxG,EAAI8C,MAAMY,UAAUV,GAAY2C,SAASc,yBAGvExB,EAAiBjF,EAAK,CAClBgD,CAACA,GAAa,KAIlBkC,EAAUlF,EAAIgD,IAAcrC,GAajBA,IAIXD,EAAQV,EAAIgD,IAAcrC,IACtB,GAAoB,WAAhBA,EAAOC,KACP,OAEJ,IAAIqG,EAAkBtG,EAAOuG,QACzBC,EAAkBxG,EAAOyG,MAE7B1B,GAAY,EACZ,IAEI,IAAI,IAAIgB,KAAkBO,EACtB,IAAK,IAAIf,KAAWM,EAChBE,EAAeR,GAAW,KAElC,IAAIC,EAAezD,MAAMC,KAAK3C,EAAI8C,MAAMN,IAAIC,QAC5C,IAAI,IAAIkE,KAAkBQ,EACtB,IAAK,IAAIlG,EAAI,EAAGA,EAAIuF,EAAwBjG,OAAQU,IAE5C0F,EAAeH,EAAwBvF,KAAOjB,EAAImG,EAAQlF,MAC1D0F,EAAeH,EAAwBvF,IAAOjB,EAAImG,EAAQlF,KAGtEyE,GAAY,EAEhB,MAAMpG,iBAoBU+H,EAAKd,KAAsBE,GAC/C,OAAO,SAAU1B,EAAU/B,GACvB,IAAIF,EAAQiC,EAAIpB,UAAUhG,iBACF2D,IAApBwB,EAAMY,YAAyBZ,EAAMY,UAAY,IAErD+C,EAA2BA,EAAyBlG,OAASkG,EAA0B,CAAC,GAAG3D,EAAM/B,KAAK6F,oBACtG9D,EAAMY,UAAUV,GAAc,CAC1BS,UAAWuD,EACXrB,SAAU,CACNY,aAAcA,EACdE,yBAA0BA,IAKlC/F,EAAQ6F,EAAazE,OAAQ+E,IACzB,IAAIC,EACJ,OAAQD,EAAcjG,MAClB,IAAK,MACDkG,EAAaD,EAAc/F,SAC3BgG,EAAWC,UAAU/E,IAAI,QAAQgB,IAAcpD,GAAQ,KACnD,IAAII,EAAO8C,EAAMhB,MAAMM,IAAIU,EAAM9D,KAAK8H,EAAYL,IAClD,GAAIzG,EAAK,EAEK,GADAA,EAAIgD,GAAY9B,QAAQ4F,IAE9BvH,GAAY,KAAQS,EAAIgD,GAAYxC,KAAKsG,WAGrD,MACJ,IAAK,SACDA,EAAaD,EAAc7F,SACvB8F,EAAWC,UAAU3E,IAAI,QAAQY,OACjC8D,EAAWC,UAAU3E,IAAI,QAAQY,IAAjC8D,GACAA,EAAWC,UAAU9E,OAAO,QAAQe,MAExC,IAAIhD,EAAO8C,EAAMhB,MAAMM,IAAIU,EAAM9D,KAAK8H,EAAYL,IAClD,GAAIzG,EAAK,CACL,MAAMiB,EAAIjB,EAAIgD,GAAY9B,QAAQ4F,GAC9B7F,GAAK,GACL1B,GAAY,KAAQS,EAAIgD,GAAY1C,OAAOW,EAAG"}
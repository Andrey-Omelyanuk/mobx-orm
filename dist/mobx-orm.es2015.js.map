{"version":3,"file":"mobx-orm.es2015.js","sources":["../src/query.ts","../src/model.ts","../src/adapters/local.ts","../src/adapters/rest.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { autorun, makeObservable, observable } from \"mobx\"\nimport { Model } from \"./model\"\n\n\nexport default class Query<M extends Model> {\n\n    @observable items       : Model[] = []   // TODO: do not allow to change items outside\n    @observable filters     : object = {}\n    @observable order_by    : string[] = []\n    @observable page        : number = 0\n    @observable page_size   : number = 50\n    @observable is_ready    : boolean = false\n    @observable error       : string = '' \n\n    private autoUpdateDisposer\n\n    constructor(model, filters?, order_by?, page?, page_size?) {\n        makeObservable(this)\n        this.autoUpdateDisposer = autorun(async () => {\n            this.is_ready = false\n            try {\n                this.items = await model.adapter.load(\n                    this.filters, \n                    this.order_by, \n                    this.page_size, \n                    this.page*this.page_size\n                    )\n            }\n            catch (e) {\n                this.error = e\n            }\n            this.is_ready = true\n        }) \n    }\n\n    destroy() {\n        this.autoUpdateDisposer()\n        // TODO: memory leak? we have to destroy observebles?\n    }\n}\n","import { action, computed, makeObservable, observable, runInAction } from 'mobx'\nimport Adapter from './adapters/adapter'\nimport Query from './query'\n\n\nexport abstract class Model {\n\n    // this private static properties will be copied to real model in the model decorator\n    private static ids          : any[]\n    private static adapter      : Adapter<Model>\n    private static cache        : Map<string, Model>\n    private static fields       : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }\n    }\n\n\n    static load(filter = {}, order_by = {}, page = 0, page_size = 50) {\n        return new Query(this, filter, order_by, page, page_size)\n    }\n\n    static clearCache() {\n        // we need it for run triggers on id fields \n        for (let obj of this.cache.values()) {\n            for (let id_field_name of this.ids) {\n                obj[id_field_name] = null\n            }\n        }\n    }\n\n    // TODO push it to utils\n    static __id(obj, ids: []) : string | null {\n        let id = '' \n        for (let id_name of ids) {\n            // if any id field is null then we should return null because id is not complite\n            if (obj[id_name] === null || obj[id_name] === undefined) \n                return null\n            id += `${obj[id_name]} :`\n        }\n        return id\n    }\n\n    private readonly _init_data\n    private disposers = new Map()\n\n    constructor(init_data?) {\n        // we have to save init data for detect changes\n        this._init_data = init_data ? init_data : {}\n    }\n\n    // build id string from ids fields and return it\n    @computed get __id() : string | null {\n        return Model.__id(this, this.model.ids)\n    }\n\n    // TODO: any is band-aid \n    get model() : any {\n        return this.constructor\n    }\n\n    // create or update object in the repo \n    async save() {\n        return this.model.adapter.save(this)\n    }\n\n    // delete object from the repo \n    async delete() {\n        await this.model.adapter.delete(this)\n        // reset ids\n        for(let id_name of this.model.ids)\n            this[id_name] = null\n    }\n\n    // add obj to the cache\n    @action inject() {\n        if (this.__id === null)                    \n            throw new Error(`Object should have id!`)\n        if (this.model.cache.has(this.__id)) {\n            debugger\n            throw new Error(`Object with id \"${this.__id}\" already exist in the cache of model: \"${this.model.name}\")`)\n        }\n        this.model.cache.set(this.__id, this)\n    }\n\n    // remove obj from the cache\n    @action eject() {\n        if (this.__id === null)\n            return                   \n        if (!this.model.cache.has(this.__id)) \n            throw new Error(`Object with id \"${this.__id}\" not exist in the cache of model: ${this.model.name}\")`)\n        this.model.cache.delete(this.__id)\n    }\n}\n\n\n// Decorator\nexport function model(constructor) {\n    var original = constructor\n\n    original.cache = observable(new Map())\n    // makeObservable(original, { cache: observable })\n\n    // the new constructor\n    let f : any = function (...args) {\n        let c : any = function () { return original.apply(this, args) }\n        c.__proto__ = original\n        c.prototype = original.prototype\n        let obj = new c()\n        makeObservable(obj)\n\n        // save default values from class declaration to init_data\n        for (let field_name in obj.model.fields) {\n            if (obj._init_data[field_name] === undefined && obj[field_name] !== undefined) {\n                obj._init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply fields decorators\n        for (let field_name in obj.model.fields) {\n            obj.model.fields[field_name].decorator(obj, field_name)\n        }\n\n        runInAction(() => {\n            // push init_data to object \n            for (let field_name in obj._init_data) {\n                obj[field_name] = obj._init_data[field_name]\n            }\n        })\n\n        return obj\n    }\n\n    f.__proto__ = original\n    f.prototype = original.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { Model } from '../model'\nimport Adapter  from './adapter'\n\n/*\n*/\n\nlet store = {}\n\nexport class LocalAdapter<M extends Model> implements Adapter<M> {\n    constructor(\n        private cls,\n        private store_name: string) {\n        store[store_name] = {}\n    }\n\n    async save(obj: M) : Promise<M> {\n        // create \n        if (obj.__id === null) {\n            // calculate and set new ID\n            let ids = [0]\n            for(let id of Object.keys(store[this.store_name])) {\n                ids.push(parseInt(id))\n            }\n            let max = Math.max.apply(null, ids)\n            for(let name_id of obj.model.ids) {\n                obj[name_id] = max + 1\n            }\n            store[this.store_name][obj.__id] = obj\n        }\n        // edit\n        else {\n            store[this.store_name][obj.__id] = obj\n        }\n        return obj\n    }\n    async delete(obj: M) : Promise<any> {\n        delete store[this.store_name][obj.__id]\n    }\n\n    load (where={}, order_by=[], limit=50, offset = 0) : Promise<M[]> {\n        throw('Not implemented')\n    }\n}\n\n// model decorator\nexport function local(api: string) {\n    return (cls) => {\n        let adapter = new LocalAdapter(cls, api)\n        cls.__proto__.adapter = adapter \n    }\n}\n","import { Model } from '../model'\nimport Adapter  from './adapter'\n\n/*\n*/\n\nexport class RestAdapter<M extends Model> implements Adapter<M> {\n    constructor(\n        private cls,\n        private http,\n        private api: string) {\n    }\n\n    async save(obj: M) : Promise<M> {\n        // gather data from obj\n        let data = {}\n        for(let field_name in obj.model.fields) {\n            if (obj[field_name] !== null) {\n                data[field_name] = obj[field_name]\n            }\n        }\n\n        if (obj.__id === null) {\n            // create \n            data = await this.http.post(`${this.api}/`, data)\n            // update values\n            for(let field_name in obj.model.fields) {\n                obj[field_name] = data[field_name]\n            }\n        }\n        else {\n            // edit\n            data = await this.http.put(`${this.api}/${obj.__id}/`, data)\n            // update values\n            for(let field_name in obj.model.fields) {\n                // do not touch the ids\n                if (!obj.model.ids.includes(field_name)) {\n                    obj[field_name] = data[field_name]\n                }\n            }\n        }\n        // push saved data to obj\n        return obj\n    }\n    async delete(obj: M) : Promise<any> {\n        return this.http.delete(`${this.api}/${obj.__id}/`)\n    }\n\n    async load (where={}, order_by=[], limit=50, offset = 0) : Promise<M[]> {\n        // build query string \n        let query = ''\n\n        let data = await this.http.get(`${this.api}/?${query}`)\n\n        // init objects from data \n        let objs : M[] = []\n        for (let obj of data) {\n            objs.push(new this.cls(obj))\n        }\n        return objs\n    }\n}\n\n// model decorator\nexport function rest(http, api: string) {\n    return (cls) => {\n        let adapter = new RestAdapter(cls, http, api)\n        cls.__proto__.adapter = adapter \n    }\n}\n","import { observable, observe, intercept, extendObservable } from 'mobx'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to cache then you can use this \nnew Obj({id: x, ...})\n*/\n\nfunction field_ID (obj , field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // before changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && obj[field_name] !== null)\n            throw new Error(`You cannot change id field: ${field_name}. ${obj[field_name]} to ${change.newValue}`)\n        if (obj[field_name] !== null && change.newValue === null) {\n            try {\n                obj.eject()\n            }\n            catch (err) {\n                let ignore_error = `Object with id \"${obj.__id}\" not exist in the model cache: ${obj.model.name}\")`\n                if (err.name !== ignore_error)\n                    throw err\n            }\n        }\n        return change\n    })\n\n    // after changes\n    observe(obj, field_name, (change) => {\n        // if id is complete\n        if (obj.__id !== null) \n            obj.inject()\n    })\n\n}\n\n\nexport default function id(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n    if (model.ids    === undefined) model.ids = []\n\n    model.fields[field_name] = { decorator: field_ID }  // register field \n    model.ids.push(field_name)                          // register id\n\n}\n","import { extendObservable } from 'mobx'\n\n\n\nexport function field_field(obj, field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n}\n\n\nexport default function field(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n\n    model.fields[field_name] = { decorator: field_field }  // register field \n}\n","// import 'reflect-metadata'\nimport {intercept, observe, extendObservable, observable, autorun, when, reaction} from 'mobx'\n\nfunction field_foreign(obj, field_name) {\n    let edit_mode = false\n    let settings = obj.model.fields[field_name].settings\n    let foreign_model     = settings.foreign_model\n    let foreign_ids_names = settings.foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    reaction(\n        // watch on foreign cache for foreign object\n        () => {\n            let id = foreign_model.__id(obj, foreign_ids_names)\n            return id ? foreign_model.cache.get(id) : null\n        },\n        // update foreign field\n        (foreign_obj, prev, reaction) => {\n            obj[field_name] = foreign_obj ? foreign_obj : null \n        })\n\n    // Setter\n    // 1. checks before set new changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor == foreign_model.__proto__))\n            throw new Error(`You can set only instance of \"${foreign_model.__proto__.name}\" or null`)\n        return change\n    })\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let new_foreign_obj = change.newValue\n        let old_foreign_obj = change.oldValue\n\n        if (new_foreign_obj === old_foreign_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n        edit_mode = true\n        try {\n            if (change.newValue === null) {\n                // if foreign set to null then reset ids on the obj\n                for (let id_name of foreign_ids_names) {\n                    obj[id_name] = null \n                }\n            }\n            else {\n                // if foreign set to obj then update ids from the obj's ids\n                let obj_ids = change.newValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    // do not touch if it the same\n                    if (obj[foreign_ids_names[i]] != change.newValue[obj_ids[i]])\n                        obj[foreign_ids_names[i]]  = change.newValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // rollback changes!\n            if (change.oldValue === null) {\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = null \n                }\n            }\n            else {\n                let obj_ids = change.oldValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n            throw e\n        }\n\n        // if foreign have the one then update the one\n        if (settings.one) {\n            if (old_foreign_obj) {\n                old_foreign_obj[settings.one] = null\n            }\n            if (new_foreign_obj) {\n                new_foreign_obj[settings.one] = obj \n            }\n        }\n\n    })\n}\n\n\nexport default function foreign(foreign_model: any, ...foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.constructor\n        if (model.fields === undefined) model.fields = {}\n        // register field \n        model.fields[field_name] = { \n            decorator: field_foreign,\n            settings: {\n                foreign_model: foreign_model,\n                // if it is empty then try auto detect it (it works only with single id) \n                foreign_ids_names: foreign_ids_names.length ? foreign_ids_names : [`${field_name}_id`]\n            } \n        } \n\n        // TODO finish it\n        // watch on the foreign cache \n        // if foreign obj was created then it should be attached to foreign\n        // if foreign obj was deleted then it should be removed from foreign\n        // e.i. update foreign obj when foreign ids was changed\n        // reaction(() => foreign_model.cache, (value, prev_value, reaction) => {\n        //     debugger\n        // })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_one(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.fields[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.fields[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // 1. checks before set new changes\n    intercept(obj, <any>field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor === remote_model.__proto__))\n                throw new Error(`You can set only instance of \"${remote_model.__proto__.name}\" or null`)\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let old_remote_obj = change.oldValue\n        let new_remote_obj = change.newValue\n\n        if (new_remote_obj === old_remote_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote obj\n            if (old_remote_obj) {\n                for (let id_name of remote_foreign_ids_name) {\n                    old_remote_obj[id_name] = null \n                }\n            }\n            // set foreign ids on the remote obj \n            if (new_remote_obj) {\n                let obj_ids = obj.model.ids \n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]] = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\n\nexport default function one(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.fields === undefined) model.fields = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.fields[field_name] = { \n            decorator: field_one,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`one ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            // TODO: is it not bad?\n                            // if (obj[field_name])\n                            //     // TODO better name of error\n                            //     // TODO add test for this case\n                            //     throw ('One: bad')\n                            runInAction(() => { obj[field_name] = remote_obj })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`one ${field_name}`)) {\n                        remote_obj.disposers.get(`one ${field_name}`)()\n                        remote_obj.disposers.delete(`one ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) \n                        runInAction(() => { obj[field_name] = null })\n                    break\n            }\n        })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_many(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.fields[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.fields[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: []\n    })\n\n    // 1. checks before set new changes\n    intercept(obj[field_name], (change: any) => {\n        // TODO\n        // if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor === remote_model.__proto__))\n        //         throw new Error(`You can set only instance of \"${remote_model.__proto__.name}\" or null`)\n\n        // TODO: if we push exist obj then ignore it? and not duplicate\n        // TODO: create a test for this case \n        // remote obj can be in the many \n        // for (let new_remote_obj of change.added) {\n        //     const i = obj[field_name].indexOf(new_remote_obj)\n        //     if (i == -1)\n        //         throw new Error(`\"${new_remote_obj.model.name}\" id:\"${new_remote_obj.__id}\" alredy in many \"${obj.model.name}\" id:\"${field_name}\"`)\n        // }\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj[field_name], (change:any) => {\n        if (change.type !== 'splice')\n            return \n\n        let old_remote_objs = change.removed\n        let new_remote_objs = change.added\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote objs\n            for(let old_remote_obj of old_remote_objs)\n                for (let id_name of remote_foreign_ids_name)\n                    old_remote_obj[id_name] = null \n            // set foreign ids on the remote objs \n            let obj_ids = obj.model.ids \n            for(let new_remote_obj of new_remote_objs) {\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]]  = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\nexport default function many(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.fields === undefined) model.fields = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.fields[field_name] = { \n            decorator: field_many,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`many ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            const i = obj[field_name].indexOf(remote_obj)\n                            if (i == -1)\n                                runInAction(() => { obj[field_name].push(remote_obj) })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`many ${field_name}`)) {\n                        remote_obj.disposers.get(`many ${field_name}`)()\n                        remote_obj.disposers.delete(`many ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) {\n                        const i = obj[field_name].indexOf(remote_obj)\n                        if (i > -1)\n                            runInAction(() => { obj[field_name].splice(i, 1); })\n                    } \n                    break\n            }\n        })\n    }\n}"],"names":["model","filters","order_by","page","page_size","Object","makeObservable","this","autoUpdateDisposer","autorun","is_ready","_a","adapter","load","items","_b","error","e_1","__decorate","observable","init_data","Map","_init_data","filter","Query","_c","__values","cache","values","obj","_e","ids","id","ids_1","id_name","undefined","Model","__id","constructor","save","delete","_d","Error","has","name","set","computed","action","original","f","_i","args","c","apply","__proto__","prototype","field_name","fields","decorator","runInAction","store","cls","store_name","keys","push","parseInt","max","Math","name_id","where","limit","offset","local","api","LocalAdapter","http","data","post","put","includes","get","objs","data_1","rest","RestAdapter","field_ID","extendObservable","intercept","change","newValue","eject","err","ignore_error","observe","inject","field_field","field","field_foreign","edit_mode","settings","foreign_model","foreign_ids_names","reaction","foreign_obj","prev","new_foreign_obj","old_foreign_obj","oldValue","foreign_ids_names_1","obj_ids","i","length","e","one","foreign","field_one","remote_model","remote_foreign_ids_name","remote_foreign_ids_names","old_remote_obj","new_remote_obj","remote_foreign_ids_name_1","toLowerCase","remote_change","remote_obj","type","disposers","obj_1","field_many","old_remote_objs","removed","new_remote_objs","added","old_remote_objs_1","new_remote_objs_1","many","indexOf","i_1","splice"],"mappings":"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"}
{"version":3,"file":"mobx-orm.es2015.js","sources":["../src/query-base.ts","../src/query.ts","../src/query-page.ts","../src/model.ts","../src/adapters/adapter.ts","../src/adapters/local.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport Adapter from \"./adapters/adapter\"\nimport { Model } from \"./model\"\n\n\nexport default abstract class Query<M extends Model> {\n\n    @observable filters     : object  \n    @observable order_by    : string[]\n    @observable page        : number\n    @observable page_size   : number\n\n    get items      () { return this.__items }\n    get is_loading () { return this.__is_loading  }\n    get is_ready   () { return this.__is_ready    }\n    get error      () { return this.__error       }\n    \n\treadonly __base_cache: any\n\treadonly __adapter: Adapter<M>\n    @observable __items: M[] = []\n    @observable __is_loading  : boolean = false \n    @observable __is_ready    : boolean = false \n    @observable __error       : string = '' \n\n    __disposers = []\n    __disposer_objects = {}\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n\t\tthis.__base_cache = base_cache\n\t\tthis.__adapter    = adapter\n        if (filters  ) this.filters   = filters\n        if (order_by ) this.order_by  = order_by\n        if (page\t ) this.page      = page\n        if (page_size) this.page_size = page_size\n        makeObservable(this)\n    }\n\n    destroy() {\n        for(let disposer of this.__disposers) disposer()\n        for(let __id in this.__disposer_objects) this.__disposer_objects[__id]()\n    }\n\n    abstract __load(objs: M[])\n\n    // use it if everybody should know that the query data is updating\n    @action async load() {\n        this.__is_loading = true\n        try {\n            await this.shadowLoad()\n        }\n        finally {\n            runInAction(() => this.__is_loading = false)\n        }\n    }\n\n    // use it if nobody should know that you load data for the query\n    // for example you need to update the current data on the page and you don't want to show a spinner\n    @action async shadowLoad() {\n        try {\n            let objs = await this.__adapter.load(this.filters, this.order_by, this.page_size, this.page*this.page_size)\n            this.__load(objs)\n            runInAction(() => this.__is_ready = true)\n        }\n        catch(e) {\n            runInAction(() => this.__error = e)\n            throw e\n        }\n    }\n\n    // use it if you need use promise instead of observe is_ready\n    ready(): Promise<Boolean> {\n        return new Promise((resolve, reject) => { \n            autorun((reaction) => {\n                if (this.__is_ready) {\n                    reaction.dispose()\n                    resolve(this.__is_ready) \n                }\n            })\n        })\n    }\n\n    // use it if you need use promise instead of observe is_loading\n    loading(): Promise<Boolean> {\n        return new Promise((resolve, reject) => { \n            autorun((reaction) => {\n                if (!this.__is_loading) {\n                    reaction.dispose()\n                    resolve(!this.__is_loading) \n                }\n            })\n        })\n    }\n\n    __is_matched(obj) {\n        for(let key in this.filters) {\n            if (obj[key] != this.filters[key]) {\n                return false\n            }\n        }\n        return true\n    }\n}\n","import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QeuryBase from './query-base'\n\n\n/*\nReactive items:\n- delete from the cache -> delete from items\n- add to the cache \n    - the new obj is match the filters  -> add the obj to items\n- obj was changed \n    - не было но уже    попадание по фильтрам -> add the obj to items\n    -    было но уже не попадание по фильтрам -> remove the obj from items\n*/\n\nexport default class Query<M extends Model> extends QeuryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[]) {\n        super(adapter, base_cache, filters, order_by)\n\n        this.load() // load when query is created\n\n        // update if filters was changed\n        // watch only filters, if order was changed then we don't need to update, just resort\n        this.__disposers.push(reaction(\n            () => { filter: this.filters },\n            () => { this.load() }\n        ))\n\n        // watch the cache for changes, and update items if needed\n        this.__disposers.push(observe(this.__base_cache, (change: any) => {\n            if (change.type == 'add') {\n                this.watch_obj(change.newValue)\n            }\n            if (change.type == \"delete\") {\n                let __id = change.name\n                let obj  = change.oldValue\n                this.__disposer_objects[__id]()\n                delete this.__disposer_objects[__id]\n                let i = this.items.indexOf(obj)\n                if (i != -1)\n                    runInAction(() => {\n                        this.items.splice(i, 1)\n                    })\n            }\n        }))\n\n        // watch all exist objects of model \n        for(let [id, obj] of this.__base_cache) {\n            this.watch_obj(obj)\n        }\n    }\n\n    private watch_obj(obj) {\n        this.__disposer_objects[obj.__id] = autorun(\n            () => {\n                let should = this.__is_matched(obj)\n                let i = this.items.indexOf(obj)\n                // should be in the items and it is not in the items? add it to the items\n                if ( should && i == -1) runInAction(() => this.items.push(obj))\n                // should not be in the items and it is in the items? remove it from the items\n                if (!should && i != -1) runInAction(() => this.items.splice(i, 1))\n            })\n    }\n\n}\n","import { reaction, action, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QueryBase from './query-base'\n\n\n// TODO: implement need_to_update\n\nexport default class Query<M extends Model> extends QueryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    // TODO: add actions for QueryBase and QueryPage\n    // TODO: Query should know nothing about pages!\n    // @action setFilters(filters : any     ) { this.filters  = filters  }\n    // @action setOrderBy(order_by: string[]) { this.order_by = order_by }\n    // @action firstPage() { this.page = 0 }\n    // @action prevPage () { this.page = this.page < 0 ? this.page - 1 : 0 }\n    // @action nextPage () { this.page = this.page + 1 }\n    // @action lastPage () { this.page = 9999 } // TODO: need to know total row count\n    // @action setPageSize(page_size: number) { this.page_size = page_size }\n\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n        super(adapter, base_cache, filters, order_by)\n        if(this.page === undefined) this.page = 0\n        if(this.page_size === undefined) this.page_size = 50\n\n        this.load() // load when query is created\n\n        // update if query is changed\n        this.__disposers.push(reaction(\n            () => { return { \n                filter          : this.filters, \n                order_by        : this.order_by, \n                page            : this.page, \n                page_size       : this.page_size,\n             }},\n            () => { this.load() }\n        ))\n    }\n}\n","import { field } from 'dist/mobx-orm'\nimport { action, computed, makeObservable, observable, runInAction } from 'mobx'\nimport Adapter   from './adapters/adapter'\nimport QueryBase from './query-base'\nimport Query     from './query'\nimport QueryPage from './query-page'\n\n\nexport type RawObject = any \n\n\nexport abstract class Model {\n    private static id_separator: string = '-'\n    // this private static properties will be copied to real model in the model decorator\n    private static adapter      : Adapter<Model>\n    private static cache        : Map<string, Model>\n    // we have 3 types of fields\n    // - ids (cannot be changed, order of keys is important)\n    // - fields\n    // - relations (not exist on outside)\n    private static ids: Map<string, {\n            // can decorator be different?\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }>\n    private static fields       : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }\n    }\n    // relateions is a list of field only foreign, one or many types\n    private static relations    : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any\n            // there is no serializer of deserializer because \n            // it is derivative and does not come from outside\n        }\n    }\n\n    // add obj to the cache\n    @action static inject(obj: Model) {\n        debugger\n        if (obj.__id === null)                    \n            throw new Error(`Object should have id!`)\n        if (this.cache.has(obj.__id)) {\n            throw new Error(`Object with id \"${obj.__id}\" already exist in the cache of model: \"${this.name}\")`)\n        }\n        this.cache.set(obj.__id, obj)\n    }\n\n    // remove obj from the cache\n    @action static eject(obj: Model) {\n        if (obj.__id === null)\n            return                   \n        if (!this.cache.has(obj.__id)) \n            throw new Error(`Object with id \"${obj.__id}\" not exist in the cache of model: ${this.name}\")`)\n        this.cache.delete(obj.__id)\n    }\n\n    // TODO: implement find method, it should load single object from Adapter\n    // and add find method to Adapter too\n    static async find(filters) : Promise<Model> {\n        return this.adapter.find(filters) \n    }\n\n    static load(filters?, order_by?: string[]): Query<Model>  {\n        return new Query<Model>(this.adapter, this.cache, filters, order_by)\n    }\n\n    static loadPage(filter?, order_by?: string[], page?: number, page_size?: number): QueryPage<Model> {\n        return new QueryPage(this.adapter, this.cache, filter, order_by, page, page_size)\n    }\n\n    // return obj from the cache\n    static get(__id: string) {\n        return this.cache.get(__id)\n    }\n\n    @action static updateCache(raw_obj): Model {\n        let __id = this.__id(raw_obj)\n        let obj\n        if (this.cache.has(__id)) {\n            runInAction(() => {\n                obj = this.cache.get(__id)\n                obj.updateFromRaw(raw_obj)\n            })\n        }\n        else {\n            obj = new (<any>this)(raw_obj)\n        }\n        return obj\n    }\n\n    static clearCache() {\n        // for clear cache we need just to set null into id fields\n        for (let obj of this.cache.values()) {\n            for (let id_field_name of this.ids.keys()) {\n                obj[id_field_name] = null\n            }\n        }\n    }\n\n    static __id(obj, ids?) : string | null {\n        let id = '' \n        if (ids === undefined) ids = Array.from(this.ids.keys()) \n        for (let id_field_name of ids) {\n            // if any id field is null then we should return null because id is not complite\n            if (obj[id_field_name] === null || obj[id_field_name] === undefined) \n                return null\n            id += `${obj[id_field_name]}${this.id_separator}`\n        }\n        id = id.slice(0, -(this.id_separator.length))\n        return id\n    }\n\n    private __init_data: any \n    private disposers = new Map()\n\n    constructor (...args) { }\n\n    @computed get __id() : string | null {\n        return this.model.__id(this)\n    }\n\n    get model() : any {\n        return (<any>this.constructor).__proto__\n    }\n\n    // it is raw_data + ids\n    get raw_obj() : any {\n        let raw_obj: any = this.raw_data\n        for(let id_field_name of this.model.ids.keys()) {\n            if(this[id_field_name] !== undefined) {\n                raw_obj[id_field_name] = this[id_field_name]\n            }\n        }\n        raw_obj.__id = this.__id\n        return raw_obj\n    }\n\n    // data only from fields (no ids)\n    get raw_data() : any {\n        let raw_data: any = {}\n        for(let field_name in this.model.fields) {\n            if(this[field_name] !== undefined) {\n                raw_data[field_name] = this[field_name]\n            }\n        }\n        return raw_data\n    }\n\n    get is_changed() : boolean {\n        let is_changed = false\n        for(let field_name in this.model.fields) {\n            if (this[field_name] != this.__init_data[field_name]) {\n                is_changed = true\n            }\n        }\n        return is_changed \n    }\n\n    async create() { return await this.model.adapter.create(this) }\n    async update() { return await this.model.adapter.update(this) }\n    async delete() { return await this.model.adapter.delete(this) }\n    async save  () { return this.__id === null ? this.create() : this.update() }\n\n    @action refresh_init_data() {\n        if(this.__init_data === undefined) this.__init_data = {}\n        for (let field_name in this.model.fields) {\n            this.__init_data[field_name] = this[field_name]\n        }\n    }\n\n    @action updateFromRaw(raw_obj) {\n        // keys\n        for (let id_field_name of this.model.ids.keys()) {\n            if (raw_obj[id_field_name] !== undefined && this[id_field_name] != raw_obj[id_field_name] ) {\n                this[id_field_name] = raw_obj[id_field_name]\n            }\n        }\n        // fields\n        for(let field_name in this.model.fields) {\n            if (raw_obj[field_name] !== undefined) {\n                this[field_name] = raw_obj[field_name]\n            }\n        }\n    }\n\n}\n\n\n// Decorator\nexport function model(constructor) {\n    var original = constructor\n\n    original.cache = observable(new Map())\n\n    // the new constructor\n    let f : any = function (...args) {\n        let c : any = class extends original { constructor (...args) { super(...args) } }\n            c.__proto__ = original\n\n        let obj   = new c()\n        let model = obj.model\n        makeObservable(obj)\n\n        if (model.ids === undefined) \n            throw(`No one id field was declared on model ${model.name}`)\n\n        // apply id-fields decorators\n        for (let id_field_name of model.ids.keys()) {\n            model.ids.get(id_field_name).decorator(obj, id_field_name)\n        }\n        // apply fields decorators\n        for (let field_name in model.fields) {\n            model.fields[field_name].decorator(obj, field_name)\n        }\n        // apply relations decorators\n        for (let field_name in model.relations) {\n            model.relations[field_name].decorator(obj, field_name)\n        }\n\n        runInAction(() => {\n            // update the object from args\n            if (args[0]) {\n                let raw_obj = args[0]\n                // id-fields\n                for (let id_field_name of model.ids.keys()) {\n                    if (raw_obj[id_field_name] !== undefined) {\n                        obj[id_field_name] = raw_obj[id_field_name]\n                    }\n                }\n                // fields \n                for (let field_name in model.fields) {\n                    if (raw_obj[field_name] !== undefined) {\n                        obj[field_name] = raw_obj[field_name]\n                    }\n                }\n            }\n        })\n        obj.refresh_init_data()\n        return obj\n    }\n\n    f.__proto__ = original\n    f.prototype = original.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { Model, RawObject } from '../model'\n\n\nexport default abstract class  Adapter<M extends Model> {\n\n    // abstract getTotalCount: (where?) => Promise<number>\n    abstract __create(obj: RawObject): Promise<object>\n    abstract __update(obj: RawObject): Promise<object>\n    abstract __delete(obj: RawObject): Promise<object>\n    abstract __find(where): Promise<object>\n    abstract __load(where?, order_by?, limit?, offset?): Promise<RawObject[]>\n    abstract getTotalCount(where?): Promise<number>\n\n    readonly model: any\n\n    constructor(model: any) {\n        this.model = model \n    }\n\n    async create(obj: M) : Promise<M> {\n        let raw_obj = await this.__create(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        obj.refresh_init_data()\n        return obj\n    }\n\n    async update(obj: M) : Promise<M> {\n        let raw_obj = await this.__update(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        obj.refresh_init_data()\n        return obj\n    }\n\n    async delete(obj: M) : Promise<M> {\n        let raw_obj = await this.__delete(obj.raw_obj)\n        for(let id_field_name of this.model.ids.keys())\n            obj[id_field_name] = null\n        return obj\n    }\n\n    async find(where): Promise<M> {\n        let raw_obj = await this.__find(where)\n        return this.model.updateCache(raw_obj)\n    }\n\n    async load(where?, order_by?, limit?, offset?):Promise<M[]> {\n        let raw_objs = await this.__load(where, order_by, limit, offset)\n        let objs: M[] = []\n        for (let raw_obj of raw_objs) {\n            objs.push(this.model.updateCache(raw_obj))\n        }\n        return objs\n    }\n}\n","import { Model, RawObject } from '../model'\nimport Adapter  from './adapter'\n\n/*\nYou can use this adapter for mock data or for unit test\n*/\n\n\nexport let store: any = {}\n\n\nfunction timeout(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n\nexport default class LocalAdapter<M extends Model> extends Adapter<M> {\n\n    readonly store_name: string\n\n    // delays for simulate real usage, use it only for tests\n    delay: number \n\n    init_local_data(data: RawObject[]) {\n        let objs = {} \n        for(let obj of data) {\n            objs[this.model.__id(obj)] = obj\n        }\n        store[this.store_name] = objs\n    }\n\n    constructor(model: any, store_name?: string) {\n        super(model)\n        this.store_name = store_name ? store_name : model.__proto__.name\n        store[this.store_name] = {}\n    }\n\n    async __create(obj: RawObject) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n\n        if (obj.__id === null) {\n            // calculate and set new ID\n            let ids = [0]\n            for(let id of Object.keys(store[this.store_name])) {\n                ids.push(parseInt(id))\n            }\n            let max = Math.max.apply(null, ids)\n            for(let field_name_id of this.model.ids.keys()) {\n                obj[field_name_id] = max + 1\n            }\n        }\n        obj.__id = this.model.__id(obj)\n        store[this.store_name][this.model.__id(obj)] = obj\n        return obj\n    }\n\n    async __update(obj: RawObject) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n        store[this.store_name][obj.__id] = obj\n        return obj\n    }\n\n    async __delete(obj: RawObject) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n        delete store[this.store_name][obj.__id]\n        return obj\n    }\n\n    async __find(where) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n        // TODO: apply where, and throw error if no obj or multi objs\n        let raw_obj = Object.values(store[this.store_name])[0]\n        return raw_obj\n    }\n\n    async __load (where?, order_by?, limit?, offset?) : Promise<RawObject[]> {\n        if (this.delay) await timeout(this.delay) \n        let raw_objs = []\n        // filter\n        if (where) {\n            for(let raw_obj of Object.values(store[this.store_name])) {\n\n            }\n        }\n        else {\n            raw_objs = Object.values(store[this.store_name])\n        }\n\n        // order_by (sort)\n        if (order_by) {\n            raw_objs = raw_objs.sort((obj_a, obj_b) => {\n                let res\n                for(let sort_by_field of order_by) {\n\n                }\n                return 0\n            })\n        }\n\n        // page\n        if (limit !== undefined && offset !== undefined) {\n            raw_objs = raw_objs.slice(offset, offset+limit)\n        }\n        return raw_objs \n    }\n\n    async getTotalCount(where?): Promise<number> {\n        let objs = []\n        // Object.values(store[this.store_name])\n        return objs.length\n    }\n}\n\n\n// model decorator\nexport function local() {\n    return (cls: any) => {\n        let adapter = new LocalAdapter(cls)\n        cls.__proto__.adapter = adapter \n    }\n}\n\n// TODO: where example\n// let where = [\n//             [\"field_a\", \"==\", 10, \"and\", \"field_b == 20\"],\n//     \"or\",   [\"field_a\", \"<=\",  5, \"and\", \"field_b\", \"contain\", \"test\"]\n// ]\n","import { observable, observe, intercept, extendObservable } from 'mobx'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to cache then you can use this \nnew Obj({id: x, ...})\n*/\n\nfunction field_ID (obj , field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // before changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && obj[field_name] !== null)\n            throw new Error(`You cannot change id field: ${field_name}. ${obj[field_name]} to ${change.newValue}`)\n        if (obj[field_name] !== null && change.newValue === null) {\n            try {\n                obj.model.eject(obj)\n            }\n            catch (err) {\n                let ignore_error = `Object with id \"${obj.__id}\" not exist in the model cache: ${obj.model.name}\")`\n                if (err.name !== ignore_error)\n                    throw err\n            }\n        }\n        return change\n    })\n\n    // after changes\n    observe(obj, field_name, (change) => {\n        // if id is complete\n        if (obj.__id !== null) \n            obj.model.inject(obj)\n    })\n\n}\n\n\nexport default function id(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.ids === undefined) model.ids = new Map()\n    model.ids.set(field_name, { decorator: field_ID })\n}\n","import { extendObservable } from 'mobx'\n\n\n\nexport function field_field(obj, field_name) {\n    // make observable and set default value\n    extendObservable(obj, { [field_name]: obj[field_name] })\n}\n\n\nexport default function field(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n\n    model.fields[field_name] = { decorator: field_field }  // register field \n}\n","// import 'reflect-metadata'\nimport {intercept, observe, extendObservable, observable, autorun, when, reaction} from 'mobx'\n\nfunction field_foreign(obj, field_name) {\n    let edit_mode = false\n    let settings = obj.model.relations[field_name].settings\n    let foreign_model     = settings.foreign_model\n    let foreign_ids_names = settings.foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    debugger\n    reaction(\n        // watch on foreign cache for foreign object\n        () => {\n            let id = foreign_model.__id(obj, foreign_ids_names)\n            return id ? foreign_model.cache.get(id) : null\n        },\n        // update foreign field\n        (foreign_obj, prev, reaction) => {\n            obj[field_name] = foreign_obj ? foreign_obj : null \n        })\n\n    // Setter\n    // 1. checks before set new changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model == foreign_model)) {\n            throw new Error(`You can set only instance of \"${foreign_model.name}\" or null`)\n        }\n        return change\n    })\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let new_foreign_obj = change.newValue\n        let old_foreign_obj = change.oldValue\n\n        if (new_foreign_obj === old_foreign_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n        edit_mode = true\n        try {\n            if (change.newValue === null) {\n                // if foreign set to null then reset ids on the obj\n                for (let id_name of foreign_ids_names) {\n                    obj[id_name] = null \n                }\n            }\n            else {\n                debugger\n                // if foreign set to obj then update ids from the obj's ids\n                let obj_ids: any = Array.from(change.newValue.model.ids.keys())\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    // do not touch if it the same\n                    if (obj[foreign_ids_names[i]] != change.newValue[obj_ids[i]])\n                        obj[foreign_ids_names[i]]  = change.newValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // rollback changes!\n            if (change.oldValue === null) {\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = null \n                }\n            }\n            else {\n                let obj_ids = change.oldValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n            throw e\n        }\n\n        // if foreign have the one then update the one\n        if (settings.one) {\n            if (old_foreign_obj) {\n                old_foreign_obj[settings.one] = null\n            }\n            if (new_foreign_obj) {\n                new_foreign_obj[settings.one] = obj \n            }\n        }\n\n    })\n}\n\n\nexport default function foreign(foreign_model: any, ...foreign_ids_names: string[]) {\n    foreign_model = foreign_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.constructor\n        if (model.relations === undefined) model.relations = {}\n        // register field \n        model.relations[field_name] = { \n            decorator: field_foreign,\n            settings: {\n                foreign_model: foreign_model,\n                // if it is empty then try auto detect it (it works only with single id) \n                foreign_ids_names: foreign_ids_names.length ? foreign_ids_names : [`${field_name}_id`]\n            } \n        } \n\n        // TODO finish it\n        // watch on the foreign cache \n        // if foreign obj was created then it should be attached to foreign\n        // if foreign obj was deleted then it should be removed from foreign\n        // e.i. update foreign obj when foreign ids was changed\n        // reaction(() => foreign_model.cache, (value, prev_value, reaction) => {\n        //     debugger\n        // })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_one(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // 1. checks before set new changes\n    intercept(obj, <any>field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model === remote_model))\n                throw new Error(`You can set only instance of \"${remote_model.name}\" or null`)\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let old_remote_obj = change.oldValue\n        let new_remote_obj = change.newValue\n\n        if (new_remote_obj === old_remote_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote obj\n            if (old_remote_obj) {\n                for (let id_name of remote_foreign_ids_name) {\n                    old_remote_obj[id_name] = null \n                }\n            }\n            // set foreign ids on the remote obj \n            if (new_remote_obj) {\n                let obj_ids: any = Array.from(obj.model.ids.keys())\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]] = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\n\nexport default function one(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    remote_model = remote_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_one,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`one ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            // TODO: is it not bad?\n                            // if (obj[field_name])\n                            //     // TODO better name of error\n                            //     // TODO add test for this case\n                            //     throw ('One: bad')\n                            runInAction(() => { obj[field_name] = remote_obj })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`one ${field_name}`)) {\n                        remote_obj.disposers.get(`one ${field_name}`)()\n                        remote_obj.disposers.delete(`one ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) \n                        runInAction(() => { obj[field_name] = null })\n                    break\n            }\n        })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_many(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: []\n    })\n\n    // 1. checks before set new changes\n    intercept(obj[field_name], (change: any) => {\n        // TODO\n        // if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor === remote_model.__proto__))\n        //         throw new Error(`You can set only instance of \"${remote_model.__proto__.name}\" or null`)\n\n        // TODO: if we push exist obj then ignore it? and not duplicate\n        // TODO: create a test for this case \n        // remote obj can be in the many \n        // for (let new_remote_obj of change.added) {\n        //     const i = obj[field_name].indexOf(new_remote_obj)\n        //     if (i == -1)\n        //         throw new Error(`\"${new_remote_obj.model.name}\" id:\"${new_remote_obj.__id}\" alredy in many \"${obj.model.name}\" id:\"${field_name}\"`)\n        // }\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj[field_name], (change:any) => {\n        if (change.type !== 'splice')\n            return \n\n        let old_remote_objs = change.removed\n        let new_remote_objs = change.added\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote objs\n            for(let old_remote_obj of old_remote_objs)\n                for (let id_name of remote_foreign_ids_name)\n                    old_remote_obj[id_name] = null \n            // set foreign ids on the remote objs \n            let obj_ids: any = Array.from(obj.model.ids.keys())\n            for(let new_remote_obj of new_remote_objs) {\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]]  = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\nexport default function many(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_many,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`many ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            const i = obj[field_name].indexOf(remote_obj)\n                            if (i == -1)\n                                runInAction(() => { obj[field_name].push(remote_obj) })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`many ${field_name}`)) {\n                        remote_obj.disposers.get(`many ${field_name}`)()\n                        remote_obj.disposers.delete(`many ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) {\n                        const i = obj[field_name].indexOf(remote_obj)\n                        if (i > -1)\n                            runInAction(() => { obj[field_name].splice(i, 1); })\n                    } \n                    break\n            }\n        })\n    }\n}"],"names":["Query","constructor","adapter","base_cache","filters","order_by","page","page_size","Object","this","__base_cache","__adapter","makeObservable","items","__items","is_loading","__is_loading","is_ready","__is_ready","error","__error","destroy","disposer","__disposers","__id","__disposer_objects","async","shadowLoad","runInAction","objs","load","__load","e","ready","Promise","resolve","reject","autorun","reaction","dispose","loading","__is_matched","obj","key","__decorate","observable","action","QeuryBase","splice","length","push","super","observe","change","type","watch_obj","newValue","name","oldValue","i","indexOf","id","should","QueryBase","undefined","filter","Model","args","Map","static","Error","cache","has","set","delete","find","QueryPage","get","raw_obj","updateFromRaw","values","id_field_name","ids","keys","Array","from","id_separator","slice","model","__proto__","raw_data","field_name","fields","is_changed","__init_data","create","update","refresh_init_data","original","f","c","decorator","relations","prototype","computed","Adapter","__create","__update","__delete","where","__find","updateCache","limit","offset","raw_objs","store","timeout","ms","setTimeout","LocalAdapter","store_name","init_local_data","data","delay","parseInt","max","Math","apply","field_name_id","sort","obj_a","obj_b","sort_by_field","local","cls","field_ID","extendObservable","intercept","eject","err","ignore_error","inject","field_field","field","field_foreign","edit_mode","settings","foreign_model","foreign_ids_names","foreign_obj","prev","new_foreign_obj","old_foreign_obj","id_name","obj_ids","one","foreign","field_one","remote_model","remote_foreign_ids_name","remote_foreign_ids_names","old_remote_obj","new_remote_obj","toLowerCase","remote_change","remote_obj","disposers","field_many","old_remote_objs","removed","new_remote_objs","added","many"],"mappings":"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"}
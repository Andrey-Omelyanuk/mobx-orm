{"version":3,"file":"mobx-orm.es2015.js","sources":["../src/adapter.ts","../src/store.ts","../src/model.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts","../src/fields/number.ts","../src/fields/float.ts","../src/fields/datetime.ts","../src/fields/boolean.ts"],"sourcesContent":["import { Model } from './model'\n\n\nexport interface Adapter {\n    save  : undefined | ((obj: Model)=> any) \n    delete: undefined | ((obj: Model)=> any)\n    load  : undefined | ((model_name, where, order_by, limit, offset) => any)\n}\n\nexport class DefaultAdapter implements Adapter {\n    newId = 0\n    async save(obj) {\n        let model_description = obj.getModelDescription()\n        if (obj.__id === null) {\n            for (let id_field_name of model_description.ids) {\n                obj[id_field_name] = this.newId\n            }\n            this.newId++\n        }\n        return Promise.resolve(obj)\n    }\n    async delete(obj: Model) {\n        let model_description = obj.getModelDescription()\n        for (let id_field_name of model_description.ids) {\n            obj[id_field_name] = null\n        }\n        return Promise.resolve(obj)\n    }\n    async load() {\n        throw new Error('Not Implemented for DefaultAdapter')\n    }\n}\n","import { observable } from 'mobx'\nimport { Model } from './model'\nimport { Adapter, DefaultAdapter } from './adapter'\n\n\nexport interface FieldTypeDecorator {\n    (model_name: string, field_name: string, obj: Object): void\n}\n\nexport interface ModelDescription {\n    ids     : any[]\n    fields  : {\n        [field_name: string]: {\n            type        : undefined | string,\n            settings    : undefined | any,\n            serialize   : undefined | any,\n            deserialize : undefined | any\n        }\n    },\n    objects : {\n        [string_id: string]: Model \n    } \n    adapter : Adapter\n}\n\n/*\nФункции хранилища:\n    Note: all functions return nothing, you can catch errors in exception\n\n    model \t\t\t\t\t\t\t\t(cls) - декоратор для класса, который мы хотим зарегистрировать как модель\n    registerModel \t\t\t\t(model_name) - register model in store if not registered yet\n    registerModelPk\t\t\t\t(model_name, fieldKey)\t-\n    registerModelField \t\t(model_name, fieldKey, fieldWrapper) \t\t\t\t-\n*/\n\nexport class Store {\n\n                debug      : boolean = false \n    @observable models     : { [model_name: string]: ModelDescription   } = {}\n                field_types: { [type_name : string]: FieldTypeDecorator } = {}\n\n    registerModel(model_name) {\n        if (!this.models[model_name]) {\n            let _count_id = 0\n            this.models[model_name] = {\n                ids     : [],\n                fields  : {},\n                objects : {},\n                adapter : new DefaultAdapter()\n            }\n            this.models[model_name].objects = observable(this.models[model_name].objects)\n        }\n        else throw new Error(`Model \"${model_name}\" already registered.`)\n    }\n\n    registerFieldType(type, decorator) {\n        if (!this.field_types[type])\n            this.field_types[type] = decorator\n        else\n            throw new Error(`Field type \"${type}\" already registered.`)\n    }\n\n    registerModelField(model_name, type, field_name, settings = {}, serialize = null, deserialize = null) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (!model_description.fields[field_name])\n            model_description.fields[field_name] = { type: type, settings: settings, serialize: serialize, deserialize: deserialize }\n        else\n            throw `Field \"${field_name}\" on \"${model_name}\" already registered.`\n    }\n\n    registerId(model_name, field_name) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (model_description.ids.indexOf(field_name) != -1)\n            throw `Id \"${field_name}\" in model \"${model_name}\" already registered.`\n        else\n            model_description.ids.push(field_name)\n    }\n\n    inject(obj: Model) {\n        let model_description = obj.getModelDescription()\n        if (obj.__id === null)                    throw new Error(`Object should have id!`)\n        if (model_description.objects[obj.__id])  throw new Error(`Object with id \"${obj.__id}\" already exist in the store (model: \"${obj.getModelName()}\")`)\n        model_description.objects[obj.__id] = obj\n    }\n\n    eject(obj: Model) {\n        if (obj.__id === null) return                   \n        let model_description = obj.getModelDescription()\n        if (!model_description.objects[obj.__id]) throw new Error(`Object with id \"${obj.__id}\" not exist in the store (model: ${obj.getModelName()}\")`)\n        delete model_description.objects[obj.__id]\n    }\n\n    clear() {\n        for (let model_name of Object.keys(this.models)) {\n            this.clearModel(model_name)\n        }\n        this.models = {}\n    }\n\n    clearModel(model_name) {\n        let model_desc = this.models[model_name]\n        if (model_desc) {\n            // we need it for run triggers on id fields \n            for (let obj of Object.values(model_desc.objects)) {\n                for (let id_field_name of model_desc.ids) {\n                    obj[id_field_name] = null\n                }\n            }\n        }\n    }\n\n    getId(obj: Model, id_name_fields: string[]) : string | null {\n        let id = '' \n        for (let id_name_field of id_name_fields) {\n            // if any id field is null then we should return null\n            // because id is not complite\n            if (obj[id_name_field] === null || obj[id_name_field] === undefined) \n                return null\n\n            id += `${obj[id_name_field]} :`\n        }\n        return id\n    }\n\n}\nlet store = new Store()\nexport default store\n\n// declare let window: any\n// if (window) \n//     window.mobx_orm_store = store\n","import { computed } from 'mobx'\nimport store, { ModelDescription } from './store'\n\n\nexport class Model {\n\n    static get(id: string): Model {\n        let model_description = this.getModelDescription()\n        return model_description.objects[id]\n    }\n\n    static all(): Model[] {\n        let model_description = this.getModelDescription()\n        return Object.values(model_description.objects)\n    }\n\n    static async load(where = {}, order_by = {}, limit = 0, offset = 0) {\n        let model_description = this.getModelDescription()\n        return model_description.adapter.load(this, where, order_by, limit, offset)\n    }\n\n    static getModelName() : string {\n        return this.prototype.constructor.name\n    }\n\n    static getModelDescription() : ModelDescription {\n        let model_name = this.getModelName()\n        let model_description = store.models[model_name]\n        if (model_description === undefined) \n            throw Error(`Description for '${model_name}' is not exist. Maybe, you called store.clear after model declaration.`)\n        return model_description\n    }\n\n    private readonly _init_data\n\n    constructor(init_data?) {\n        this._init_data = init_data\n    }\n\n    @computed({keepAlive: true}) get __id() : string | null {\n        return store.getId(this, this.getModelDescription().ids)\n    }\n\n    getModelName() : string {\n        return this.constructor.name\n    }\n\n    getModelDescription() : ModelDescription {\n        let model_name = this.getModelName() \n        let model_description = store.models[model_name]\n        if (model_description === undefined) \n            throw Error(`Description for '${model_name}' is not exist. Maybe, you called store.clear after model declaration.`)\n            // throw new Error(`Model name \"${model_name} is not registered in the store`)\n        return model_description\n    }\n    \n    async save() {\n        return this.getModelDescription().adapter.save(this)\n    }\n\n    async delete() {\n        return this.getModelDescription().adapter.delete(this)\n    }\n}\n\n\n// Decorator\nexport function model(cls) {\n    // the new constructor behaviour\n    let f : any = function (...args) {\n        let c : any = function () { return cls.apply(this, args) }\n        c.__proto__ = cls.__proto__\n        c.prototype = cls.prototype\n\n        let model_name        = cls.getModelName()\n        let model_description = cls.getModelDescription()\n\n        let obj  = new c()\n        let init_data = obj._init_data ? obj._init_data : {}\n        delete obj._init_data\n\n        // save defaults from class declaration\n        for (let field_name in model_description.fields) {\n            if (obj[field_name] !== undefined && init_data[field_name] === undefined) {\n                init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply decorators\n        for (let field_name in model_description.fields) {\n            let type = model_description.fields[field_name].type\n            store.field_types[type](model_name, field_name, obj)\n        }\n        \n        if (init_data)\n            for (let field_name in init_data)\n                obj[field_name] = init_data[field_name]\n\n        return obj\n    }\n    // copy static properties/methods\n    for (let prop_name of Object.getOwnPropertyNames(cls))\n        if(f[prop_name] == undefined)\n            f[prop_name] = cls[prop_name]\n\n    f.__proto__ = cls.__proto__\n    f.prototype = cls.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { observable, observe, intercept } from 'mobx'\nimport { Model } from '../model'\nimport store from '../store'\n\n\nlet type = 'id'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to store then you can use this \nnew Obj({id: x, ...})\n*/\n\nexport function registerFieldId() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && obj[field_name] !== null)\n                throw new Error(`You cannot change id field: ${field_name}`)\n\n            if (obj[field_name] !== null && change.newValue === null) {\n                try {\n                    store.eject(obj)\n                }\n                catch (err) {\n                    if (err.name !== `Object with id \"${obj.__id}\" not exist in the store (model: ${obj.getModelName()}\")`)\n                        throw err\n                }\n            }\n\n            return change\n        })\n\n        // after changes\n        observe(obj, field_name, (change) => {\n            // if id is complete\n            if (obj.__id !== null) \n                store.inject(obj)\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterFieldId()\n\n\nexport default function id(cls: Model, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    // let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(cls.getModelName(), type, field_name)\n    store.registerId(cls.getModelName(), field_name)\n    // register observable into mobx\n    observable(cls, field_name)\n}\n","import { observable } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'field'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function field(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","// import 'reflect-metadata'\nimport store from '../store'\nimport {intercept, observe, observable, autorun} from 'mobx'\n\n\nlet type = 'foreign'\n\nexport function registerForeign() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        let edit_mode = false\n        let foreign_model_name     = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_names = store.models[model_name].fields[field_name].settings.foreign_id_field_names\n\n        // Computed\n        // watch \"foreign id\" fields\n        // e.i. update foreign obj when foreign ids was changed\n        autorun(() => {\n            let id = store.getId(obj, foreign_id_field_names)\n            if (store.models[foreign_model_name]) {\n                let foreign_obj = store.models[foreign_model_name].objects[id]\n                obj[field_name] = foreign_obj ? foreign_obj : null \n            }\n        })\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue || edit_mode)\n                return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n            edit_mode = true\n            try {\n                if (change.newValue === null) {\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = null \n                    }\n                }\n                else {\n                    let foreign_model_description = change.newValue.getModelDescription()\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = change.newValue[foreign_model_description.ids[i]]\n                    }\n                }\n                edit_mode = false\n            }\n            catch(e) {\n                // rollback changes!\n                if (change.oldValue === null) {\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = null \n                    }\n                }\n                else {\n                    let foreign_model_description = change.newValue.getModelDescription()\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = change.oldValue[foreign_model_description.ids[i]]\n                    }\n                }\n                edit_mode = false\n                throw e\n            }\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterForeign()\n\n\nexport default function foreign(foreign_model_name: any, ...foreign_id_field_names: string[]) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        // let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        let model_name = cls.getModelName()\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        store.registerModelField(model_name, type, field_name, {\n            foreign_model_name    : foreign_model_name,\n            foreign_id_field_names: foreign_id_field_names.length ? foreign_id_field_names : [`${field_name}_id`]\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n    }\n}\n","import { store, Model } from '../index'\nimport {intercept, observe, observable} from 'mobx'\n\n\nexport function registerOne() {\n    store.registerFieldType('one', (model_name: string, field_name: string, obj: Model) => {\n        let remote_model_name             = store.models[model_name].fields[field_name].settings.remote_model_name\n        let foreign_field_on_remote_model = store.models[model_name].fields[field_name].settings.foreign_field_on_remote_model\n\n        // 1. checks before set new changes\n        intercept(obj, <any>field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name === remote_model_name))\n                    throw new Error(`You can set only instance of \"${remote_model_name}\" or null`)\n            return change\n        })\n\n        // default value\n        obj[field_name] = null\n    })\n}\nregisterOne()\n\n\nexport default function one(remote_model_name: any, foreign_field_on_remote_model: string) {\n    return function (cls: any, field_name: string) {\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        // let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        let model_name = cls.getModelName()\n\n        // detect class name\n        if (typeof remote_model_name === 'function')\n            remote_model_name = remote_model_name.constructor.name == 'Function' \n                ? remote_model_name.prototype.constructor.name \n                : remote_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[remote_model_name])  store.registerModel(remote_model_name)\n        store.registerModelField(model_name, 'one', field_name, {\n            remote_model_name               : remote_model_name,\n            foreign_field_on_remote_model   : foreign_field_on_remote_model\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // watch foreign fields on exists remote object \n        for (let remote_object of Object.values(store.models[remote_model_name].objects)) {\n            observe(remote_object, <any>foreign_field_on_remote_model, (remote_foreign_field_change) => {\n                // remove old\n                if (remote_foreign_field_change.oldValue) \n                    remote_foreign_field_change.oldValue[field_name] = null\n                // add new\n                if (remote_foreign_field_change.newValue)\n                    remote_foreign_field_change.newValue[field_name] = remote_object\n            })\n        }\n\n        // watch for remote object that related to one-field\n        observe(store.models[remote_model_name].objects, (remote_change) => {\n            switch (remote_change.type) {\n                // remote object was injected\n                case 'add':\n                    // add to one  \n                    if (remote_change.newValue[foreign_field_on_remote_model])\n                        remote_change.newValue[foreign_field_on_remote_model][field_name] = remote_change.newValue\n                    // watch foreign field on remote object \n                    observe(remote_change.newValue, foreign_field_on_remote_model, (remote_foreign_field_change) => {\n                        // remove old\n                        if (remote_foreign_field_change.oldValue) \n                            remote_foreign_field_change.oldValue[field_name] = null\n                        // add new\n                        if (remote_foreign_field_change.newValue)\n                            remote_foreign_field_change.newValue[field_name] = remote_change.newValue\n                    })\n                    break\n                // remote object was ejected\n                case 'remove':\n                    // TODO: check memory leaks (unsubscribe observer in 'add' section)\n                    let obj = remote_change.oldValue[foreign_field_on_remote_model]\n                    if (obj) \n                        obj[field_name] = null\n                    break\n            }\n        })\n    }\n}\n","import { observable, observe } from 'mobx'\nimport store from '../store'\n\n\nexport function registerMany() {\n    store.registerFieldType('many', (model_name, field_name, obj) => {\n        // default value\n        obj[field_name] = []\n    })\n}\nregisterMany()\n\n\nexport default function many(remote_model_name: any, foreign_field_on_remote_model: string) {\n    return function (cls: any, field_name: string) {\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        // let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        let model_name = cls.getModelName()\n\n        // detect class name\n        if (typeof remote_model_name === 'function')\n            remote_model_name = remote_model_name.constructor.name == 'Function'\n                ? remote_model_name.prototype.constructor.name\n                : remote_model_name.constructor.name\n        //\n        if (!store.models[model_name])          store.registerModel(model_name)\n        if (!store.models[remote_model_name])   store.registerModel(remote_model_name)\n        store.registerModelField(model_name, 'many', field_name, {\n            remote_model_name               : remote_model_name,\n            foreign_field_on_remote_model   : foreign_field_on_remote_model\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // watch foreign fields on exists remote object \n        for (let remote_object of Object.values(store.models[remote_model_name].objects)) {\n            observe(remote_object, <any>foreign_field_on_remote_model, (remote_foreign_field_change) => {\n                // remove old\n                if (remote_foreign_field_change.oldValue) \n                    remote_foreign_field_change.oldValue[field_name] = null\n                // add new\n                if (remote_foreign_field_change.newValue)\n                    remote_foreign_field_change.newValue[field_name] = remote_object\n            })\n        }\n\n        // watch for all foreign objects\n        observe(store.models[remote_model_name].objects, (remote_change: any) => {\n            switch (remote_change.type) {\n                // remote object was injected\n                case 'add':\n                    // add to many  \n                    if (remote_change.newValue[foreign_field_on_remote_model])\n                        remote_change.newValue[foreign_field_on_remote_model][field_name].push(remote_change.newValue)\n                    // watch foreign field on remote object \n                    observe(remote_change.newValue, foreign_field_on_remote_model, (remote_foreign_field_change) => {\n                        // remote old\n                        if (remote_foreign_field_change.oldValue) {\n                            let object_with_many = remote_foreign_field_change.oldValue\n                            let index = object_with_many[field_name].indexOf(remote_change.newValue)\n                            if (index > -1) {\n                                object_with_many[field_name].splice(index, 1)\n                            }\n                        }\n                        // add new\n                        if (remote_foreign_field_change.newValue)\n                            remote_foreign_field_change.newValue[field_name].push(remote_change.newValue)\n                    })\n                    break\n                // object was removed \n                case 'remove':\n                    let object_with_many = remote_change.oldValue[foreign_field_on_remote_model]\n                    if (object_with_many) {\n                        let index = object_with_many[field_name].indexOf(remote_change.oldValue)\n                        if (index > -1) {\n                            object_with_many[field_name].splice(index, 1)\n                        }\n                    }\n                    break\n            }\n        })\n    }\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'number'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (!(change.newValue === Number(change.newValue) && change.newValue % 1 === 0))\n                    throw new Error(`Field can be only integer or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'float'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (change.newValue !== Number(change.newValue))\n                    throw new Error(`Field can be only float or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\nimport { isNoop } from '@babel/types';\n\n\nlet type = 'datetime'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null) {\n                if(typeof change.newValue === 'string' || change.newValue instanceof String) {\n                    change.newValue = Date.parse(<any>change.newValue)\n                    if (!isNaN(change.newValue))\n                        change.newValue = new Date(change.newValue)\n                }\n                if (!(change.newValue instanceof Date)) \n                    throw new Error(`Field can be only Date or null.`)\n            }\n            return change\n        })\n    })\n}\nregisterField()\n\n\nexport default function datetime(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name, {},\n        (obj) => { return new Date(obj)     },\n        (obj) => { return obj.toISOString() }\n    )\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'boolean'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                change.newValue = Boolean(change.newValue)\n            return change\n        })\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n"],"names":["this","DefaultAdapter","obj","model_description","getModelDescription","__id","_a","ids","_i","id_field_name","newId","Promise","resolve","Error","store","Store","model_name","models","fields","objects","adapter","observable","type","decorator","field_types","field_name","settings","serialize","deserialize","registerModel","indexOf","push","getModelName","Object","keys","clearModel","model_desc","values","_c","_b","id_name_fields","id","id_name_fields_1","id_name_field","undefined","tslib_1.__decorate","init_data","_init_data","Model","where","order_by","limit","offset","load","prototype","constructor","name","getId","save","delete","computed","keepAlive","model","cls","f","args","c","apply","__proto__","getOwnPropertyNames","prop_name","registerModelField","registerId","registerFieldType","intercept","change","newValue","eject","err","observe","inject","field","foreign","foreign_model_name","foreign_id_field_names","length","one","remote_model_name","foreign_field_on_remote_model","remote_object","remote_foreign_field_change","oldValue","remote_change","many","object_with_many_1","index","splice","object_with_many","edit_mode","autorun","foreign_obj","i","foreign_model_description","e","number","Number","datetime","Date","toISOString","String","parse","isNaN","Boolean"],"mappings":"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"}
{"version":3,"file":"mobx-orm.es2015.js","sources":["../src/store.ts","../src/model.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts","../src/fields/number.ts","../src/fields/float.ts","../src/fields/datetime.ts"],"sourcesContent":["import { observable } from 'mobx'\n\n\ninterface FieldTypeDecorator {\n    (model_name: string, field_name: string, obj: Object): void\n}\n\ninterface ModelDescription {\n    fields: {\n        [field_name: string]: {\n            type        : undefined | string,\n            settings    : undefined | any,\n            serialize   : undefined | any,\n            deserialize : undefined | any\n        }\n    }\n    objects: {\n        [id: number]: object\n    }\n    unique: {\n        [field_name: string]: any\n    }\n    getNewId: ()=>number\n    save  : undefined | ((obj)=> any) \n    delete: undefined | ((obj)=> any)\n    load  : undefined | ((model_name, where, order_by, limit, offset) => any)\n}\n\n/*\nФункции хранилища:\n    Note: all functions return nothing, you can catch errors in exception\n\n    model \t\t\t\t\t\t\t\t(cls) - декоратор для класса, который мы хотим зарегистрировать как модель\n    registerModel \t\t\t\t(model_name) - register model in store if not registered yet\n    registerModelPk\t\t\t\t(model_name, fieldKey)\t-\n    registerModelField \t\t(model_name, fieldKey, fieldWrapper) \t\t\t\t-\n*/\n\nexport class Store {\n\n    debug      : boolean = false \n    models     : { [model_name: string]: ModelDescription   } = {}\n    field_types: { [type_name : string]: FieldTypeDecorator } = {}\n\n\n    registerModel(model_name) {\n        if (!this.models[model_name]) {\n            let _count_id = 0\n            this.models[model_name] = {\n                objects: {},\n                fields : {},\n                unique : {},\n                getNewId: () => {\n                    _count_id = _count_id + 1\n                    return _count_id\n                },\n                save  : undefined,\n                delete: undefined,\n                load  : undefined\n            }\n            this.models[model_name].objects = observable(this.models[model_name].objects)\n        }\n        else throw new Error(`Model \"${model_name}\" already registered.`)\n    }\n\n    registerFieldType(type, decorator) {\n        if (!this.field_types[type])\n            this.field_types[type] = decorator\n        else\n            throw new Error(`Field type \"${type}\" already registered.`)\n    }\n\n    registerModelField(model_name, type, field_name, settings = {}, serialize = null, deserialize = null) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (!model_description.fields[field_name])\n            model_description.fields[field_name] = { type: type, settings: settings, serialize: serialize, deserialize: deserialize }\n        else\n            throw `Field \"${field_name}\" on \"${model_name}\" already registered.`\n    }\n\n    // registerUniqueField(model_name, field_name) {\n    // \tif (!this.models[model_name]) this.registerModel(model_name)\n    // \tlet model_description = this.models[model_name]\n    // \tif (!model_description.unique[field_name]) {\n    //\n    // \t\tlet unique_set = new Set()\n    // \t\t//\n    // \t\tmodel_description.unique[field_name] = unique_set\n    // \t\t// inject/eject/update\n    // \t\tmodel_description.fields[field_name].onUpdate(({obj}) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for updating ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onInject((obj) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for inject ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onEject((obj) => {\n    // \t\t\tunique_set.delete(obj[field_name])\n    // \t\t})\n    // \t}\n    // \telse {\n    // \t\tthrow `Unique on field \"${field_name}\" on \"${model_name}\" already registered.`\n    // \t}\n    // }\n\n    inject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can inject only instance of \"${model_name}\"`)\n        if (model_description.objects[object.id])  throw new Error(`Object with id=\"${object.id}\" already exist in model \"${model_name}\".`)\n\n        model_description.objects[object.id] = object\n    }\n\n    eject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can eject only instance of \"${model_name}\"`)\n        if (!model_description.objects[object.id]) throw new Error(`Object with id ${object.id} not exist in model \"${model_name}\"`)\n\n        delete model_description.objects[object.id]\n    }\n\n    clear() {\n        for (let model_name of Object.keys(this.models))\n            for (let obj of <any>Object.values(this.models[model_name].objects))\n                if(obj.delete)\n                    obj.delete()\n\n        this.models = {}\n    }\n\n    clearModel(model_name) {\n        for (let obj of <any>Object.values(this.models[model_name].objects))\n            if(obj.delete)\n                obj.delete()\n    }\n\n}\nlet store = new Store()\nexport default store\n\ndeclare let window\nwindow.mobx_orm_store = store\n","import store from './store'\n\n\nexport class Model {\n\n    static get(id: number): Model {\n        let model_name = this.prototype.constructor.name\n        return <Model>store.models[model_name].objects[id]\n    }\n\n    static all(): Model[] {\n        let model_name = this.prototype.constructor.name\n        return <Model[]>Object.values(store.models[model_name].objects)\n    }\n\n    static async load(where = {}, order_by = {}, limit = 0, offset = 0) {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.load) \n            return model_description.load(this, where, order_by, limit, offset)\n        else\n            throw Error(`load function is not defined for ${model_name}`) \n    }\n\n    static getFieldsMeta() {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        return model_description.fields\n    }\n\n    private readonly _init_data\n\n    constructor(init_data?) {\n        this._init_data = init_data\n    }\n\n    // если нет id, то создать его\n    // если нужна синхронизация с удаленным хранилищем, то:\n    //      если нет id - то создаем объект удаленно, оттуда и приходит обект с готовым id\n    //\t\t\tесли есть   - то обновляем удаленно\n    async save() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.save) \n            return model_description.save(this)\n        else {\n            let obj = <any>this\n            if (!obj.id)\n                obj.id = model_description.getNewId()\n\n            return Promise.resolve(obj)\n        }\n    }\n\n    async delete() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.delete) \n            return model_description.delete(this)\n        else {\n            (<any>this).id = null\n            return Promise.resolve(this)\n        }\n    }\n}\n\n\n// Decorator\nexport function model(cls) {\n    // the new constructor behaviour\n    let f : any = function (...args) {\n        let c : any = function () { return cls.apply(this, args) }\n        c.__proto__ = cls.__proto__\n        c.prototype = cls.prototype\n\n        let model_name = cls.name\n        let model_description = store.models[model_name]\n\n        let obj  = new c()\n        let init_data = obj._init_data\n        delete obj._init_data\n\n        // save defaults from class declaration\n        for (let field_name in model_description.fields) {\n            if (obj[field_name] !== undefined && init_data[field_name] === undefined) {\n                init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply decorators\n        for (let field_name in model_description.fields) {\n            let type = model_description.fields[field_name].type\n            store.field_types[type](model_name, field_name, obj)\n        }\n        \n        if (init_data)\n            for (let field_name in init_data)\n                obj[field_name] = init_data[field_name]\n\n        return obj\n    }\n    // copy static properties/methods\n    for (let prop_name of Object.getOwnPropertyNames(cls))\n        if(f[prop_name] == undefined)\n            f[prop_name] = cls[prop_name]\n\n    f.__proto__ = cls.__proto__\n    f.prototype = cls.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { observable, observe, intercept } from 'mobx'\nimport store from '../store'\nimport field from './field';\n\n\nlet type = 'id'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to store then you can use this \nnew Obj({id: x, ...})\n*/\n\nexport function registerFieldId() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue != null)\n                if(obj.id != null)\n                    throw new Error(`You cannot change id.`)\n                else if (!Number.isInteger(change.newValue))\n                    throw new Error(`Id can be only integer or null.`)\n\n            if (obj.id && change.newValue == null)\n                store.eject (model_name, obj)\n\n            return change\n        })\n\n        // after changes\n        observe(obj, field_name, (change) => {\n            if (change.newValue)\n                store.inject(model_name,obj)\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterFieldId()\n\n\nexport default function id(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    if (field_name != 'id')\n        throw new Error(`id field should named by 'id'`)\n    store.registerModelField(model_name, type, field_name)\n\n    // register observable into mobx\n    observable(cls, field_name)\n}\n","import { observable } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'field'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function field(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","// import 'reflect-metadata'\nimport store from '../store'\nimport {intercept, observe, observable, autorun} from 'mobx'\n\n\nlet type = 'foreign'\n\nexport function registerForeign() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Computed\n        // watch \"foreign_id\" field\n        // e.i. update foreign obj when foreign id was changed\n        autorun(() => {\n            let foreign_obj = store.models[foreign_model_name].objects[obj[foreign_id_field_name]]\n            obj[field_name] = foreign_obj ? foreign_obj : null\n        })\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n            if (change.newValue !== null && change.newValue.id === null)\n                throw new Error(`Object should have id!`)\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n            try {\n                obj[foreign_id_field_name] = change.newValue === null ? null : change.newValue.id\n            }\n            catch(e) {\n                // rollback changes!\n                obj[foreign_id_field_name] = change.oldValue === null ? null : change.oldValue.id\n                throw e\n            }\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterForeign()\n\n\nexport default function foreign(foreign_model_name: any, foreign_id_field_name?: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        store.registerModelField(model_name, type, field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name ? foreign_id_field_name : `${field_name}_id`\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n    }\n}\n","import store from '../store'\nimport {intercept, observe, observable} from 'mobx'\n\n\nexport function registerOne() {\n    store.registerFieldType('one', (model_name, field_name, obj) => {\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null) {\n                if (!(change.newValue.constructor && change.newValue.constructor.name === foreign_model_name))\n                    throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n                if (change.newValue.id === null)\n                    throw new Error(`Object should have id!`)\n            }\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n            let prev_old = null\n            let prev_new = null\n            try {\n                if (change.oldValue) {\n                    prev_old = change.oldValue[foreign_id_field_name]\n                    change.oldValue[foreign_id_field_name] = null\n                }\n                if (change.newValue) {\n                    prev_new = change.newValue[foreign_id_field_name]\n                    change.newValue[foreign_id_field_name] = obj.id\n                }\n            }\n            catch(e) {\n                // rollback changes!\n                if (change.newValue)\n                    change.newValue[foreign_id_field_name] = prev_new\n                if (change.oldValue)\n                    change.oldValue[foreign_id_field_name] = prev_old\n                throw e\n            }\n        })\n\n        // default value\n        obj[field_name] = null\n    })\n}\nregisterOne()\n\n\nexport default function one(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'one', field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // сдедим за созданием объектов, для первого подсчета one\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type == 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[field_name] = obj\n        })\n\n        // следим за всеми foreign объектами\n        observe(store.models[foreign_model_name].objects, (change) => {\n            switch (change.type) {\n                // появился новый объект\n                case 'add':\n                    let new_object = store.models[model_name].objects[(<any>change).newValue[foreign_id_field_name]]\n                    if (new_object)\n                        new_object[field_name] = change.newValue\n\n                    // подписываемся на каждый объект\n                    observe(change.newValue, foreign_id_field_name, (field_change) => {\n                        // first delete old\n                        if (field_change.oldValue) {\n                            let object = store.models[model_name].objects[field_change.oldValue]\n                            object[field_name] = null\n                        }\n                        //\n                        if (field_change.newValue) {\n                            let obj = store.models[model_name].objects[field_change.newValue]\n                            if (obj)\n                                obj[field_name] = change.newValue\n                        }\n                    })\n                    break\n                // удалили объект\n                case 'remove':\n                    let old_object = store.models[model_name].objects[(<any>change).oldValue[foreign_id_field_name]]\n                    if (old_object)\n                            old_object[field_name] = null\n                    break\n            }\n        })\n    }\n}\n","import { observable, observe } from 'mobx'\nimport store from '../store'\n\n\nexport function registerMany() {\n    store.registerFieldType('many', (model_name, field_name, obj) => {\n        // default value\n        obj[field_name] = []\n    })\n}\nregisterMany()\n\n\nexport default function many(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, many_field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        // detect class name\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name\n                = foreign_model_name.constructor.name == 'Function'\n                ? foreign_model_name.prototype.constructor.name\n                : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'many', many_field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, many_field_name)\n\n        // watch for creation of new objects for first calculation of \"many\"\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type === 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[many_field_name].push(obj)\n        })\n\n        // watch for all foreign objects\n        observe(store.models[foreign_model_name].objects, (change: any) => {\n            let foreign_object   : any\n            let object_with_many : any\n            switch (change.type) {\n                // new object was added \n                case 'add':\n                    foreign_object = change.newValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} start`)\n                        object_with_many[many_field_name].push(foreign_object)\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} finish`)\n                    }\n\n                    observe(foreign_object, foreign_id_field_name, (field_change) => {\n                        if (field_change.newValue) {\n                            let object_with_many_id = field_change.newValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} start`)\n                                object_with_many[many_field_name].push(foreign_object)\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} finish`)\n                            }\n                        }\n                        if (field_change.oldValue) {\n                            let object_with_many_id = field_change.oldValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                let index = object_with_many[many_field_name].indexOf(foreign_object)\n                                if (index > -1) {\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} start`)\n                                    object_with_many[many_field_name].splice(index, 1)\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} finish`)\n                                }\n                            }\n                        }\n                    })\n                    break\n                // object was removed \n                case 'remove':\n                    foreign_object = change.oldValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        let index = object_with_many[many_field_name].indexOf(foreign_object)\n                        if (index > -1) {\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} start`)\n                            object_with_many[many_field_name].splice(index, 1)\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} finish`)\n                        }\n                    }\n                    break\n            }\n        })\n    }\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'number'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (!(change.newValue === Number(change.newValue) && change.newValue % 1 === 0))\n                    throw new Error(`Field can be only integer or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'float'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (change.newValue !== Number(change.newValue))\n                    throw new Error(`Field can be only float or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'datetime'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (Object.prototype.toString.call(change.newValue) !== '[object Date]')\n                    throw new Error(`Field can be only Date or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function datetime(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name, {},\n        (obj) => { return new Date(obj)     },\n        (obj) => { return obj.toISOString() }\n    )\n    // register into mobx\n    observable(cls, field_name)\n}\n"],"names":["store","this","Store","model_name","models","Error","_count_id_1","objects","fields","unique","getNewId","save","undefined","delete","load","observable","type","decorator","field_types","field_name","settings","serialize","deserialize","registerModel","model_description","object","constructor","id","name","_a","Object","keys","_i","_c","values","_b","obj","window","mobx_orm_store","init_data","_init_data","Model","prototype","where","order_by","limit","offset","Promise","resolve","model","cls","f","args","c","apply","__proto__","getOwnPropertyNames","prop_name","registerModelField","registerFieldType","intercept","change","newValue","Number","isInteger","eject","observe","inject","field","foreign","foreign_model_name","foreign_id_field_name","one","new_object","field_change","oldValue","old_object","many","many_field_name","push","foreign_object","object_with_many","debug","console","log","object_with_many_id","object_with_many_1","object_with_many_2","index","indexOf","splice","autorun","foreign_obj","e","prev_old","prev_new","number","datetime","Date","toISOString","toString","call"],"mappings":"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"}
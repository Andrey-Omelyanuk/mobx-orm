{"version":3,"file":"mobx-orm.es2015.js","sources":["../src/query.ts","../src/model.ts","../src/adapters/local.ts","../src/adapters/rest.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\n\n// TODO: do not allow to change obj.items outside\n\nexport default class Query<M extends Model> {\n\n    private     model       : any            // TODO: what type it should be?\n    @observable items       : M[] = []       // they fill from cache only! don't fill it from the update method\n    @observable filters     : object = {}\n    @observable order_by    : string[] = []\n    @observable page        : number = 0\n    @observable page_size   : number = 50\n    @observable is_ready    : boolean = false   // it set to true when we have got data from API at least one time \n    @observable is_updating : boolean = false   // true => we have requesting data from api\n    @observable error       : string = '' \n\n    private disposers = []\n    private disposer_objects = {}\n\n    //\n    constructor(model: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n        this.model = model\n        if (filters  ) this.filters   = filters\n        if (order_by ) this.order_by  = order_by\n        if (page     ) this.page      = page\n        if (page_size) this.page_size = page_size\n        makeObservable(this)\n\n        this.update() // update when query is created\n\n        // update if query is changed\n        this.disposers.push(reaction(\n            () => {\n                return {\n                    filter   : this.filters,\n                    order_by : this.order_by,\n                    page     : this.page,\n                    page_size: this.page_size\n                }\n            }, \n            () => {\n                this.update()\n            }\n        ))\n\n        // watch the cache for changes, and update items if needed\n        this.disposers.push(observe(this.model.cache, (change: any) => {\n            if (change.type == 'add') {\n                this.watch_obj(change.newValue)\n            }\n            if (change.type == \"delete\") {\n                let __id = change.name\n                let obj  = change.oldValue\n                this.disposer_objects[__id]()\n                delete this.disposer_objects[__id]\n                let i = this.items.indexOf(obj)\n                if (i != -1)\n                    this.items.splice(i, 1)\n            }\n        }))\n\n        // watch all exist objects of model \n        for(let [id, obj] of this.model.cache) {\n            this.watch_obj(obj)\n        }\n    }\n\n    // query should be destroyed explicitly\n    destroy() {\n        for(let disposer of this.disposers) disposer()\n    }\n\n    @action update(): Promise<M[]> {\n        this.is_updating = true\n        return this.model.adapter.load(\n            this.filters, \n            this.order_by, \n            this.page_size, \n            this.page*this.page_size\n        )\n        .catch((err) => { \n            runInAction(() => this.error = err)\n        })\n        .finally(() => {\n            runInAction(() => this.is_ready = true)\n            runInAction(() => this.is_updating = false)\n        } )\n    }\n\n    //\n    private watch_obj(obj) {\n        this.disposer_objects[obj.__id] = autorun(\n            () => {\n                let should_be_in_the_list = this.should_be_in_the_list(obj, this.filters)\n                if (should_be_in_the_list) {\n                    let i = this.items.indexOf(obj)\n                    if (should_be_in_the_list && i == -1)\n                        this.items.push(obj)\n                    if (!should_be_in_the_list && i != -1)\n                        this.items.splice(i, 1)\n                }\n            })\n    }\n\n    //\n    private should_be_in_the_list(obj, filters) {\n        if (Object.keys(filters).length) {\n            for(let key in filters) {\n                if (obj[key] != filters[key])\n                    return false\n            }\n            return true\n        }\n        else\n            return true\n    }\n\n    // TODO: convert observeble to promise?\n    ready(): Promise<Boolean> {\n        return new Promise((resolve, reject) => { \n            autorun((reaction) => {\n                if (this.is_ready) {\n                    reaction.dispose()\n                    resolve(this.is_ready) \n                }\n            })\n        })\n    }\n\n}\n\n","import { action, computed, makeObservable, observable, runInAction } from 'mobx'\nimport Adapter from './adapters/adapter'\nimport Query from './query'\n\n\nexport abstract class Model {\n\n    // this private static properties will be copied to real model in the model decorator\n    private static ids          : any[]\n    private static adapter      : Adapter<Model>\n    private static cache        : Map<string, Model>\n    private static fields       : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }\n    }\n\n\n    static load(filter = {}, order_by: string[] = [], page: number = 0, page_size: number = 50) {\n        return new Query(this, filter, order_by, page, page_size)\n    }\n\n    static clearCache() {\n        // we need it for run triggers on id fields \n        for (let obj of this.cache.values()) {\n            for (let id_field_name of this.ids) {\n                obj[id_field_name] = null\n            }\n        }\n    }\n\n    // TODO push it to utils\n    static __id(obj, ids: []) : string | null {\n        let id = '' \n        for (let id_name of ids) {\n            // if any id field is null then we should return null because id is not complite\n            if (obj[id_name] === null || obj[id_name] === undefined) \n                return null\n            id += `${obj[id_name]} :`\n        }\n        return id\n    }\n\n    private readonly _init_data\n    private disposers = new Map()\n\n    constructor (...args) { }\n\n    // build id string from ids fields and return it\n    @computed get __id() : string | null {\n        return Model.__id(this, this.model.ids)\n    }\n\n    // TODO: any is band-aid \n    get model() : any {\n        return (<any>this.constructor).__proto__\n    }\n\n    // create or update object in the repo \n    async save() {\n        return this.model.adapter.save(this)\n    }\n\n    // delete object from the repo \n    async delete() {\n        await this.model.adapter.delete(this)\n        // reset ids\n        for(let id_name of this.model.ids)\n            this[id_name] = null\n    }\n\n    // add obj to the cache\n    @action inject() {\n        if (this.__id === null)                    \n            throw new Error(`Object should have id!`)\n        if (this.model.cache.has(this.__id)) {\n            throw new Error(`Object with id \"${this.__id}\" already exist in the cache of model: \"${this.model.name}\")`)\n        }\n        this.model.cache.set(this.__id, this)\n    }\n\n    // remove obj from the cache\n    @action eject() {\n        if (this.__id === null)\n            return                   \n        if (!this.model.cache.has(this.__id)) \n            throw new Error(`Object with id \"${this.__id}\" not exist in the cache of model: ${this.model.name}\")`)\n        this.model.cache.delete(this.__id)\n    }\n}\n\n\n// Decorator\nexport function model(constructor) {\n    var original = constructor\n\n    original.cache = observable(new Map())\n    // makeObservable(original, { cache: observable })\n\n    // the new constructor\n    let f : any = function (...args) {\n        // let c : any = function () { return original.apply(this, args) }\n        let c : any = class extends original { constructor (...args) { super(...args) } }\n\n        c.__proto__ = original\n        // c.prototype = original.prototype\n        let obj = new c()\n        makeObservable(obj)\n        // we have to save init data for detect changes\n        obj._init_data = args[0] ? args[0] : {}\n\n        // save default values from class declaration to init_data\n        for (let field_name in obj.model.fields) {\n            if (obj._init_data[field_name] === undefined && obj[field_name] !== undefined) {\n                obj._init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply fields decorators\n        for (let field_name in obj.model.fields) {\n            obj.model.fields[field_name].decorator(obj, field_name)\n        }\n\n        runInAction(() => {\n            // push init_data to object \n            // ids should be the last\n            let ids = []\n            for (let field_name in obj._init_data) {\n                if (obj.model.ids && obj.model.ids.includes(field_name))\n                    ids.push(field_name)\n                else\n                    obj[field_name] = obj._init_data[field_name]\n            }\n            for (let field_name of ids) {\n                obj[field_name] = obj._init_data[field_name]\n            }\n        })\n\n        return obj\n    }\n\n    f.__proto__ = original\n    f.prototype = original.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { Model } from '../model'\nimport Adapter  from './adapter'\n\n/*\n*/\n\nlet store = {}\n\nexport class LocalAdapter<M extends Model> implements Adapter<M> {\n    constructor(\n        private cls,\n        private store_name: string) {\n        store[store_name] = {}\n    }\n\n    async save(obj: M) : Promise<M> {\n        // create \n        if (obj.__id === null) {\n            // calculate and set new ID\n            let ids = [0]\n            for(let id of Object.keys(store[this.store_name])) {\n                ids.push(parseInt(id))\n            }\n            let max = Math.max.apply(null, ids)\n            for(let name_id of obj.model.ids) {\n                obj[name_id] = max + 1\n            }\n            store[this.store_name][obj.__id] = obj\n        }\n        // edit\n        else {\n            store[this.store_name][obj.__id] = obj\n        }\n        return obj\n    }\n    async delete(obj: M) : Promise<any> {\n        delete store[this.store_name][obj.__id]\n    }\n\n    load (where={}, order_by=[], limit=50, offset = 0) : Promise<M[]> {\n        throw('Not implemented')\n    }\n}\n\n// model decorator\nexport function local(api: string) {\n    return (cls) => {\n        let adapter = new LocalAdapter(cls, api)\n        cls.__proto__.adapter = adapter \n    }\n}\n","import { Model } from '../model'\nimport Adapter  from './adapter'\n\n/*\n*/\n\nexport class RestAdapter<M extends Model> implements Adapter<M> {\n    constructor(\n        private cls,\n        private http,\n        private api: string) {\n    }\n\n    async save(obj: M) : Promise<M> {\n        // gather data from obj\n        let data = {}\n        for(let field_name in obj.model.fields) {\n            if (obj[field_name] !== null) {\n                data[field_name] = obj[field_name]\n            }\n        }\n\n        if (obj.__id === null) {\n            // create \n            data = await this.http.post(`${this.api}/`, data)\n            // update values\n            for(let field_name in obj.model.fields) {\n                obj[field_name] = data[field_name]\n            }\n        }\n        else {\n            // edit\n            data = await this.http.put(`${this.api}/${obj.__id}/`, data)\n            // update values\n            for(let field_name in obj.model.fields) {\n                // do not touch the ids\n                if (!obj.model.ids.includes(field_name)) {\n                    obj[field_name] = data[field_name]\n                }\n            }\n        }\n        // push saved data to obj\n        return obj\n    }\n    async delete(obj: M) : Promise<any> {\n        return this.http.delete(`${this.api}/${obj.__id}/`)\n    }\n\n    async load (where={}, order_by=[], limit=50, offset = 0) : Promise<M[]> {\n        // TODO build query string \n        let query = ''\n\n        let data = await this.http.get(`${this.api}/?${query}`)\n\n        // init objects from data \n        let objs : M[] = []\n        for (let obj of data) {\n            objs.push(new this.cls(obj))\n        }\n        return objs\n    }\n}\n\n// model decorator\nexport function rest(http, api: string) {\n    return (cls) => {\n        let adapter = new RestAdapter(cls, http, api)\n        cls.__proto__.adapter = adapter \n    }\n}\n","import { observable, observe, intercept, extendObservable } from 'mobx'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to cache then you can use this \nnew Obj({id: x, ...})\n*/\n\nfunction field_ID (obj , field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // before changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && obj[field_name] !== null)\n            throw new Error(`You cannot change id field: ${field_name}. ${obj[field_name]} to ${change.newValue}`)\n        if (obj[field_name] !== null && change.newValue === null) {\n            try {\n                obj.eject()\n            }\n            catch (err) {\n                let ignore_error = `Object with id \"${obj.__id}\" not exist in the model cache: ${obj.model.name}\")`\n                if (err.name !== ignore_error)\n                    throw err\n            }\n        }\n        return change\n    })\n\n    // after changes\n    observe(obj, field_name, (change) => {\n        // if id is complete\n        if (obj.__id !== null) \n            obj.inject()\n    })\n\n}\n\n\nexport default function id(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n    if (model.ids    === undefined) model.ids = []\n\n    model.fields[field_name] = { decorator: field_ID }  // register field \n    model.ids.push(field_name)                          // register id\n\n}\n","import { extendObservable } from 'mobx'\n\n\n\nexport function field_field(obj, field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n}\n\n\nexport default function field(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n\n    model.fields[field_name] = { decorator: field_field }  // register field \n}\n","// import 'reflect-metadata'\nimport {intercept, observe, extendObservable, observable, autorun, when, reaction} from 'mobx'\n\nfunction field_foreign(obj, field_name) {\n    let edit_mode = false\n    let settings = obj.model.fields[field_name].settings\n    let foreign_model     = settings.foreign_model\n    let foreign_ids_names = settings.foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    reaction(\n        // watch on foreign cache for foreign object\n        () => {\n            let id = foreign_model.__id(obj, foreign_ids_names)\n            return id ? foreign_model.cache.get(id) : null\n        },\n        // update foreign field\n        (foreign_obj, prev, reaction) => {\n            obj[field_name] = foreign_obj ? foreign_obj : null \n        })\n\n    // Setter\n    // 1. checks before set new changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model == foreign_model)) {\n            throw new Error(`You can set only instance of \"${foreign_model.name}\" or null`)\n        }\n        return change\n    })\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let new_foreign_obj = change.newValue\n        let old_foreign_obj = change.oldValue\n\n        if (new_foreign_obj === old_foreign_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n        edit_mode = true\n        try {\n            if (change.newValue === null) {\n                // if foreign set to null then reset ids on the obj\n                for (let id_name of foreign_ids_names) {\n                    obj[id_name] = null \n                }\n            }\n            else {\n                // if foreign set to obj then update ids from the obj's ids\n                let obj_ids = change.newValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    // do not touch if it the same\n                    if (obj[foreign_ids_names[i]] != change.newValue[obj_ids[i]])\n                        obj[foreign_ids_names[i]]  = change.newValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // rollback changes!\n            if (change.oldValue === null) {\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = null \n                }\n            }\n            else {\n                let obj_ids = change.oldValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n            throw e\n        }\n\n        // if foreign have the one then update the one\n        if (settings.one) {\n            if (old_foreign_obj) {\n                old_foreign_obj[settings.one] = null\n            }\n            if (new_foreign_obj) {\n                new_foreign_obj[settings.one] = obj \n            }\n        }\n\n    })\n}\n\n\nexport default function foreign(foreign_model: any, ...foreign_ids_names: string[]) {\n    foreign_model = foreign_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.constructor\n        if (model.fields === undefined) model.fields = {}\n        // register field \n        model.fields[field_name] = { \n            decorator: field_foreign,\n            settings: {\n                foreign_model: foreign_model,\n                // if it is empty then try auto detect it (it works only with single id) \n                foreign_ids_names: foreign_ids_names.length ? foreign_ids_names : [`${field_name}_id`]\n            } \n        } \n\n        // TODO finish it\n        // watch on the foreign cache \n        // if foreign obj was created then it should be attached to foreign\n        // if foreign obj was deleted then it should be removed from foreign\n        // e.i. update foreign obj when foreign ids was changed\n        // reaction(() => foreign_model.cache, (value, prev_value, reaction) => {\n        //     debugger\n        // })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_one(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.fields[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.fields[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // 1. checks before set new changes\n    intercept(obj, <any>field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model === remote_model))\n                throw new Error(`You can set only instance of \"${remote_model.name}\" or null`)\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let old_remote_obj = change.oldValue\n        let new_remote_obj = change.newValue\n\n        if (new_remote_obj === old_remote_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote obj\n            if (old_remote_obj) {\n                for (let id_name of remote_foreign_ids_name) {\n                    old_remote_obj[id_name] = null \n                }\n            }\n            // set foreign ids on the remote obj \n            if (new_remote_obj) {\n                let obj_ids = obj.model.ids \n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]] = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\n\nexport default function one(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    remote_model = remote_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.fields === undefined) model.fields = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.fields[field_name] = { \n            decorator: field_one,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`one ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            // TODO: is it not bad?\n                            // if (obj[field_name])\n                            //     // TODO better name of error\n                            //     // TODO add test for this case\n                            //     throw ('One: bad')\n                            runInAction(() => { obj[field_name] = remote_obj })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`one ${field_name}`)) {\n                        remote_obj.disposers.get(`one ${field_name}`)()\n                        remote_obj.disposers.delete(`one ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) \n                        runInAction(() => { obj[field_name] = null })\n                    break\n            }\n        })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_many(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.fields[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.fields[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: []\n    })\n\n    // 1. checks before set new changes\n    intercept(obj[field_name], (change: any) => {\n        // TODO\n        // if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor === remote_model.__proto__))\n        //         throw new Error(`You can set only instance of \"${remote_model.__proto__.name}\" or null`)\n\n        // TODO: if we push exist obj then ignore it? and not duplicate\n        // TODO: create a test for this case \n        // remote obj can be in the many \n        // for (let new_remote_obj of change.added) {\n        //     const i = obj[field_name].indexOf(new_remote_obj)\n        //     if (i == -1)\n        //         throw new Error(`\"${new_remote_obj.model.name}\" id:\"${new_remote_obj.__id}\" alredy in many \"${obj.model.name}\" id:\"${field_name}\"`)\n        // }\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj[field_name], (change:any) => {\n        if (change.type !== 'splice')\n            return \n\n        let old_remote_objs = change.removed\n        let new_remote_objs = change.added\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote objs\n            for(let old_remote_obj of old_remote_objs)\n                for (let id_name of remote_foreign_ids_name)\n                    old_remote_obj[id_name] = null \n            // set foreign ids on the remote objs \n            let obj_ids = obj.model.ids \n            for(let new_remote_obj of new_remote_objs) {\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]]  = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\nexport default function many(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.fields === undefined) model.fields = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.fields[field_name] = { \n            decorator: field_many,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`many ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            const i = obj[field_name].indexOf(remote_obj)\n                            if (i == -1)\n                                runInAction(() => { obj[field_name].push(remote_obj) })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`many ${field_name}`)) {\n                        remote_obj.disposers.get(`many ${field_name}`)()\n                        remote_obj.disposers.delete(`many ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) {\n                        const i = obj[field_name].indexOf(remote_obj)\n                        if (i > -1)\n                            runInAction(() => { obj[field_name].splice(i, 1); })\n                    } \n                    break\n            }\n        })\n    }\n}"],"names":["Query","[object Object]","model","filters","order_by","page","page_size","Object","this","makeObservable","update","disposers","push","reaction","filter","observe","cache","change","type","watch_obj","newValue","__id","name","obj","oldValue","disposer_objects","i","items","indexOf","splice","id","disposer","is_updating","adapter","load","catch","err","runInAction","error","finally","is_ready","autorun","should_be_in_the_list","keys","length","key","Promise","resolve","reject","dispose","__decorate","observable","action","Model","args","Map","values","id_field_name","ids","id_name","undefined","constructor","__proto__","save","delete","Error","has","set","original","f","c","super","_init_data","field_name","fields","decorator","includes","prototype","computed","store","LocalAdapter","cls","store_name","parseInt","max","Math","apply","name_id","where","limit","offset","local","api","RestAdapter","http","data","post","put","get","objs","rest","field_ID","extendObservable","intercept","eject","ignore_error","inject","field_field","field","field_foreign","edit_mode","settings","foreign_model","foreign_ids_names","foreign_obj","prev","new_foreign_obj","old_foreign_obj","obj_ids","e","one","foreign","field_one","remote_model","remote_foreign_ids_name","remote_foreign_ids_names","old_remote_obj","new_remote_obj","toLowerCase","remote_change","remote_obj","field_many","old_remote_objs","removed","new_remote_objs","added","many"],"mappings":"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"}
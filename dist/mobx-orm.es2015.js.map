{"version":3,"file":"mobx-orm.es2015.js","sources":["../src/store.ts","../src/model.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { observable } from 'mobx'\n\n\ninterface FieldTypeDecorator {\n    (model_name: string, field_name: string, obj: Object): void\n}\n\ninterface ModelDescription {\n    fields: {\n        [field_name: string]: {\n            type    : string,\n            settings: any\n        }\n    }\n    objects: {\n        [id: number]: object\n    }\n    unique: {\n        [field_name: string]: any\n    }\n    getNewId: ()=>number\n    save  : undefined | ((obj)=> any) \n    delete: undefined | ((obj)=> any)\n    load  : undefined | ((model_name, where, order_by, limit, offset) => any)\n}\n\n/*\nФункции хранилища:\n    Note: all functions return nothing, you can catch errors in exception\n\n    model \t\t\t\t\t\t\t\t(cls) - декоратор для класса, который мы хотим зарегистрировать как модель\n    registerModel \t\t\t\t(model_name) - register model in store if not registered yet\n    registerModelPk\t\t\t\t(model_name, fieldKey)\t-\n    registerModelField \t\t(model_name, fieldKey, fieldWrapper) \t\t\t\t-\n*/\n\nexport class Store {\n\n    debug      : boolean = false \n    models     : { [model_name: string]: ModelDescription   } = {}\n    field_types: { [type_name : string]: FieldTypeDecorator } = {}\n\n\n    registerModel(model_name) {\n        if (!this.models[model_name]) {\n            let _count_id = 0\n            this.models[model_name] = {\n                objects: {},\n                fields : {},\n                unique : {},\n                getNewId: () => {\n                    _count_id = _count_id + 1\n                    return _count_id\n                },\n                save  : undefined,\n                delete: undefined,\n                load  : undefined\n            }\n            this.models[model_name].objects = observable(this.models[model_name].objects)\n        }\n        else throw new Error(`Model \"${model_name}\" already registered.`)\n    }\n\n    registerFieldType(type, decorator) {\n        if (!this.field_types[type])\n            this.field_types[type] = decorator\n        else\n            throw new Error(`Field type \"${type}\" already registered.`)\n    }\n\n    registerModelField(model_name, type, field_name, settings) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (!model_description.fields[field_name])\n            model_description.fields[field_name] = { type: type, settings: settings }\n        else\n            throw `Field \"${field_name}\" on \"${model_name}\" already registered.`\n    }\n\n    // registerUniqueField(model_name, field_name) {\n    // \tif (!this.models[model_name]) this.registerModel(model_name)\n    // \tlet model_description = this.models[model_name]\n    // \tif (!model_description.unique[field_name]) {\n    //\n    // \t\tlet unique_set = new Set()\n    // \t\t//\n    // \t\tmodel_description.unique[field_name] = unique_set\n    // \t\t// inject/eject/update\n    // \t\tmodel_description.fields[field_name].onUpdate(({obj}) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for updating ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onInject((obj) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for inject ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onEject((obj) => {\n    // \t\t\tunique_set.delete(obj[field_name])\n    // \t\t})\n    // \t}\n    // \telse {\n    // \t\tthrow `Unique on field \"${field_name}\" on \"${model_name}\" already registered.`\n    // \t}\n    // }\n\n    inject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can inject only instance of \"${model_name}\"`)\n        if (model_description.objects[object.id])  throw new Error(`Object with id=\"${object.id}\" already exist in model \"${model_name}\".`)\n\n        model_description.objects[object.id] = object\n    }\n\n    eject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can eject only instance of \"${model_name}\"`)\n        if (!model_description.objects[object.id]) throw new Error(`Object with id ${object.id} not exist in model \"${model_name}\"`)\n\n        delete model_description.objects[object.id]\n    }\n\n    clear() {\n        for (let model_name of Object.keys(this.models))\n            for (let obj of <any>Object.values(this.models[model_name].objects))\n                if(obj.delete)\n                    obj.delete()\n\n        this.models = {}\n    }\n\n    clearModel(model_name) {\n        for (let obj of <any>Object.values(this.models[model_name].objects))\n            if(obj.delete)\n                obj.delete()\n    }\n\n}\nlet store = new Store()\nexport default store\n\ndeclare let window\nwindow.mobx_orm_store = store\n","import store from './store'\n\n\nexport class Model {\n\n    static get(id: number): Model {\n        let model_name = this.prototype.constructor.name\n        return <Model>store.models[model_name].objects[id]\n    }\n\n    static all(): Model[] {\n        let model_name = this.prototype.constructor.name\n        return <Model[]>Object.values(store.models[model_name].objects)\n    }\n\n    static async load(where = {}, order_by = {}, limit = 0, offset = 0) {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.load) \n            return model_description.load(this, where, order_by, limit, offset)\n        else\n            throw Error(`load function is not defined for ${model_name}`) \n    }\n\n    static getFieldsNames() {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        return model_description.fields\n    }\n\n    private readonly _init_data\n\n    constructor(init_data?) {\n        this._init_data = init_data\n    }\n\n    // если нет id, то создать его\n    // если нужна синхронизация с удаленным хранилищем, то:\n    //      если нет id - то создаем объект удаленно, оттуда и приходит обект с готовым id\n    //\t\t\tесли есть   - то обновляем удаленно\n    async save() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.save) \n            return model_description.save(this)\n        else {\n            let obj = <any>this\n            if (!obj.id)\n                obj.id = model_description.getNewId()\n\n            return Promise.resolve(obj)\n        }\n    }\n\n    async delete() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.delete) \n            return model_description.delete(this)\n        else {\n            (<any>this).id = null\n            return Promise.resolve(this)\n        }\n    }\n}\n\n\n// Decorator\nexport function model(cls) {\n    // the new constructor behaviour\n    let f : any = function (...args) {\n        let c : any = function () { return cls.apply(this, args) }\n        c.__proto__ = cls.__proto__\n        c.prototype = cls.prototype\n\n        let model_name = cls.name\n        let model_description = store.models[model_name]\n\n        let obj  = new c()\n        let init_data = obj._init_data\n        delete obj._init_data\n\n        // save defaults from class declaration\n        for (let field_name in model_description.fields) {\n            if (obj[field_name] !== undefined && init_data[field_name] === undefined) {\n                init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply decorators\n        for (let field_name in model_description.fields) {\n            let type = model_description.fields[field_name].type\n            store.field_types[type](model_name, field_name, obj)\n        }\n        \n        if (init_data)\n            for (let field_name in init_data)\n                obj[field_name] = init_data[field_name]\n\n        return obj\n    }\n    // copy static properties/methods\n    for (let prop_name of Object.getOwnPropertyNames(cls))\n        if(f[prop_name] == undefined)\n            f[prop_name] = cls[prop_name]\n\n    f.__proto__ = cls.__proto__\n    f.prototype = cls.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { observable, observe, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'id'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to store then you can use this \nnew Obj({id: x, ...})\n*/\n\nexport function registerFieldId() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, 'id', (change) => {\n            if (change.newValue != null)\n                if(obj.id != null)\n                    throw new Error(`You cannot change id.`)\n                else if (!Number.isInteger(change.newValue))\n                    throw new Error(`Id can be only integer or null.`)\n\n            if (obj.id && change.newValue == null)\n                store.eject (model_name, obj)\n\n            return change\n        })\n\n        // after changes\n        observe(obj, 'id', (change) => {\n            if (change.newValue)\n                store.inject(model_name,obj)\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterFieldId()\n\n\nexport default function id(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    if (field_name != 'id')\n        throw new Error(`id field should named by 'id'`)\n    store.registerModelField(model_name, type, field_name, {})\n\n    // register observable into mobx\n    observable(cls, field_name)\n}\n","import { observable } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'field'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function field(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name, {})\n    // register into mobx\n    observable(cls, field_name)\n}\n","// import 'reflect-metadata'\nimport store from '../store'\nimport {intercept, observe, observable, autorun} from 'mobx'\n\n\nlet type = 'foreign'\n\nexport function registerForeign() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Computed\n        // watch \"foreign_id\" field\n        // e.i. update foreign obj when foreign id was changed\n        autorun(() => {\n            let foreign_obj = store.models[foreign_model_name].objects[obj[foreign_id_field_name]]\n            obj[field_name] = foreign_obj ? foreign_obj : null\n        })\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n            if (change.newValue !== null && change.newValue.id === null)\n                throw new Error(`Object should have id!`)\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n            try {\n                obj[foreign_id_field_name] = change.newValue === null ? null : change.newValue.id\n            }\n            catch(e) {\n                // rollback changes!\n                obj[foreign_id_field_name] = change.oldValue === null ? null : change.oldValue.id\n                throw e\n            }\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterForeign()\n\n\nexport default function foreign(foreign_model_name: any, foreign_id_field_name?: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        store.registerModelField(model_name, type, field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name ? foreign_id_field_name : `${field_name}_id`\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n    }\n}\n","import store from '../store'\nimport {intercept, observe, observable} from 'mobx'\n\n\nexport function registerOne() {\n    store.registerFieldType('one', (model_name, field_name, obj) => {\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null) {\n                if (!(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                    throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n                if (change.newValue.id === null)\n                    throw new Error(`Object should have id!`)\n            }\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n            let prev_old = null\n            let prev_new = null\n            try {\n                if (change.oldValue) {\n                    prev_old = change.oldValue[foreign_id_field_name]\n                    change.oldValue[foreign_id_field_name] = null\n                }\n                if (change.newValue) {\n                    prev_new = change.newValue[foreign_id_field_name]\n                    change.newValue[foreign_id_field_name] = obj.id\n                }\n            }\n            catch(e) {\n                // rollback changes!\n                if (change.newValue)\n                    change.newValue[foreign_id_field_name] = prev_new\n                if (change.oldValue)\n                    change.oldValue[foreign_id_field_name] = prev_old\n                throw e\n            }\n        })\n\n        // default value\n        obj[field_name] = null\n    })\n}\nregisterOne()\n\n\nexport default function one(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'one', field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // сдедим за созданием объектов, для первого подсчета one\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type == 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[field_name] = obj\n        })\n\n        // следим за всеми foreign объектами\n        observe(store.models[foreign_model_name].objects, (change) => {\n            switch (change.type) {\n                // появился новый объект\n                case 'add':\n                    let new_object = store.models[model_name].objects[(<any>change).newValue[foreign_id_field_name]]\n                    if (new_object)\n                        new_object[field_name] = change.newValue\n\n                    // подписываемся на каждый объект\n                    observe(change.newValue, foreign_id_field_name, (field_change) => {\n                        // first delete old\n                        if (field_change.oldValue) {\n                            let object = store.models[model_name].objects[field_change.oldValue]\n                            object[field_name] = null\n                        }\n                        //\n                        if (field_change.newValue) {\n                            let obj = store.models[model_name].objects[field_change.newValue]\n                            if (obj)\n                                obj[field_name] = change.newValue\n                        }\n                    })\n                    break\n                // удалили объект\n                case 'remove':\n                    let old_object = store.models[model_name].objects[(<any>change).oldValue[foreign_id_field_name]]\n                    if (old_object)\n                            old_object[field_name] = null\n                    break\n            }\n        })\n    }\n}\n","import { observable, observe } from 'mobx'\nimport store from '../store'\n\n\nexport function registerMany() {\n    store.registerFieldType('many', (model_name, field_name, obj) => {\n        // default value\n        obj[field_name] = []\n    })\n}\nregisterMany()\n\n\nexport default function many(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, many_field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        // detect class name\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name\n                = foreign_model_name.constructor.name == 'Function'\n                ? foreign_model_name.prototype.constructor.name\n                : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'many', many_field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, many_field_name)\n\n        // watch for creation of new objects for first calculation of \"many\"\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type == 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[many_field_name].push(obj)\n        })\n\n        // watch for all foreign objects\n        observe(store.models[foreign_model_name].objects, (change: any) => {\n            let foreign_object   : any\n            let object_with_many : any\n            switch (change.type) {\n                // new object was added \n                case 'add':\n                    foreign_object = change.newValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} start`)\n                        object_with_many[many_field_name].push(foreign_object)\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} finish`)\n                    }\n\n                    observe(foreign_object, foreign_id_field_name, (field_change) => {\n                        if (field_change.newValue) {\n                            let object_with_many_id = field_change.newValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} start`)\n                                object_with_many[many_field_name].push(foreign_object)\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} finish`)\n                            }\n                        }\n                        if (field_change.oldValue) {\n                            let object_with_many_id = field_change.oldValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                let index = object_with_many[many_field_name].indexOf(foreign_object)\n                                if (index > -1) {\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} start`)\n                                    object_with_many[many_field_name].splice(index, 1)\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} finish`)\n                                }\n                            }\n                        }\n                    })\n                    break\n                // object was removed \n                case 'remove':\n                    foreign_object = change.oldValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        let index = object_with_many[many_field_name].indexOf(foreign_object)\n                        if (index > -1) {\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} start`)\n                            object_with_many[many_field_name].splice(index, 1)\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} finish`)\n                        }\n                    }\n                    break\n            }\n        })\n    }\n}\n"],"names":["store","this","Store","model_name","models","Error","_count_id_1","objects","fields","unique","getNewId","save","undefined","delete","load","observable","type","decorator","field_types","field_name","settings","registerModel","model_description","object","constructor","id","name","_a","Object","keys","_i","_c","values","_b","obj","window","mobx_orm_store","init_data","_init_data","Model","prototype","where","order_by","limit","offset","Promise","resolve","model","cls","f","args","c","apply","__proto__","getOwnPropertyNames","prop_name","registerModelField","registerFieldType","intercept","change","newValue","Number","isInteger","eject","observe","inject","field","foreign","foreign_model_name","foreign_id_field_name","one","new_object","field_change","oldValue","old_object","many","many_field_name","push","foreign_object","object_with_many","debug","console","log","object_with_many_id","object_with_many_1","object_with_many_2","index","indexOf","splice","autorun","foreign_obj","e","prev_old","prev_new"],"mappings":"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"}
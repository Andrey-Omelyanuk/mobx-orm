{"version":3,"file":"mobx-orm.js","sources":["../src/adapter.ts","../src/store.ts","../src/model.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts","../src/fields/number.ts","../src/fields/float.ts","../src/fields/datetime.ts","../src/fields/boolean.ts"],"sourcesContent":["import { Model } from './model'\n\n\nexport interface Adapter {\n    save  : undefined | ((obj: Model)=> any) \n    delete: undefined | ((obj: Model)=> any)\n    load  : undefined | ((model_name, where, order_by, limit, offset) => any)\n}\n\nexport class DefaultAdapter implements Adapter {\n    newId = 0\n    async save(obj) {\n        let model_description = obj.getModelDescription()\n        if (obj.__id === null) {\n            for (let id_field_name of model_description.ids) {\n                obj[id_field_name] = this.newId\n            }\n            this.newId++\n        }\n        return Promise.resolve(obj)\n    }\n    async delete(obj: Model) {\n        let model_description = obj.getModelDescription()\n        for (let id_field_name of model_description.ids) {\n            obj[id_field_name] = null\n        }\n        return Promise.resolve(obj)\n    }\n    async load() {\n        throw new Error('Not Implemented for DefaultAdapter')\n    }\n}\n","import { observable } from 'mobx'\nimport { Model } from './model'\nimport { Adapter, DefaultAdapter } from './adapter'\n\n\nexport interface FieldTypeDecorator {\n    (model_name: string, field_name: string, obj: Object): void\n}\n\nexport interface ModelDescription {\n    ids     : any[]\n    fields  : {\n        [field_name: string]: {\n            type        : undefined | string,\n            settings    : undefined | any,\n            serialize   : undefined | any,\n            deserialize : undefined | any\n        }\n    },\n    objects : {\n        [string_id: string]: Model \n    } \n    adapter : Adapter\n}\n\n/*\nФункции хранилища:\n    Note: all functions return nothing, you can catch errors in exception\n\n    model \t\t\t\t\t\t\t\t(cls) - декоратор для класса, который мы хотим зарегистрировать как модель\n    registerModel \t\t\t\t(model_name) - register model in store if not registered yet\n    registerModelPk\t\t\t\t(model_name, fieldKey)\t-\n    registerModelField \t\t(model_name, fieldKey, fieldWrapper) \t\t\t\t-\n*/\n\nexport class Store {\n\n                debug      : boolean = false \n    @observable models     : { [model_name: string]: ModelDescription   } = {}\n                field_types: { [type_name : string]: FieldTypeDecorator } = {}\n\n    registerModel(model_name) {\n        if (!this.models[model_name]) {\n            let _count_id = 0\n            this.models[model_name] = {\n                ids     : [],\n                fields  : {},\n                objects : {},\n                adapter : new DefaultAdapter()\n            }\n            this.models[model_name].objects = observable(this.models[model_name].objects)\n        }\n        else throw new Error(`Model \"${model_name}\" already registered.`)\n    }\n\n    registerFieldType(type, decorator) {\n        if (!this.field_types[type])\n            this.field_types[type] = decorator\n        else\n            throw new Error(`Field type \"${type}\" already registered.`)\n    }\n\n    registerModelField(model_name, type, field_name, settings = {}, serialize = null, deserialize = null) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (!model_description.fields[field_name])\n            model_description.fields[field_name] = { type: type, settings: settings, serialize: serialize, deserialize: deserialize }\n        else\n            throw `Field \"${field_name}\" on \"${model_name}\" already registered.`\n    }\n\n    registerId(model_name, field_name) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (model_description.ids.indexOf(field_name) != -1)\n            throw `Id \"${field_name}\" in model \"${model_name}\" already registered.`\n        else\n            model_description.ids.push(field_name)\n    }\n\n    inject(obj: Model) {\n        let model_description = obj.getModelDescription()\n        if (obj.__id === null)                    throw new Error(`Object should have id!`)\n        if (model_description.objects[obj.__id])  throw new Error(`Object with id \"${obj.__id}\" already exist in the store (model: \"${obj.getModelName()}\")`)\n        model_description.objects[obj.__id] = obj\n    }\n\n    eject(obj: Model) {\n        if (obj.__id === null) return                   \n        let model_description = obj.getModelDescription()\n        if (!model_description.objects[obj.__id]) throw new Error(`Object with id \"${obj.__id}\" not exist in the store (model: ${obj.getModelName()}\")`)\n        delete model_description.objects[obj.__id]\n    }\n\n    clear() {\n        for (let model_name of Object.keys(this.models)) {\n            this.clearModel(model_name)\n        }\n        this.models = {}\n    }\n\n    clearModel(model_name) {\n        let model_desc = this.models[model_name]\n        if (model_desc) {\n            // we need it for run triggers on id fields \n            for (let obj of Object.values(model_desc.objects)) {\n                for (let id_field_name of model_desc.ids) {\n                    obj[id_field_name] = null\n                }\n            }\n        }\n    }\n\n    getId(obj: Model, id_name_fields: string[]) : string | null {\n        let id = '' \n        for (let id_name_field of id_name_fields) {\n            // if any id field is null then we should return null\n            // because id is not complite\n            if (obj[id_name_field] === null || obj[id_name_field] === undefined) \n                return null\n\n            id += `${obj[id_name_field]} :`\n        }\n        return id\n    }\n\n}\nlet store = new Store()\nexport default store\n\n// declare let window: any\n// if (window) \n//     window.mobx_orm_store = store\n","import { computed } from 'mobx'\nimport store, { ModelDescription } from './store'\n\n\nexport class Model {\n\n    static get(id: string): Model {\n        let model_description = this.getModelDescription()\n        return model_description.objects[id]\n    }\n\n    static all(): Model[] {\n        let model_description = this.getModelDescription()\n        return Object.values(model_description.objects)\n    }\n\n    static async load(where = {}, order_by = {}, limit = 0, offset = 0) {\n        let model_description = this.getModelDescription()\n        return model_description.adapter.load(this, where, order_by, limit, offset)\n    }\n\n    static getModelName() : string {\n        return this.prototype.constructor.name\n    }\n\n    static getModelDescription() : ModelDescription {\n        let model_name = this.getModelName()\n        let model_description = store.models[model_name]\n        if (model_description === undefined) \n            throw Error(`Description for '${model_name}' is not exist. Maybe, you called store.clear after model declaration.`)\n        return model_description\n    }\n\n    private readonly _init_data\n\n    constructor(init_data?) {\n        this._init_data = init_data\n    }\n\n    @computed({keepAlive: true}) get __id() : string | null {\n        return store.getId(this, this.getModelDescription().ids)\n    }\n\n    getModelName() : string {\n        return this.constructor.name\n    }\n\n    getModelDescription() : ModelDescription {\n        let model_name = this.getModelName() \n        let model_description = store.models[model_name]\n        if (model_description === undefined) \n            throw Error(`Description for '${model_name}' is not exist. Maybe, you called store.clear after model declaration.`)\n            // throw new Error(`Model name \"${model_name} is not registered in the store`)\n        return model_description\n    }\n    \n    async save() {\n        return this.getModelDescription().adapter.save(this)\n    }\n\n    async delete() {\n        return this.getModelDescription().adapter.delete(this)\n    }\n}\n\n\n// Decorator\nexport function model(cls) {\n    // the new constructor behaviour\n    let f : any = function (...args) {\n        let c : any = function () { return cls.apply(this, args) }\n        c.__proto__ = cls.__proto__\n        c.prototype = cls.prototype\n\n        let model_name        = cls.getModelName()\n        let model_description = cls.getModelDescription()\n\n        let obj  = new c()\n        let init_data = obj._init_data ? obj._init_data : {}\n        delete obj._init_data\n\n        // save defaults from class declaration\n        for (let field_name in model_description.fields) {\n            if (obj[field_name] !== undefined && init_data[field_name] === undefined) {\n                init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply decorators\n        for (let field_name in model_description.fields) {\n            let type = model_description.fields[field_name].type\n            store.field_types[type](model_name, field_name, obj)\n        }\n        \n        if (init_data)\n            for (let field_name in init_data)\n                obj[field_name] = init_data[field_name]\n\n        return obj\n    }\n    // copy static properties/methods\n    for (let prop_name of Object.getOwnPropertyNames(cls))\n        if(f[prop_name] == undefined)\n            f[prop_name] = cls[prop_name]\n\n    f.__proto__ = cls.__proto__\n    f.prototype = cls.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { observable, observe, intercept } from 'mobx'\nimport { Model } from '../model'\nimport store from '../store'\n\n\nlet type = 'id'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to store then you can use this \nnew Obj({id: x, ...})\n*/\n\nexport function registerFieldId() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && obj[field_name] !== null)\n                throw new Error(`You cannot change id field: ${field_name}`)\n\n            if (obj[field_name] !== null && change.newValue === null) {\n                try {\n                    store.eject(obj)\n                }\n                catch (err) {\n                    if (err.name !== `Object with id \"${obj.__id}\" not exist in the store (model: ${obj.getModelName()}\")`)\n                        throw err\n                }\n            }\n\n            return change\n        })\n\n        // after changes\n        observe(obj, field_name, (change) => {\n            // if id is complete\n            if (obj.__id !== null) \n                store.inject(obj)\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterFieldId()\n\n\nexport default function id(cls: Model, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    // let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(cls.getModelName(), type, field_name)\n    store.registerId(cls.getModelName(), field_name)\n    // register observable into mobx\n    observable(cls, field_name)\n}\n","import { observable } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'field'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function field(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","// import 'reflect-metadata'\nimport store from '../store'\nimport {intercept, observe, observable, autorun} from 'mobx'\n\n\nlet type = 'foreign'\n\nexport function registerForeign() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        let edit_mode = false\n        let foreign_model_name     = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_names = store.models[model_name].fields[field_name].settings.foreign_id_field_names\n\n        // Computed\n        // watch \"foreign id\" fields\n        // e.i. update foreign obj when foreign ids was changed\n        autorun(() => {\n            let id = store.getId(obj, foreign_id_field_names)\n            if (store.models[foreign_model_name]) {\n                let foreign_obj = store.models[foreign_model_name].objects[id]\n                obj[field_name] = foreign_obj ? foreign_obj : null \n            }\n        })\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue || edit_mode)\n                return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n            edit_mode = true\n            try {\n                if (change.newValue === null) {\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = null \n                    }\n                }\n                else {\n                    let foreign_model_description = change.newValue.getModelDescription()\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = change.newValue[foreign_model_description.ids[i]]\n                    }\n                }\n                edit_mode = false\n            }\n            catch(e) {\n                // rollback changes!\n                if (change.oldValue === null) {\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = null \n                    }\n                }\n                else {\n                    let foreign_model_description = change.newValue.getModelDescription()\n                    for (var i = 0; i < foreign_id_field_names.length; i++) {\n                        obj[foreign_id_field_names[i]] = change.oldValue[foreign_model_description.ids[i]]\n                    }\n                }\n                edit_mode = false\n                throw e\n            }\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterForeign()\n\n\nexport default function foreign(foreign_model_name: any, ...foreign_id_field_names: string[]) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        // let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        let model_name = cls.getModelName()\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        store.registerModelField(model_name, type, field_name, {\n            foreign_model_name    : foreign_model_name,\n            foreign_id_field_names: foreign_id_field_names.length ? foreign_id_field_names : [`${field_name}_id`]\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n    }\n}\n","import { store, Model } from '../index'\nimport {intercept, observe, observable} from 'mobx'\n\n\nexport function registerOne() {\n    store.registerFieldType('one', (model_name: string, field_name: string, obj: Model) => {\n        let remote_model_name             = store.models[model_name].fields[field_name].settings.remote_model_name\n        let foreign_field_on_remote_model = store.models[model_name].fields[field_name].settings.foreign_field_on_remote_model\n\n        // 1. checks before set new changes\n        intercept(obj, <any>field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name === remote_model_name))\n                    throw new Error(`You can set only instance of \"${remote_model_name}\" or null`)\n            return change\n        })\n\n        // default value\n        obj[field_name] = null\n    })\n}\nregisterOne()\n\n\nexport default function one(remote_model_name: any, foreign_field_on_remote_model: string) {\n    return function (cls: any, field_name: string) {\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        // let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        let model_name = cls.getModelName()\n\n        // detect class name\n        if (typeof remote_model_name === 'function')\n            remote_model_name = remote_model_name.constructor.name == 'Function' \n                ? remote_model_name.prototype.constructor.name \n                : remote_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[remote_model_name])  store.registerModel(remote_model_name)\n        store.registerModelField(model_name, 'one', field_name, {\n            remote_model_name               : remote_model_name,\n            foreign_field_on_remote_model   : foreign_field_on_remote_model\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // watch foreign fields on exists remote object \n        for (let remote_object of Object.values(store.models[remote_model_name].objects)) {\n            observe(remote_object, <any>foreign_field_on_remote_model, (remote_foreign_field_change) => {\n                // remove old\n                if (remote_foreign_field_change.oldValue) \n                    remote_foreign_field_change.oldValue[field_name] = null\n                // add new\n                if (remote_foreign_field_change.newValue)\n                    remote_foreign_field_change.newValue[field_name] = remote_object\n            })\n        }\n\n        // watch for remote object that related to one-field\n        observe(store.models[remote_model_name].objects, (remote_change) => {\n            switch (remote_change.type) {\n                // remote object was injected\n                case 'add':\n                    // watch foreign field on remote object \n                    observe(remote_change.newValue, foreign_field_on_remote_model, (remote_foreign_field_change) => {\n                        // remove old\n                        if (remote_foreign_field_change.oldValue) \n                            remote_foreign_field_change.oldValue[field_name] = null\n                        // add new\n                        if (remote_foreign_field_change.newValue)\n                            remote_foreign_field_change.newValue[field_name] = remote_change.newValue\n                    })\n                    break\n                // remote object was ejected\n                case 'remove':\n                    // TODO: check memory leaks (unsubscribe observer in 'add' section)\n                    let obj = remote_change.oldValue[foreign_field_on_remote_model]\n                    if (obj) \n                        obj[field_name] = null\n                    break\n            }\n        })\n    }\n}\n","import { observable, observe } from 'mobx'\nimport store from '../store'\n\n\nexport function registerMany() {\n    store.registerFieldType('many', (model_name, field_name, obj) => {\n        // default value\n        obj[field_name] = []\n    })\n}\nregisterMany()\n\n\nexport default function many(remote_model_name: any, foreign_field_on_remote_model: string) {\n    return function (cls: any, field_name: string) {\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        // let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        let model_name = cls.getModelName()\n\n        // detect class name\n        if (typeof remote_model_name === 'function')\n            remote_model_name = remote_model_name.constructor.name == 'Function'\n                ? remote_model_name.prototype.constructor.name\n                : remote_model_name.constructor.name\n        //\n        if (!store.models[model_name])          store.registerModel(model_name)\n        if (!store.models[remote_model_name])   store.registerModel(remote_model_name)\n        store.registerModelField(model_name, 'many', field_name, {\n            remote_model_name               : remote_model_name,\n            foreign_field_on_remote_model   : foreign_field_on_remote_model\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // watch foreign fields on exists remote object \n        // for (let remote_object of Object.values(store.models[remote_model_name].objects)) {\n        //     observe(remote_object, <any>foreign_field_on_remote_model, (remote_foreign_field_change) => {\n        //         // remove old\n        //         if (remote_foreign_field_change.oldValue) \n        //             remote_foreign_field_change.oldValue[field_name] = null\n        //         // add new\n        //         if (remote_foreign_field_change.newValue)\n        //             remote_foreign_field_change.newValue[field_name] = remote_object\n        //     })\n        // }\n\n        // watch for all foreign objects\n        observe(store.models[remote_model_name].objects, (remote_change: any) => {\n            switch (remote_change.type) {\n                // remote object was injected\n                case 'add':\n                    // watch foreign field on remote object \n                    observe(remote_change.newValue, foreign_field_on_remote_model, (remote_foreign_field_change) => {\n                        // remote old\n                        if (remote_foreign_field_change.oldValue) {\n                            let object_with_many = remote_foreign_field_change.oldValue\n                            let index = object_with_many[field_name].indexOf(remote_change.newValue)\n                            if (index > -1) {\n                                object_with_many[field_name].splice(index, 1)\n                            }\n                        }\n                        // add new\n                        if (remote_foreign_field_change.newValue)\n                            remote_foreign_field_change.newValue[field_name].push(remote_change.newValue)\n                    })\n                    break\n                // object was removed \n                case 'remove':\n                    let object_with_many = remote_change.oldValue[foreign_field_on_remote_model]\n                    if (object_with_many) {\n                        let index = object_with_many[field_name].indexOf(remote_change.oldValue)\n                        if (index > -1) {\n                            object_with_many[field_name].splice(index, 1)\n                        }\n                    }\n                    break\n            }\n        })\n    }\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'number'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (!(change.newValue === Number(change.newValue) && change.newValue % 1 === 0))\n                    throw new Error(`Field can be only integer or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'float'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (change.newValue !== Number(change.newValue))\n                    throw new Error(`Field can be only float or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\nimport { isNoop } from '@babel/types';\n\n\nlet type = 'datetime'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null) {\n                if(typeof change.newValue === 'string' || change.newValue instanceof String) {\n                    change.newValue = Date.parse(<any>change.newValue)\n                    if (!isNaN(change.newValue))\n                        change.newValue = new Date(change.newValue)\n                }\n                if (!(change.newValue instanceof Date)) \n                    throw new Error(`Field can be only Date or null.`)\n            }\n            return change\n        })\n    })\n}\nregisterField()\n\n\nexport default function datetime(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name, {},\n        (obj) => { return new Date(obj)     },\n        (obj) => { return obj.toISOString() }\n    )\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'boolean'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                change.newValue = Boolean(change.newValue)\n            return change\n        })\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n"],"names":["this","DefaultAdapter","obj","model_description","getModelDescription","__id","_a","ids","_i","id_field_name","newId","Promise","resolve","Error","store","Store","model_name","models","fields","objects","adapter","observable","type","decorator","field_types","field_name","settings","serialize","deserialize","registerModel","indexOf","push","getModelName","Object","keys","clearModel","model_desc","values","_c","_b","id_name_fields","id","id_name_fields_1","id_name_field","undefined","tslib_1.__decorate","init_data","_init_data","Model","where","order_by","limit","offset","load","prototype","constructor","name","getId","save","delete","computed","keepAlive","registerFieldType","intercept","change","newValue","eject","err","observe","inject","edit_mode","foreign_model_name","foreign_id_field_names","autorun","foreign_obj","oldValue","i","length","foreign_model_description","e","remote_model_name","foreign_field_on_remote_model","Number","String","Date","parse","isNaN","Boolean","cls","registerModelField","toISOString","registerId","remote_change","remote_foreign_field_change","object_with_many_1","index","splice","object_with_many","f","args","c","apply","__proto__","getOwnPropertyNames","prop_name","remote_object"],"mappings":"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"}
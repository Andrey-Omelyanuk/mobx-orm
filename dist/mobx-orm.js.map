{"version":3,"file":"mobx-orm.js","sources":["../src/store.ts","../src/model.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { observable } from 'mobx'\n\n\ninterface FieldTypeDecorator {\n    (model_name: string, field_name: string, obj: Object): void\n}\n\ninterface ModelDescription {\n    fields: {\n        [field_name: string]: {\n            type    : string,\n            settings: any\n        }\n    }\n    objects: {\n        [id: number]: object\n    }\n    unique: {\n        [field_name: string]: any\n    }\n    getNewId: ()=>number\n    save  : undefined | ((obj)=> any) \n    delete: undefined | ((obj)=> any)\n    load  : undefined | ((model_name, where, order_by, limit, offset) => any)\n}\n\n/*\nФункции хранилища:\n    Note: all functions return nothing, you can catch errors in exception\n\n    model \t\t\t\t\t\t\t\t(cls) - декоратор для класса, который мы хотим зарегистрировать как модель\n    registerModel \t\t\t\t(model_name) - register model in store if not registered yet\n    registerModelPk\t\t\t\t(model_name, fieldKey)\t-\n    registerModelField \t\t(model_name, fieldKey, fieldWrapper) \t\t\t\t-\n*/\n\nexport class Store {\n\n    debug      : boolean = false \n    models     : { [model_name: string]: ModelDescription   } = {}\n    field_types: { [type_name : string]: FieldTypeDecorator } = {}\n\n\n    registerModel(model_name) {\n        if (!this.models[model_name]) {\n            let _count_id = 0\n            this.models[model_name] = {\n                objects: {},\n                fields : {},\n                unique : {},\n                getNewId: () => {\n                    _count_id = _count_id + 1\n                    return _count_id\n                },\n                save  : undefined,\n                delete: undefined,\n                load  : undefined\n            }\n            this.models[model_name].objects = observable(this.models[model_name].objects)\n        }\n        else throw new Error(`Model \"${model_name}\" already registered.`)\n    }\n\n    registerFieldType(type, decorator) {\n        if (!this.field_types[type])\n            this.field_types[type] = decorator\n        else\n            throw new Error(`Field type \"${type}\" already registered.`)\n    }\n\n    registerModelField(model_name, type, field_name, settings) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (!model_description.fields[field_name])\n            model_description.fields[field_name] = { type: type, settings: settings }\n        else\n            throw `Field \"${field_name}\" on \"${model_name}\" already registered.`\n    }\n\n    // registerUniqueField(model_name, field_name) {\n    // \tif (!this.models[model_name]) this.registerModel(model_name)\n    // \tlet model_description = this.models[model_name]\n    // \tif (!model_description.unique[field_name]) {\n    //\n    // \t\tlet unique_set = new Set()\n    // \t\t//\n    // \t\tmodel_description.unique[field_name] = unique_set\n    // \t\t// inject/eject/update\n    // \t\tmodel_description.fields[field_name].onUpdate(({obj}) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for updating ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onInject((obj) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for inject ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onEject((obj) => {\n    // \t\t\tunique_set.delete(obj[field_name])\n    // \t\t})\n    // \t}\n    // \telse {\n    // \t\tthrow `Unique on field \"${field_name}\" on \"${model_name}\" already registered.`\n    // \t}\n    // }\n\n    inject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can inject only instance of \"${model_name}\"`)\n        if (model_description.objects[object.id])  throw new Error(`Object with id=\"${object.id}\" already exist in model \"${model_name}\".`)\n\n        model_description.objects[object.id] = object\n    }\n\n    eject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can eject only instance of \"${model_name}\"`)\n        if (!model_description.objects[object.id]) throw new Error(`Object with id ${object.id} not exist in model \"${model_name}\"`)\n\n        delete model_description.objects[object.id]\n    }\n\n    clear() {\n        for (let model_name of Object.keys(this.models))\n            for (let obj of <any>Object.values(this.models[model_name].objects))\n                if(obj.delete)\n                    obj.delete()\n\n        this.models = {}\n    }\n\n    clearModel(model_name) {\n        for (let obj of <any>Object.values(this.models[model_name].objects))\n            if(obj.delete)\n                obj.delete()\n    }\n\n}\nlet store = new Store()\nexport default store\n\ndeclare let window\nwindow.mobx_orm_store = store\n","import store from './store'\n\n\nexport class Model {\n\n    static get(id: number): Model {\n        let model_name = this.prototype.constructor.name\n        return <Model>store.models[model_name].objects[id]\n    }\n\n    static all(): Model[] {\n        let model_name = this.prototype.constructor.name\n        return <Model[]>Object.values(store.models[model_name].objects)\n    }\n\n    static async load(where = {}, order_by = {}, limit = 0, offset = 0) {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.load) \n            return model_description.load(this, where, order_by, limit, offset)\n        else\n            throw Error(`load function is not defined for ${model_name}`) \n    }\n\n    static getFieldsNames() {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        return model_description.fields\n    }\n\n    private readonly _init_data\n\n    constructor(init_data?) {\n        this._init_data = init_data\n    }\n\n    // если нет id, то создать его\n    // если нужна синхронизация с удаленным хранилищем, то:\n    //      если нет id - то создаем объект удаленно, оттуда и приходит обект с готовым id\n    //\t\t\tесли есть   - то обновляем удаленно\n    async save() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.save) \n            return model_description.save(this)\n        else {\n            let obj = <any>this\n            if (!obj.id)\n                obj.id = model_description.getNewId()\n\n            return Promise.resolve(obj)\n        }\n    }\n\n    async delete() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.delete) \n            return model_description.delete(this)\n        else {\n            (<any>this).id = null\n            return Promise.resolve(this)\n        }\n    }\n}\n\n\n// Decorator\nexport function model(cls) {\n    // the new constructor behaviour\n    let f : any = function (...args) {\n        let c : any = function () { return cls.apply(this, args) }\n        c.__proto__ = cls.__proto__\n        c.prototype = cls.prototype\n\n        let model_name = cls.name\n        let model_description = store.models[model_name]\n\n        let obj  = new c()\n        let init_data = obj._init_data\n        delete obj._init_data\n\n        // save defaults from class declaration\n        for (let field_name in model_description.fields) {\n            if (obj[field_name] !== undefined && init_data[field_name] === undefined) {\n                init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply decorators\n        for (let field_name in model_description.fields) {\n            let type = model_description.fields[field_name].type\n            store.field_types[type](model_name, field_name, obj)\n        }\n        \n        if (init_data)\n            for (let field_name in init_data)\n                obj[field_name] = init_data[field_name]\n\n        return obj\n    }\n    // copy static properties/methods\n    for (let prop_name of Object.getOwnPropertyNames(cls))\n        if(f[prop_name] == undefined)\n            f[prop_name] = cls[prop_name]\n\n    f.__proto__ = cls.__proto__\n    f.prototype = cls.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { observable, observe, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'id'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to store then you can use this \nnew Obj({id: x, ...})\n*/\n\nexport function registerFieldId() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, 'id', (change) => {\n            if (change.newValue != null)\n                if(obj.id != null)\n                    throw new Error(`You cannot change id.`)\n                else if (!Number.isInteger(change.newValue))\n                    throw new Error(`Id can be only integer or null.`)\n\n            if (obj.id && change.newValue == null)\n                store.eject (model_name, obj)\n\n            return change\n        })\n\n        // after changes\n        observe(obj, 'id', (change) => {\n            if (change.newValue)\n                store.inject(model_name,obj)\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterFieldId()\n\n\nexport default function id(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    if (field_name != 'id')\n        throw new Error(`id field should named by 'id'`)\n    store.registerModelField(model_name, type, field_name, {})\n\n    // register observable into mobx\n    observable(cls, field_name)\n}\n","import { observable } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'field'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function field(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name, {})\n    // register into mobx\n    observable(cls, field_name)\n}\n","// import 'reflect-metadata'\nimport store from '../store'\nimport {intercept, observe, observable, autorun} from 'mobx'\n\n\nlet type = 'foreign'\n\nexport function registerForeign() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Computed\n        // watch \"foreign_id\" field\n        // e.i. update foreign obj when foreign id was changed\n        autorun(() => {\n            let foreign_obj = store.models[foreign_model_name].objects[obj[foreign_id_field_name]]\n            obj[field_name] = foreign_obj ? foreign_obj : null\n        })\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n            if (change.newValue !== null && change.newValue.id === null)\n                throw new Error(`Object should have id!`)\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n            try {\n                obj[foreign_id_field_name] = change.newValue === null ? null : change.newValue.id\n            }\n            catch(e) {\n                // rollback changes!\n                obj[foreign_id_field_name] = change.oldValue === null ? null : change.oldValue.id\n                throw e\n            }\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterForeign()\n\n\nexport default function foreign(foreign_model_name: any, foreign_id_field_name?: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        store.registerModelField(model_name, type, field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name ? foreign_id_field_name : `${field_name}_id`\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n    }\n}\n","import store from '../store'\nimport {intercept, observe, observable} from 'mobx'\n\n\nexport function registerOne() {\n    store.registerFieldType('one', (model_name, field_name, obj) => {\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null) {\n                if (!(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                    throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n                if (change.newValue.id === null)\n                    throw new Error(`Object should have id!`)\n            }\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n            let prev_old = null\n            let prev_new = null\n            try {\n                if (change.oldValue) {\n                    prev_old = change.oldValue[foreign_id_field_name]\n                    change.oldValue[foreign_id_field_name] = null\n                }\n                if (change.newValue) {\n                    prev_new = change.newValue[foreign_id_field_name]\n                    change.newValue[foreign_id_field_name] = obj.id\n                }\n            }\n            catch(e) {\n                // rollback changes!\n                if (change.newValue)\n                    change.newValue[foreign_id_field_name] = prev_new\n                if (change.oldValue)\n                    change.oldValue[foreign_id_field_name] = prev_old\n                throw e\n            }\n        })\n\n        // default value\n        obj[field_name] = null\n    })\n}\nregisterOne()\n\n\nexport default function one(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'one', field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // сдедим за созданием объектов, для первого подсчета one\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type == 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[field_name] = obj\n        })\n\n        // следим за всеми foreign объектами\n        observe(store.models[foreign_model_name].objects, (change) => {\n            switch (change.type) {\n                // появился новый объект\n                case 'add':\n                    let new_object = store.models[model_name].objects[(<any>change).newValue[foreign_id_field_name]]\n                    if (new_object)\n                        new_object[field_name] = change.newValue\n\n                    // подписываемся на каждый объект\n                    observe(change.newValue, foreign_id_field_name, (field_change) => {\n                        // first delete old\n                        if (field_change.oldValue) {\n                            let object = store.models[model_name].objects[field_change.oldValue]\n                            object[field_name] = null\n                        }\n                        //\n                        if (field_change.newValue) {\n                            let obj = store.models[model_name].objects[field_change.newValue]\n                            if (obj)\n                                obj[field_name] = change.newValue\n                        }\n                    })\n                    break\n                // удалили объект\n                case 'remove':\n                    let old_object = store.models[model_name].objects[(<any>change).oldValue[foreign_id_field_name]]\n                    if (old_object)\n                            old_object[field_name] = null\n                    break\n            }\n        })\n    }\n}\n","import { observable, observe } from 'mobx'\nimport store from '../store'\n\n\nexport function registerMany() {\n    store.registerFieldType('many', (model_name, field_name, obj) => {\n        // default value\n        obj[field_name] = []\n    })\n}\nregisterMany()\n\n\nexport default function many(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, many_field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        // detect class name\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name\n                = foreign_model_name.constructor.name == 'Function'\n                ? foreign_model_name.prototype.constructor.name\n                : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'many', many_field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, many_field_name)\n\n        // watch for creation of new objects for first calculation of \"many\"\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type == 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[many_field_name].push(obj)\n        })\n\n        // watch for all foreign objects\n        observe(store.models[foreign_model_name].objects, (change: any) => {\n            let foreign_object   : any\n            let object_with_many : any\n            switch (change.type) {\n                // new object was added \n                case 'add':\n                    foreign_object = change.newValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} start`)\n                        object_with_many[many_field_name].push(foreign_object)\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} finish`)\n                    }\n\n                    observe(foreign_object, foreign_id_field_name, (field_change) => {\n                        if (field_change.newValue) {\n                            let object_with_many_id = field_change.newValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} start`)\n                                object_with_many[many_field_name].push(foreign_object)\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} finish`)\n                            }\n                        }\n                        if (field_change.oldValue) {\n                            let object_with_many_id = field_change.oldValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                let index = object_with_many[many_field_name].indexOf(foreign_object)\n                                if (index > -1) {\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} start`)\n                                    object_with_many[many_field_name].splice(index, 1)\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} finish`)\n                                }\n                            }\n                        }\n                    })\n                    break\n                // object was removed \n                case 'remove':\n                    foreign_object = change.oldValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        let index = object_with_many[many_field_name].indexOf(foreign_object)\n                        if (index > -1) {\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} start`)\n                            object_with_many[many_field_name].splice(index, 1)\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} finish`)\n                        }\n                    }\n                    break\n            }\n        })\n    }\n}\n"],"names":["store","this","Store","model_name","models","Error","_count_id_1","objects","fields","unique","getNewId","save","undefined","delete","load","observable","type","decorator","field_types","field_name","settings","registerModel","model_description","object","constructor","id","name","_a","Object","keys","_i","_c","values","_b","obj","window","mobx_orm_store","init_data","_init_data","Model","prototype","where","order_by","limit","offset","Promise","resolve","registerFieldType","intercept","change","newValue","Number","isInteger","eject","observe","inject","foreign_model_name","foreign_id_field_name","autorun","foreign_obj","oldValue","e","prev_old","prev_new","cls","registerModelField","many_field_name","push","foreign_object","object_with_many","debug","console","log","field_change","object_with_many_id","object_with_many_1","object_with_many_2","index","indexOf","splice","f","args","c","apply","__proto__","getOwnPropertyNames","prop_name","new_object","old_object"],"mappings":"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"}
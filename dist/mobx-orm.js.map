{"version":3,"file":"mobx-orm.js","sources":["../src/query-base.ts","../src/query.ts","../src/query-page.ts","../src/model.ts","../src/adapters/adapter.ts","../src/adapters/local.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport Adapter from \"./adapters/adapter\"\nimport { Model } from \"./model\"\n\n\nexport default abstract class Query<M extends Model> {\n\n    @observable filters     : object  \n    @observable order_by    : string[]\n    @observable page        : number\n    @observable page_size   : number\n\n    get items      () { return this.__items }\n    get is_loading () { return this.__is_loading  }\n    get error      () { return this.__error       }\n    \n\treadonly __base_cache: any\n\treadonly __adapter: Adapter<M>\n    @observable __items: M[] = []\n    @observable __is_loading  : boolean = false \n    @observable __error       : string = '' \n\n    __disposers = []\n    __disposer_objects = {}\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n\t\tthis.__base_cache = base_cache\n\t\tthis.__adapter    = adapter\n        if (filters  ) this.filters   = filters\n        if (order_by ) this.order_by  = order_by\n\t\tif (page\t ) this.page      = page\n\t\tif (page_size) this.page_size = page_size\n        makeObservable(this)\n    }\n\n    destroy() {\n        for(let disposer of this.__disposers) disposer()\n        for(let __id in this.__disposer_objects) this.__disposer_objects[__id]()\n    }\n\n    abstract __load(objs: M[])\n\n    @action async load() {\n        this.__is_loading = true\n        try {\n            let objs = await this.__adapter.load(this.filters, this.order_by, this.page_size, this.page*this.page_size)\n\t\t\tthis.__load(objs)\n        }\n        catch(e) {\n            runInAction(() => this.__error = e)\n\t\t\tthrow e\n        }\n        finally {\n            runInAction(() => this.__is_loading = false)\n        }\n    }\n\n    ready(): Promise<Boolean> {\n        return new Promise((resolve, reject) => { \n            autorun((reaction) => {\n                if (!this.__is_loading) {\n                    reaction.dispose()\n                    resolve(!this.__is_loading) \n                }\n            })\n        })\n    }\n\n    __is_matched(obj) {\n        for(let key in this.filters) {\n            if (obj[key] != this.filters[key]) {\n                return false\n            }\n        }\n        return true\n    }\n}\n","import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QeuryBase from './query-base'\n\n\n/*\nReactive items:\n- delete from the cache -> delete from items\n- add to the cache \n    - the new obj is match the filters  -> add the obj to items\n- obj was changed \n    - не было но уже    попадание по фильтрам -> add the obj to items\n    -    было но уже не попадание по фильтрам -> remove the obj from items\n*/\n\nexport default class Query<M extends Model> extends QeuryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[]) {\n        super(adapter, base_cache, filters, order_by)\n\n        this.load() // load when query is created\n\n        // update if filters was changed\n        // watch only filters, if order was changed then we don't need to update, just resort\n        this.__disposers.push(reaction(\n            () => { filter: this.filters },\n            () => { this.load() }\n        ))\n\n        // watch the cache for changes, and update items if needed\n        this.__disposers.push(observe(this.__base_cache, (change: any) => {\n            if (change.type == 'add') {\n                this.watch_obj(change.newValue)\n            }\n            if (change.type == \"delete\") {\n                let __id = change.name\n                let obj  = change.oldValue\n                this.__disposer_objects[__id]()\n                delete this.__disposer_objects[__id]\n                let i = this.items.indexOf(obj)\n                if (i != -1)\n                    runInAction(() => {\n                        this.items.splice(i, 1)\n                    })\n            }\n        }))\n\n        // watch all exist objects of model \n        for(let [id, obj] of this.__base_cache) {\n            this.watch_obj(obj)\n        }\n    }\n\n    private watch_obj(obj) {\n        this.__disposer_objects[obj.__id] = autorun(\n            () => {\n                let should = this.__is_matched(obj)\n                let i = this.items.indexOf(obj)\n                // should be in the items and it is not in the items? add it to the items\n                if ( should && i == -1) runInAction(() => this.items.push(obj))\n                // should not be in the items and it is in the items? remove it from the items\n                if (!should && i != -1) runInAction(() => this.items.splice(i, 1))\n            })\n    }\n\n}\n","import { action, autorun, computed, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QueryBase from './query-base'\n\n/*\nПоведение реактивности items\n\nactions:\n    - удаление объекта который в items -> update() ? or just delete from items?\n    - добавление в кэш\n        - попадание по фильтрам -> update() ? or show `query should to update`?\n    - изменение в кэш\n        - не было но уже    попадание по фильтрам -> update()  ? or show `query should to update`?\n        -    было но уже не попадание по фильтрам -> update() ? or show `query should to update`?\n\nneed_to_update = \nauto_update = \n*/\n\n// TODO get total count - we need to count pages num\n\nexport default class Query<M extends Model> extends QueryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n        super(adapter, base_cache, filters, order_by)\n        if(this.page === undefined) this.page = 0\n        if(this.page_size === undefined) this.page_size = 50\n\n        this.load() // load when query is created\n\n        // update if query is changed\n        this.__disposers.push(reaction(\n            () => { return { \n                filter          : this.filters, \n                order_by        : this.order_by, \n                page            : this.page, \n                page_size       : this.page_size,\n             }},\n            () => { this.load() }\n        ))\n\n        // // watch the cache for changes, and update items if needed\n        // this.__disposers.push(observe(this.__base_cache, (change: any) => {\n        //     if (change.type == 'add') {\n        //         this.watch_obj(change.newValue)\n        //     }\n        //     if (change.type == \"delete\") {\n        //         let __id = change.name\n        //         let obj  = change.oldValue\n        //         this.__disposer_objects[__id]()\n        //         delete this.__disposer_objects[__id]\n        //         let i = this.items.indexOf(obj)\n        //         if (i != -1)\n        //             runInAction(() => {\n        //                 this.items.splice(i, 1)\n        //             })\n        //     }\n        // }))\n\n        // // watch all exist objects of model \n        // for(let [id, obj] of this.__base_cache) {\n        //     this.watch_obj(obj)\n        // }\n    }\n\n    //\n    private watch_obj(obj) {\n        this.__disposer_objects[obj.__id] = autorun(\n            () => {\n                let should_be_in_the_list = this.__is_matched(obj)\n                if (should_be_in_the_list) {\n                    let i = this.items.indexOf(obj)\n                    if (should_be_in_the_list && i == -1)\n                        runInAction(() => this.items.push(obj))\n                        \n                    if (!should_be_in_the_list && i != -1)\n                        runInAction(() => this.items.splice(i, 1))\n                }\n            })\n    }\n\n}\n\n","import { field } from 'dist/mobx-orm'\nimport { action, computed, makeObservable, observable, runInAction } from 'mobx'\nimport Adapter   from './adapters/adapter'\nimport QueryBase from './query-base'\nimport Query     from './query'\nimport QueryPage from './query-page'\n\n\nexport abstract class Model {\n    private static id_separator: string = '-'\n    // this private static properties will be copied to real model in the model decorator\n    private static adapter      : Adapter<Model>\n    private static cache        : Map<string, Model>\n    // we have 3 types of fields\n    // - ids (cannot be changed, order of keys is important)\n    // - fields\n    // - relations (not exist on outside)\n    private static ids: Map<string, {\n            // can decorator be different?\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }>\n    private static fields       : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }\n    }\n    // relateions is a list of field only foreign, one or many types\n    private static relations    : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any\n            // there is no serializer of deserializer because \n            // it is derivative and does not come from outside\n        }\n    }\n\n    // add obj to the cache\n    @action static inject(obj: Model) {\n        debugger\n        if (obj.__id === null)                    \n            throw new Error(`Object should have id!`)\n        if (this.cache.has(obj.__id)) {\n            throw new Error(`Object with id \"${obj.__id}\" already exist in the cache of model: \"${this.name}\")`)\n        }\n        this.cache.set(obj.__id, obj)\n    }\n\n    // remove obj from the cache\n    @action static eject(obj: Model) {\n        if (obj.__id === null)\n            return                   \n        if (!this.cache.has(obj.__id)) \n            throw new Error(`Object with id \"${obj.__id}\" not exist in the cache of model: ${this.name}\")`)\n        this.cache.delete(obj.__id)\n    }\n\n    static load(filters?, order_by?: string[]): QueryBase<Model>  {\n        return new Query<Model>(this.adapter, this.cache, filters, order_by)\n    }\n\n    static loadPage(filter?, order_by?: string[], page?: number, page_size?: number) {\n        return new QueryPage(this.adapter, this.cache, filter, order_by, page, page_size)\n    }\n\n    @action static updateCache(raw_obj): Model {\n        let __id = this.__id(raw_obj)\n        let obj\n        if (this.cache.has(__id)) {\n            runInAction(() => {\n                obj = this.cache.get(__id)\n                obj.updateFromRaw(raw_obj)\n            })\n        }\n        else {\n            obj = new (<any>this)(raw_obj)\n        }\n        return obj\n    }\n\n    static clearCache() {\n        // for clear cache we need just to set null into id fields\n        for (let obj of this.cache.values()) {\n            for (let id_field_name of this.ids.keys()) {\n                obj[id_field_name] = null\n            }\n        }\n    }\n\n    static __id(obj, ids?) : string | null {\n        let id = '' \n        if (ids === undefined) ids = Array.from(this.ids.keys()) \n        for (let id_field_name of ids) {\n            // if any id field is null then we should return null because id is not complite\n            if (obj[id_field_name] === null || obj[id_field_name] === undefined) \n                return null\n            id += `${obj[id_field_name]}${this.id_separator}`\n        }\n        id = id.slice(0, -(this.id_separator.length))\n        return id\n    }\n\n    private readonly __init_data: any \n    private disposers = new Map()\n\n    constructor (...args) { }\n\n    @computed get __id() : string | null {\n        return this.model.__id(this)\n    }\n\n    get model() : any {\n        return (<any>this.constructor).__proto__\n    }\n\n    get raw_obj() : any {\n        let raw_obj: any = {}\n        for(let id_field_name of this.model.ids.keys()) {\n            if(this[id_field_name] !== undefined) {\n                raw_obj[id_field_name] = this[id_field_name]\n            }\n        }\n        for(let field_name in this.model.fields) {\n            if(this[field_name] !== undefined) {\n                raw_obj[field_name] = this[field_name]\n            }\n        }\n        raw_obj.__id = this.__id\n        return raw_obj\n    }\n\n    get is_changed() : boolean {\n        let is_changed = false\n        for(let field_name in this.model.fields) {\n            if (this[field_name] != this.__init_data[field_name]) {\n                is_changed = true\n            }\n        }\n        return is_changed \n    }\n\n    async create() { return await this.model.adapter.create(this) }\n    async update() { return await this.model.adapter.update(this) }\n    async delete() { return await this.model.adapter.delete(this) }\n    async save  () { return this.__id === null ? this.create() : this.update() }\n\n    @action updateFromRaw(raw_obj) {\n        // keys\n        for (let id_field_name of this.model.ids.keys()) {\n            if (raw_obj[id_field_name] !== undefined && this[id_field_name] != raw_obj[id_field_name] ) {\n                this[id_field_name] = raw_obj[id_field_name]\n            }\n        }\n        // fields\n        for(let field_name in this.model.fields) {\n            if (raw_obj[field_name] !== undefined) {\n                this[field_name] = raw_obj[field_name]\n            }\n        }\n    }\n\n}\n\n\n// Decorator\nexport function model(constructor) {\n    var original = constructor\n\n    original.cache = observable(new Map())\n\n    // the new constructor\n    let f : any = function (...args) {\n        let c : any = class extends original { constructor (...args) { super(...args) } }\n            c.__proto__ = original\n\n        let obj   = new c()\n        let model = obj.model\n        makeObservable(obj)\n\n        if (model.ids === undefined) \n            throw(`No one id field was declared on model ${model.name}`)\n\n        // apply id-fields decorators\n        for (let id_field_name of model.ids.keys()) {\n            model.ids.get(id_field_name).decorator(obj, id_field_name)\n        }\n        // apply fields decorators\n        for (let field_name in model.fields) {\n            model.fields[field_name].decorator(obj, field_name)\n        }\n        // apply relations decorators\n        for (let field_name in model.relations) {\n            model.relations[field_name].decorator(obj, field_name)\n        }\n\n        runInAction(() => {\n            // update the object from args\n            if (args[0]) {\n                let raw_obj = args[0]\n                // id-fields\n                for (let id_field_name of model.ids.keys()) {\n                    if (raw_obj[id_field_name] !== undefined) {\n                        obj[id_field_name] = raw_obj[id_field_name]\n                    }\n                }\n                // fields \n                for (let field_name in model.fields) {\n                    if (raw_obj[field_name] !== undefined) {\n                        obj[field_name] = raw_obj[field_name]\n                    }\n                }\n            }\n            // save __init_data\n            obj.__init_data = {}\n            for (let field_name in model.fields) {\n                obj.__init_data[field_name] = obj[field_name]\n            }\n        })\n        return obj\n    }\n\n    f.__proto__ = original\n    f.prototype = original.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { Model } from '../model'\n\ntype RawObject = any \n\nexport default abstract class  Adapter<M extends Model> {\n\n    // abstract getTotalCount: (where?) => Promise<number>\n    abstract __create(obj: RawObject): Promise<object>\n    abstract __update(obj: RawObject): Promise<object>\n    abstract __delete(obj: RawObject): Promise<object>\n    abstract __load  (where?, order_by?, limit?, offset?): Promise<RawObject[]>\n\n    readonly model: any\n\n    constructor(model: any) {\n        this.model = model \n    }\n\n    async create(obj: M) : Promise<M> {\n        let raw_obj = await this.__create(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        return obj\n    }\n\n    async update(obj: M) : Promise<M> {\n        let raw_obj = await this.__update(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        return obj\n    }\n\n    async delete(obj: M) : Promise<M> {\n        let raw_obj = await this.__delete(obj.raw_obj)\n        // reset ids\n        debugger\n        for(let id_field_name of this.model.ids.keys())\n            obj[id_field_name] = null\n        return obj\n    }\n\n    async load(where?, order_by?, limit?, offset?):Promise<M[]> {\n        let raw_objs = await this.__load(where, order_by, limit, offset)\n        let objs: M[] = []\n        for (let raw_obj of raw_objs) {\n            objs.push(this.model.updateCache(raw_obj))\n        }\n        return objs\n    }\n}\n","import { Model } from '../model'\nimport Adapter  from './adapter'\n\n/*\nYou can use this adapter for mock data or for unit test\n*/\n\ntype RawObject = any \n\nexport let store: any = {}\n\nexport class LocalAdapter<M extends Model> extends Adapter<M> {\n\n    readonly store_name: string\n\n    constructor(model: any) {\n        super(model)\n        this.store_name = model.__proto__.name\n        store[this.store_name] = {}\n    }\n\n    async __create(obj: RawObject) : Promise<RawObject> {\n        if (obj.__id === null) {\n            // calculate and set new ID\n            let ids = [0]\n            for(let id of Object.keys(store[this.store_name])) {\n                ids.push(parseInt(id))\n            }\n            let max = Math.max.apply(null, ids)\n            for(let field_name_id of this.model.ids.keys()) {\n                obj[field_name_id] = max + 1\n            }\n        }\n        obj.__id = this.model.__id(obj)\n        store[this.store_name][this.model.__id(obj)] = obj\n        return obj\n    }\n\n    async __update(obj: RawObject) : Promise<RawObject> {\n        store[this.store_name][obj.__id] = obj\n        return obj\n    }\n\n    async __delete(obj: RawObject) : Promise<RawObject> {\n        delete store[this.store_name][obj.__id]\n        return obj\n    }\n\n    async __load (where?, order_by?, limit?, offset?) : Promise<RawObject[]> {\n        let raw_objs = Object.values(store[this.store_name])\n        if (limit !== undefined && offset !== undefined) {\n            raw_objs = raw_objs.slice(offset, offset+limit)\n        }\n        return raw_objs \n    }\n\n    // async getTotalCount(where?): Promise<number> {\n    //     return 100\n    // }\n}\n\n// model decorator\nexport function local() {\n    return (cls: any) => {\n        let adapter = new LocalAdapter(cls)\n        cls.__proto__.adapter = adapter \n    }\n}\n\nexport function init_local_data(model: any, data: RawObject[]) {\n    let objs = {} \n    for(let obj of data) {\n        objs[model.__id(obj)] = obj\n    }\n    store[model.__proto__.name] = objs\n}\n","import { observable, observe, intercept, extendObservable } from 'mobx'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to cache then you can use this \nnew Obj({id: x, ...})\n*/\n\nfunction field_ID (obj , field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // before changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && obj[field_name] !== null)\n            throw new Error(`You cannot change id field: ${field_name}. ${obj[field_name]} to ${change.newValue}`)\n        if (obj[field_name] !== null && change.newValue === null) {\n            try {\n                obj.model.eject(obj)\n            }\n            catch (err) {\n                let ignore_error = `Object with id \"${obj.__id}\" not exist in the model cache: ${obj.model.name}\")`\n                if (err.name !== ignore_error)\n                    throw err\n            }\n        }\n        return change\n    })\n\n    // after changes\n    observe(obj, field_name, (change) => {\n        // if id is complete\n        if (obj.__id !== null) \n            obj.model.inject(obj)\n    })\n\n}\n\n\nexport default function id(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.ids === undefined) model.ids = new Map()\n    model.ids.set(field_name, { decorator: field_ID })\n}\n","import { extendObservable } from 'mobx'\n\n\n\nexport function field_field(obj, field_name) {\n    // make observable and set default value\n    extendObservable(obj, { [field_name]: obj[field_name] })\n}\n\n\nexport default function field(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n\n    model.fields[field_name] = { decorator: field_field }  // register field \n}\n","// import 'reflect-metadata'\nimport {intercept, observe, extendObservable, observable, autorun, when, reaction} from 'mobx'\n\nfunction field_foreign(obj, field_name) {\n    let edit_mode = false\n    let settings = obj.model.relations[field_name].settings\n    let foreign_model     = settings.foreign_model\n    let foreign_ids_names = settings.foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    debugger\n    reaction(\n        // watch on foreign cache for foreign object\n        () => {\n            let id = foreign_model.__id(obj, foreign_ids_names)\n            return id ? foreign_model.cache.get(id) : null\n        },\n        // update foreign field\n        (foreign_obj, prev, reaction) => {\n            obj[field_name] = foreign_obj ? foreign_obj : null \n        })\n\n    // Setter\n    // 1. checks before set new changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model == foreign_model)) {\n            throw new Error(`You can set only instance of \"${foreign_model.name}\" or null`)\n        }\n        return change\n    })\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let new_foreign_obj = change.newValue\n        let old_foreign_obj = change.oldValue\n\n        if (new_foreign_obj === old_foreign_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n        edit_mode = true\n        try {\n            if (change.newValue === null) {\n                // if foreign set to null then reset ids on the obj\n                for (let id_name of foreign_ids_names) {\n                    obj[id_name] = null \n                }\n            }\n            else {\n                debugger\n                // if foreign set to obj then update ids from the obj's ids\n                let obj_ids: any = Array.from(change.newValue.model.ids.keys())\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    // do not touch if it the same\n                    if (obj[foreign_ids_names[i]] != change.newValue[obj_ids[i]])\n                        obj[foreign_ids_names[i]]  = change.newValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // rollback changes!\n            if (change.oldValue === null) {\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = null \n                }\n            }\n            else {\n                let obj_ids = change.oldValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n            throw e\n        }\n\n        // if foreign have the one then update the one\n        if (settings.one) {\n            if (old_foreign_obj) {\n                old_foreign_obj[settings.one] = null\n            }\n            if (new_foreign_obj) {\n                new_foreign_obj[settings.one] = obj \n            }\n        }\n\n    })\n}\n\n\nexport default function foreign(foreign_model: any, ...foreign_ids_names: string[]) {\n    foreign_model = foreign_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.constructor\n        if (model.relations === undefined) model.relations = {}\n        // register field \n        model.relations[field_name] = { \n            decorator: field_foreign,\n            settings: {\n                foreign_model: foreign_model,\n                // if it is empty then try auto detect it (it works only with single id) \n                foreign_ids_names: foreign_ids_names.length ? foreign_ids_names : [`${field_name}_id`]\n            } \n        } \n\n        // TODO finish it\n        // watch on the foreign cache \n        // if foreign obj was created then it should be attached to foreign\n        // if foreign obj was deleted then it should be removed from foreign\n        // e.i. update foreign obj when foreign ids was changed\n        // reaction(() => foreign_model.cache, (value, prev_value, reaction) => {\n        //     debugger\n        // })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_one(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // 1. checks before set new changes\n    intercept(obj, <any>field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model === remote_model))\n                throw new Error(`You can set only instance of \"${remote_model.name}\" or null`)\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let old_remote_obj = change.oldValue\n        let new_remote_obj = change.newValue\n\n        if (new_remote_obj === old_remote_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote obj\n            if (old_remote_obj) {\n                for (let id_name of remote_foreign_ids_name) {\n                    old_remote_obj[id_name] = null \n                }\n            }\n            // set foreign ids on the remote obj \n            if (new_remote_obj) {\n                let obj_ids: any = Array.from(obj.model.ids.keys())\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]] = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\n\nexport default function one(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    remote_model = remote_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_one,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`one ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            // TODO: is it not bad?\n                            // if (obj[field_name])\n                            //     // TODO better name of error\n                            //     // TODO add test for this case\n                            //     throw ('One: bad')\n                            runInAction(() => { obj[field_name] = remote_obj })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`one ${field_name}`)) {\n                        remote_obj.disposers.get(`one ${field_name}`)()\n                        remote_obj.disposers.delete(`one ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) \n                        runInAction(() => { obj[field_name] = null })\n                    break\n            }\n        })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_many(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: []\n    })\n\n    // 1. checks before set new changes\n    intercept(obj[field_name], (change: any) => {\n        // TODO\n        // if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor === remote_model.__proto__))\n        //         throw new Error(`You can set only instance of \"${remote_model.__proto__.name}\" or null`)\n\n        // TODO: if we push exist obj then ignore it? and not duplicate\n        // TODO: create a test for this case \n        // remote obj can be in the many \n        // for (let new_remote_obj of change.added) {\n        //     const i = obj[field_name].indexOf(new_remote_obj)\n        //     if (i == -1)\n        //         throw new Error(`\"${new_remote_obj.model.name}\" id:\"${new_remote_obj.__id}\" alredy in many \"${obj.model.name}\" id:\"${field_name}\"`)\n        // }\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj[field_name], (change:any) => {\n        if (change.type !== 'splice')\n            return \n\n        let old_remote_objs = change.removed\n        let new_remote_objs = change.added\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote objs\n            for(let old_remote_obj of old_remote_objs)\n                for (let id_name of remote_foreign_ids_name)\n                    old_remote_obj[id_name] = null \n            // set foreign ids on the remote objs \n            let obj_ids: any = Array.from(obj.model.ids.keys())\n            for(let new_remote_obj of new_remote_objs) {\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]]  = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\nexport default function many(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_many,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`many ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            const i = obj[field_name].indexOf(remote_obj)\n                            if (i == -1)\n                                runInAction(() => { obj[field_name].push(remote_obj) })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`many ${field_name}`)) {\n                        remote_obj.disposers.get(`many ${field_name}`)()\n                        remote_obj.disposers.delete(`many ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) {\n                        const i = obj[field_name].indexOf(remote_obj)\n                        if (i > -1)\n                            runInAction(() => { obj[field_name].splice(i, 1); })\n                    } \n                    break\n            }\n        })\n    }\n}"],"names":["Query","constructor","adapter","base_cache","filters","order_by","page","page_size","Object","this","__base_cache","__adapter","makeObservable","items","__items","is_loading","__is_loading","error","__error","destroy","disposer","__disposers","__id","__disposer_objects","async","objs","load","__load","e","runInAction","ready","Promise","resolve","reject","autorun","reaction","dispose","__is_matched","obj","key","__decorate","observable","action","QeuryBase","splice","length","push","super","observe","change","type","watch_obj","newValue","name","oldValue","i","indexOf","id","should","QueryBase","undefined","filter","should_be_in_the_list","Model","args","Map","static","Error","cache","has","set","delete","QueryPage","raw_obj","get","updateFromRaw","values","id_field_name","ids","keys","Array","from","id_separator","slice","model","__proto__","field_name","fields","is_changed","__init_data","create","update","computed","Adapter","__create","__update","__delete","where","limit","offset","raw_objs","updateCache","store","LocalAdapter","store_name","parseInt","max","Math","apply","field_name_id","field_ID","extendObservable","intercept","eject","err","ignore_error","inject","field_field","field_foreign","edit_mode","settings","relations","foreign_model","foreign_ids_names","foreign_obj","prev","new_foreign_obj","old_foreign_obj","id_name","obj_ids","one","field_one","remote_model","remote_foreign_ids_name","remote_foreign_ids_names","old_remote_obj","new_remote_obj","field_many","old_remote_objs","removed","new_remote_objs","added","cls","decorator","prototype","toLowerCase","remote_change","remote_obj","disposers","original","f","c"],"mappings":"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"}
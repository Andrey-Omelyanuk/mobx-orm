{"version":3,"file":"mobx-orm.js","sources":["../src/query-base.ts","../src/query.ts","../src/query-page.ts","../src/model.ts","../src/adapters/adapter.ts","../src/adapters/local.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts"],"sourcesContent":["import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport Adapter from \"./adapters/adapter\"\nimport { Model } from \"./model\"\n\n\nexport default abstract class Query<M extends Model> {\n\n    @observable filters     : object  \n    @observable order_by    : string[]\n    @observable page        : number\n    @observable page_size   : number\n\n    get items      () { return this.__items }\n    get is_loading () { return this.__is_loading  }\n    get is_ready   () { return this.__is_ready    }\n    get error      () { return this.__error       }\n    \n\treadonly __base_cache: any\n\treadonly __adapter: Adapter<M>\n    @observable __items: M[] = []\n    @observable __is_loading  : boolean = false \n    @observable __is_ready    : boolean = false \n    @observable __error       : string = '' \n\n    __disposers = []\n    __disposer_objects = {}\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n\t\tthis.__base_cache = base_cache\n\t\tthis.__adapter    = adapter\n        if (filters  ) this.filters   = filters\n        if (order_by ) this.order_by  = order_by\n        if (page\t ) this.page      = page\n        if (page_size) this.page_size = page_size\n        makeObservable(this)\n    }\n\n    destroy() {\n        for(let disposer of this.__disposers) disposer()\n        for(let __id in this.__disposer_objects) this.__disposer_objects[__id]()\n    }\n\n    abstract __load(objs: M[])\n\n    // use it if everybody should know that the query data is updating\n    @action async load() {\n        this.__is_loading = true\n        try {\n            await this.shadowLoad()\n        }\n        finally {\n            runInAction(() => this.__is_loading = false)\n        }\n    }\n\n    // use it if nobody should know that you load data for the query\n    // for example you need to update the current data on the page and you don't want to show a spinner\n    @action async shadowLoad() {\n        try {\n            let objs = await this.__adapter.load(this.filters, this.order_by, this.page_size, this.page*this.page_size)\n            this.__load(objs)\n            runInAction(() => this.__is_ready = true)\n        }\n        catch(e) {\n            runInAction(() => this.__error = e)\n            throw e\n        }\n    }\n\n    // use it if you need use promise instead of observe is_ready\n    ready(): Promise<Boolean> {\n        return new Promise((resolve, reject) => { \n            autorun((reaction) => {\n                if (this.__is_ready) {\n                    reaction.dispose()\n                    resolve(this.__is_ready) \n                }\n            })\n        })\n    }\n\n    // use it if you need use promise instead of observe is_loading\n    loading(): Promise<Boolean> {\n        return new Promise((resolve, reject) => { \n            autorun((reaction) => {\n                if (!this.__is_loading) {\n                    reaction.dispose()\n                    resolve(!this.__is_loading) \n                }\n            })\n        })\n    }\n\n    __is_matched(obj) {\n        for(let key in this.filters) {\n            if (obj[key] != this.filters[key]) {\n                return false\n            }\n        }\n        return true\n    }\n}\n","import { action, autorun, makeObservable, observable, observe, reaction, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QeuryBase from './query-base'\n\n\n/*\nReactive items:\n- delete from the cache -> delete from items\n- add to the cache \n    - the new obj is match the filters  -> add the obj to items\n- obj was changed \n    - не было но уже    попадание по фильтрам -> add the obj to items\n    -    было но уже не попадание по фильтрам -> remove the obj from items\n*/\n\nexport default class Query<M extends Model> extends QeuryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[]) {\n        super(adapter, base_cache, filters, order_by)\n\n        this.load() // load when query is created\n\n        // update if filters was changed\n        // watch only filters, if order was changed then we don't need to update, just resort\n        this.__disposers.push(reaction(\n            () => { filter: this.filters },\n            () => { this.load() }\n        ))\n\n        // watch the cache for changes, and update items if needed\n        this.__disposers.push(observe(this.__base_cache, (change: any) => {\n            if (change.type == 'add') {\n                this.watch_obj(change.newValue)\n            }\n            if (change.type == \"delete\") {\n                let __id = change.name\n                let obj  = change.oldValue\n                this.__disposer_objects[__id]()\n                delete this.__disposer_objects[__id]\n                let i = this.items.indexOf(obj)\n                if (i != -1)\n                    runInAction(() => {\n                        this.items.splice(i, 1)\n                    })\n            }\n        }))\n\n        // watch all exist objects of model \n        for(let [id, obj] of this.__base_cache) {\n            this.watch_obj(obj)\n        }\n    }\n\n    private watch_obj(obj) {\n        this.__disposer_objects[obj.__id] = autorun(\n            () => {\n                let should = this.__is_matched(obj)\n                let i = this.items.indexOf(obj)\n                // should be in the items and it is not in the items? add it to the items\n                if ( should && i == -1) runInAction(() => this.items.push(obj))\n                // should not be in the items and it is in the items? remove it from the items\n                if (!should && i != -1) runInAction(() => this.items.splice(i, 1))\n            })\n    }\n\n}\n","import { reaction, action, runInAction } from \"mobx\"\nimport { Model } from \"./model\"\nimport Adapter from \"./adapters/adapter\"\nimport QueryBase from './query-base'\n\n\n// TODO: implement need_to_update\n\nexport default class Query<M extends Model> extends QueryBase<M> {\n\n    __load(objs: M[]) {\n        runInAction(() => { \n            this.__items.splice(0, this.__items.length)\n            this.__items.push(...objs)\n        })\n    }\n\n    // TODO: add actions for QueryBase and QueryPage\n    // TODO: Query should know nothing about pages!\n    // @action setFilters(filters : any     ) { this.filters  = filters  }\n    // @action setOrderBy(order_by: string[]) { this.order_by = order_by }\n    // @action firstPage() { this.page = 0 }\n    // @action prevPage () { this.page = this.page < 0 ? this.page - 1 : 0 }\n    // @action nextPage () { this.page = this.page + 1 }\n    // @action lastPage () { this.page = 9999 } // TODO: need to know total row count\n    // @action setPageSize(page_size: number) { this.page_size = page_size }\n\n\n    constructor(adapter: Adapter<M>, base_cache: any, filters?: object, order_by?: string[], page?: number, page_size?: number) {\n        super(adapter, base_cache, filters, order_by)\n        if(this.page === undefined) this.page = 0\n        if(this.page_size === undefined) this.page_size = 50\n\n        this.load() // load when query is created\n\n        // update if query is changed\n        this.__disposers.push(reaction(\n            () => { return { \n                filter          : this.filters, \n                order_by        : this.order_by, \n                page            : this.page, \n                page_size       : this.page_size,\n             }},\n            () => { this.load() }\n        ))\n    }\n}\n","import { field } from 'dist/mobx-orm'\nimport { action, computed, makeObservable, observable, runInAction } from 'mobx'\nimport Adapter   from './adapters/adapter'\nimport QueryBase from './query-base'\nimport Query     from './query'\nimport QueryPage from './query-page'\n\n\nexport type RawObject = any \n\n\nexport abstract class Model {\n    private static id_separator: string = '-'\n    // this private static properties will be copied to real model in the model decorator\n    private static adapter      : Adapter<Model>\n    private static cache        : Map<string, Model>\n    // we have 3 types of fields\n    // - ids (cannot be changed, order of keys is important)\n    // - fields\n    // - relations (not exist on outside)\n    private static ids: Map<string, {\n            // can decorator be different?\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }>\n    private static fields       : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any,\n            serialize   : any,\n            deserialize : any\n        }\n    }\n    // relateions is a list of field only foreign, one or many types\n    private static relations    : {\n        [field_name: string]: {\n            decorator   : (obj: Model, field_name: string) => void,\n            settings    : any\n            // there is no serializer of deserializer because \n            // it is derivative and does not come from outside\n        }\n    }\n\n    // add obj to the cache\n    @action static inject(obj: Model) {\n        debugger\n        if (obj.__id === null)                    \n            throw new Error(`Object should have id!`)\n        if (this.cache.has(obj.__id)) {\n            throw new Error(`Object with id \"${obj.__id}\" already exist in the cache of model: \"${this.name}\")`)\n        }\n        this.cache.set(obj.__id, obj)\n    }\n\n    // remove obj from the cache\n    @action static eject(obj: Model) {\n        if (obj.__id === null)\n            return                   \n        if (!this.cache.has(obj.__id)) \n            throw new Error(`Object with id \"${obj.__id}\" not exist in the cache of model: ${this.name}\")`)\n        this.cache.delete(obj.__id)\n    }\n\n    // TODO: implement find method, it should load single object from Adapter\n    // and add find method to Adapter too\n    static async find(filters) : Promise<Model> {\n        return this.adapter.find(filters) \n    }\n\n    static load(filters?, order_by?: string[]): Query<Model>  {\n        return new Query<Model>(this.adapter, this.cache, filters, order_by)\n    }\n\n    static loadPage(filter?, order_by?: string[], page?: number, page_size?: number): QueryPage<Model> {\n        return new QueryPage(this.adapter, this.cache, filter, order_by, page, page_size)\n    }\n\n    // return obj from the cache\n    static get(__id: string) {\n        return this.cache.get(__id)\n    }\n\n    @action static updateCache(raw_obj): Model {\n        let __id = this.__id(raw_obj)\n        let obj\n        if (this.cache.has(__id)) {\n            runInAction(() => {\n                obj = this.cache.get(__id)\n                obj.updateFromRaw(raw_obj)\n            })\n        }\n        else {\n            obj = new (<any>this)(raw_obj)\n        }\n        return obj\n    }\n\n    static clearCache() {\n        // for clear cache we need just to set null into id fields\n        for (let obj of this.cache.values()) {\n            for (let id_field_name of this.ids.keys()) {\n                obj[id_field_name] = null\n            }\n        }\n    }\n\n    static __id(obj, ids?) : string | null {\n        let id = '' \n        if (ids === undefined) ids = Array.from(this.ids.keys()) \n        for (let id_field_name of ids) {\n            // if any id field is null then we should return null because id is not complite\n            if (obj[id_field_name] === null || obj[id_field_name] === undefined) \n                return null\n            id += `${obj[id_field_name]}${this.id_separator}`\n        }\n        id = id.slice(0, -(this.id_separator.length))\n        return id\n    }\n\n    private __init_data: any \n    private disposers = new Map()\n\n    constructor (...args) { }\n\n    @computed get __id() : string | null {\n        return this.model.__id(this)\n    }\n\n    get model() : any {\n        return (<any>this.constructor).__proto__\n    }\n\n    // it is raw_data + ids\n    get raw_obj() : any {\n        let raw_obj: any = this.raw_data\n        for(let id_field_name of this.model.ids.keys()) {\n            if(this[id_field_name] !== undefined) {\n                raw_obj[id_field_name] = this[id_field_name]\n            }\n        }\n        raw_obj.__id = this.__id\n        return raw_obj\n    }\n\n    // data only from fields (no ids)\n    get raw_data() : any {\n        let raw_data: any = {}\n        for(let field_name in this.model.fields) {\n            if(this[field_name] !== undefined) {\n                raw_data[field_name] = this[field_name]\n            }\n        }\n        return raw_data\n    }\n\n    get is_changed() : boolean {\n        let is_changed = false\n        for(let field_name in this.model.fields) {\n            if (this[field_name] != this.__init_data[field_name]) {\n                is_changed = true\n            }\n        }\n        return is_changed \n    }\n\n    async create() { return await this.model.adapter.create(this) }\n    async update() { return await this.model.adapter.update(this) }\n    async delete() { return await this.model.adapter.delete(this) }\n    async save  () { return this.__id === null ? this.create() : this.update() }\n\n    @action refresh_init_data() {\n        if(this.__init_data === undefined) this.__init_data = {}\n        for (let field_name in this.model.fields) {\n            this.__init_data[field_name] = this[field_name]\n        }\n    }\n\n    @action updateFromRaw(raw_obj) {\n        // keys\n        for (let id_field_name of this.model.ids.keys()) {\n            if (raw_obj[id_field_name] !== undefined && this[id_field_name] != raw_obj[id_field_name] ) {\n                this[id_field_name] = raw_obj[id_field_name]\n            }\n        }\n        // fields\n        for(let field_name in this.model.fields) {\n            if (raw_obj[field_name] !== undefined) {\n                this[field_name] = raw_obj[field_name]\n            }\n        }\n    }\n\n}\n\n\n// Decorator\nexport function model(constructor) {\n    var original = constructor\n\n    original.cache = observable(new Map())\n\n    // the new constructor\n    let f : any = function (...args) {\n        let c : any = class extends original { constructor (...args) { super(...args) } }\n            c.__proto__ = original\n\n        let obj   = new c()\n        let model = obj.model\n        makeObservable(obj)\n\n        if (model.ids === undefined) \n            throw(`No one id field was declared on model ${model.name}`)\n\n        // apply id-fields decorators\n        for (let id_field_name of model.ids.keys()) {\n            model.ids.get(id_field_name).decorator(obj, id_field_name)\n        }\n        // apply fields decorators\n        for (let field_name in model.fields) {\n            model.fields[field_name].decorator(obj, field_name)\n        }\n        // apply relations decorators\n        for (let field_name in model.relations) {\n            model.relations[field_name].decorator(obj, field_name)\n        }\n\n        runInAction(() => {\n            // update the object from args\n            if (args[0]) {\n                let raw_obj = args[0]\n                // id-fields\n                for (let id_field_name of model.ids.keys()) {\n                    if (raw_obj[id_field_name] !== undefined) {\n                        obj[id_field_name] = raw_obj[id_field_name]\n                    }\n                }\n                // fields \n                for (let field_name in model.fields) {\n                    if (raw_obj[field_name] !== undefined) {\n                        obj[field_name] = raw_obj[field_name]\n                    }\n                }\n            }\n        })\n        obj.refresh_init_data()\n        return obj\n    }\n\n    f.__proto__ = original\n    f.prototype = original.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { Model, RawObject } from '../model'\n\n\nexport default abstract class  Adapter<M extends Model> {\n\n    // abstract getTotalCount: (where?) => Promise<number>\n    abstract __create(obj: RawObject): Promise<object>\n    abstract __update(obj: RawObject): Promise<object>\n    abstract __delete(obj: RawObject): Promise<object>\n    abstract __find(where): Promise<object>\n    abstract __load(where?, order_by?, limit?, offset?): Promise<RawObject[]>\n    abstract getTotalCount(where?): Promise<number>\n\n    readonly model: any\n\n    constructor(model: any) {\n        this.model = model \n    }\n\n    async create(obj: M) : Promise<M> {\n        let raw_obj = await this.__create(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        obj.refresh_init_data()\n        return obj\n    }\n\n    async update(obj: M) : Promise<M> {\n        let raw_obj = await this.__update(obj.raw_obj)\n        obj.updateFromRaw(raw_obj)\n        obj.refresh_init_data()\n        return obj\n    }\n\n    async delete(obj: M) : Promise<M> {\n        let raw_obj = await this.__delete(obj.raw_obj)\n        for(let id_field_name of this.model.ids.keys())\n            obj[id_field_name] = null\n        return obj\n    }\n\n    async find(where): Promise<M> {\n        let raw_obj = await this.__find(where)\n        return this.model.updateCache(raw_obj)\n    }\n\n    async load(where?, order_by?, limit?, offset?):Promise<M[]> {\n        let raw_objs = await this.__load(where, order_by, limit, offset)\n        let objs: M[] = []\n        for (let raw_obj of raw_objs) {\n            objs.push(this.model.updateCache(raw_obj))\n        }\n        return objs\n    }\n}\n","import { Model, RawObject } from '../model'\nimport Adapter  from './adapter'\n\n/*\nYou can use this adapter for mock data or for unit test\n*/\n\n\nexport let store: any = {}\n\n\nfunction timeout(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n\nexport default class LocalAdapter<M extends Model> extends Adapter<M> {\n\n    readonly store_name: string\n\n    // delays for simulate real usage, use it only for tests\n    delay: number \n\n    init_local_data(data: RawObject[]) {\n        let objs = {} \n        for(let obj of data) {\n            objs[this.model.__id(obj)] = obj\n        }\n        store[this.store_name] = objs\n    }\n\n    constructor(model: any, store_name?: string) {\n        super(model)\n        this.store_name = store_name ? store_name : model.__proto__.name\n        store[this.store_name] = {}\n    }\n\n    async __create(obj: RawObject) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n\n        if (obj.__id === null) {\n            // calculate and set new ID\n            let ids = [0]\n            for(let id of Object.keys(store[this.store_name])) {\n                ids.push(parseInt(id))\n            }\n            let max = Math.max.apply(null, ids)\n            for(let field_name_id of this.model.ids.keys()) {\n                obj[field_name_id] = max + 1\n            }\n        }\n        obj.__id = this.model.__id(obj)\n        store[this.store_name][this.model.__id(obj)] = obj\n        return obj\n    }\n\n    async __update(obj: RawObject) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n        store[this.store_name][obj.__id] = obj\n        return obj\n    }\n\n    async __delete(obj: RawObject) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n        delete store[this.store_name][obj.__id]\n        return obj\n    }\n\n    async __find(where) : Promise<RawObject> {\n        if (this.delay) await timeout(this.delay) \n        // TODO: apply where, and throw error if no obj or multi objs\n        let raw_obj = Object.values(store[this.store_name])[0]\n        return raw_obj\n    }\n\n    async __load (where?, order_by?, limit?, offset?) : Promise<RawObject[]> {\n        if (this.delay) await timeout(this.delay) \n        let raw_objs = []\n        // filter\n        if (where) {\n            for(let raw_obj of Object.values(store[this.store_name])) {\n\n            }\n        }\n        else {\n            raw_objs = Object.values(store[this.store_name])\n        }\n\n        // order_by (sort)\n        if (order_by) {\n            raw_objs = raw_objs.sort((obj_a, obj_b) => {\n                let res\n                for(let sort_by_field of order_by) {\n\n                }\n                return 0\n            })\n        }\n\n        // page\n        if (limit !== undefined && offset !== undefined) {\n            raw_objs = raw_objs.slice(offset, offset+limit)\n        }\n        return raw_objs \n    }\n\n    async getTotalCount(where?): Promise<number> {\n        let objs = []\n        // Object.values(store[this.store_name])\n        return objs.length\n    }\n}\n\n\n// model decorator\nexport function local() {\n    return (cls: any) => {\n        let adapter = new LocalAdapter(cls)\n        cls.__proto__.adapter = adapter \n    }\n}\n\n// TODO: where example\n// let where = [\n//             [\"field_a\", \"==\", 10, \"and\", \"field_b == 20\"],\n//     \"or\",   [\"field_a\", \"<=\",  5, \"and\", \"field_b\", \"contain\", \"test\"]\n// ]\n","import { observable, observe, intercept, extendObservable } from 'mobx'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to cache then you can use this \nnew Obj({id: x, ...})\n*/\n\nfunction field_ID (obj , field_name) {\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // before changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && obj[field_name] !== null)\n            throw new Error(`You cannot change id field: ${field_name}. ${obj[field_name]} to ${change.newValue}`)\n        if (obj[field_name] !== null && change.newValue === null) {\n            try {\n                obj.model.eject(obj)\n            }\n            catch (err) {\n                let ignore_error = `Object with id \"${obj.__id}\" not exist in the model cache: ${obj.model.name}\")`\n                if (err.name !== ignore_error)\n                    throw err\n            }\n        }\n        return change\n    })\n\n    // after changes\n    observe(obj, field_name, (change) => {\n        // if id is complete\n        if (obj.__id !== null) \n            obj.model.inject(obj)\n    })\n\n}\n\n\nexport default function id(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.ids === undefined) model.ids = new Map()\n    model.ids.set(field_name, { decorator: field_ID })\n}\n","import { extendObservable } from 'mobx'\n\n\n\nexport function field_field(obj, field_name) {\n    // make observable and set default value\n    extendObservable(obj, { [field_name]: obj[field_name] })\n}\n\n\nexport default function field(cls, field_name: string) {\n    let model = cls.constructor\n    if (model.fields === undefined) model.fields = {}\n\n    model.fields[field_name] = { decorator: field_field }  // register field \n}\n","// import 'reflect-metadata'\nimport {intercept, observe, extendObservable, observable, autorun, when, reaction} from 'mobx'\n\nfunction field_foreign(obj, field_name) {\n    let edit_mode = false\n    let settings = obj.model.relations[field_name].settings\n    let foreign_model     = settings.foreign_model\n    let foreign_ids_names = settings.foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    debugger\n    reaction(\n        // watch on foreign cache for foreign object\n        () => {\n            let id = foreign_model.__id(obj, foreign_ids_names)\n            return id ? foreign_model.cache.get(id) : null\n        },\n        // update foreign field\n        (foreign_obj, prev, reaction) => {\n            obj[field_name] = foreign_obj ? foreign_obj : null \n        })\n\n    // Setter\n    // 1. checks before set new changes\n    intercept(obj, field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model == foreign_model)) {\n            throw new Error(`You can set only instance of \"${foreign_model.name}\" or null`)\n        }\n        return change\n    })\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let new_foreign_obj = change.newValue\n        let old_foreign_obj = change.oldValue\n\n        if (new_foreign_obj === old_foreign_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n        edit_mode = true\n        try {\n            if (change.newValue === null) {\n                // if foreign set to null then reset ids on the obj\n                for (let id_name of foreign_ids_names) {\n                    obj[id_name] = null \n                }\n            }\n            else {\n                debugger\n                // if foreign set to obj then update ids from the obj's ids\n                let obj_ids: any = Array.from(change.newValue.model.ids.keys())\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    // do not touch if it the same\n                    if (obj[foreign_ids_names[i]] != change.newValue[obj_ids[i]])\n                        obj[foreign_ids_names[i]]  = change.newValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // rollback changes!\n            if (change.oldValue === null) {\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = null \n                }\n            }\n            else {\n                let obj_ids = change.oldValue.model.ids\n                for (var i = 0; i < foreign_ids_names.length; i++) {\n                    obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n            throw e\n        }\n\n        // if foreign have the one then update the one\n        if (settings.one) {\n            if (old_foreign_obj) {\n                old_foreign_obj[settings.one] = null\n            }\n            if (new_foreign_obj) {\n                new_foreign_obj[settings.one] = obj \n            }\n        }\n\n    })\n}\n\n\nexport default function foreign(foreign_model: any, ...foreign_ids_names: string[]) {\n    foreign_model = foreign_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.constructor\n        if (model.relations === undefined) model.relations = {}\n        // register field \n        model.relations[field_name] = { \n            decorator: field_foreign,\n            settings: {\n                foreign_model: foreign_model,\n                // if it is empty then try auto detect it (it works only with single id) \n                foreign_ids_names: foreign_ids_names.length ? foreign_ids_names : [`${field_name}_id`]\n            } \n        } \n\n        // TODO finish it\n        // watch on the foreign cache \n        // if foreign obj was created then it should be attached to foreign\n        // if foreign obj was deleted then it should be removed from foreign\n        // e.i. update foreign obj when foreign ids was changed\n        // reaction(() => foreign_model.cache, (value, prev_value, reaction) => {\n        //     debugger\n        // })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_one(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: null \n    })\n\n    // 1. checks before set new changes\n    intercept(obj, <any>field_name, (change) => {\n        if (change.newValue !== null && !(change.newValue.model === remote_model))\n                throw new Error(`You can set only instance of \"${remote_model.name}\" or null`)\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj, field_name, (change:any) => {\n        let old_remote_obj = change.oldValue\n        let new_remote_obj = change.newValue\n\n        if (new_remote_obj === old_remote_obj || edit_mode)\n            return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote obj\n            if (old_remote_obj) {\n                for (let id_name of remote_foreign_ids_name) {\n                    old_remote_obj[id_name] = null \n                }\n            }\n            // set foreign ids on the remote obj \n            if (new_remote_obj) {\n                let obj_ids: any = Array.from(obj.model.ids.keys())\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]] = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\n\nexport default function one(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    remote_model = remote_model.__proto__ // band-aid\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_one,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`one ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            // TODO: is it not bad?\n                            // if (obj[field_name])\n                            //     // TODO better name of error\n                            //     // TODO add test for this case\n                            //     throw ('One: bad')\n                            runInAction(() => { obj[field_name] = remote_obj })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`one ${field_name}`)) {\n                        remote_obj.disposers.get(`one ${field_name}`)()\n                        remote_obj.disposers.delete(`one ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) \n                        runInAction(() => { obj[field_name] = null })\n                    break\n            }\n        })\n    }\n}\n","import { intercept, observe, observable, extendObservable, reaction, autorun, runInAction } from 'mobx'\nimport { Model } from '../model'\n\n\nfunction field_many(obj: Model, field_name) {\n\n    let edit_mode = false\n    let remote_model            = obj.model.relations[field_name].settings.remote_model\n    let remote_foreign_ids_name = obj.model.relations[field_name].settings.remote_foreign_ids_names\n\n    // make observable and set default value\n    extendObservable(obj, {\n        [field_name]: []\n    })\n\n    // 1. checks before set new changes\n    intercept(obj[field_name], (change: any) => {\n        // TODO\n        // if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor === remote_model.__proto__))\n        //         throw new Error(`You can set only instance of \"${remote_model.__proto__.name}\" or null`)\n\n        // TODO: if we push exist obj then ignore it? and not duplicate\n        // TODO: create a test for this case \n        // remote obj can be in the many \n        // for (let new_remote_obj of change.added) {\n        //     const i = obj[field_name].indexOf(new_remote_obj)\n        //     if (i == -1)\n        //         throw new Error(`\"${new_remote_obj.model.name}\" id:\"${new_remote_obj.__id}\" alredy in many \"${obj.model.name}\" id:\"${field_name}\"`)\n        // }\n        return change\n    })\n\n    // 2. after changes run trigger for \"change foreign_id\"\n    observe(obj[field_name], (change:any) => {\n        if (change.type !== 'splice')\n            return \n\n        let old_remote_objs = change.removed\n        let new_remote_objs = change.added\n\n        edit_mode = true\n        try {\n            // remove foreign ids on the old remote objs\n            for(let old_remote_obj of old_remote_objs)\n                for (let id_name of remote_foreign_ids_name)\n                    old_remote_obj[id_name] = null \n            // set foreign ids on the remote objs \n            let obj_ids: any = Array.from(obj.model.ids.keys())\n            for(let new_remote_obj of new_remote_objs) {\n                for (var i = 0; i < remote_foreign_ids_name.length; i++) {\n                    // do not touch if it the same\n                    if (new_remote_obj[remote_foreign_ids_name[i]] != obj[obj_ids[i]])\n                        new_remote_obj[remote_foreign_ids_name[i]]  = obj[obj_ids[i]]\n                }\n            }\n            edit_mode = false\n        }\n        catch(e) {\n            // TODO: we need to test rallback\n            // // rollback changes!\n            // if (change.oldValue === null) {\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = null \n            //     }\n            // }\n            // else {\n            //     let obj_ids = change.oldValue.model.ids\n            //     for (var i = 0; i < foreign_ids_names.length; i++) {\n            //         obj[foreign_ids_names[i]] = change.oldValue[obj_ids[i]]\n            //     }\n            // }\n            // edit_mode = false\n            // throw e\n        }\n    })\n}\n\nexport default function many(remote_model: any, ...remote_foreign_ids_names: string[]) {\n    return function (cls: any, field_name: string) {\n        let model = cls.prototype.constructor\n        if (model.relations === undefined) model.relations = {}\n        // if it is empty then try auto detect it (it works only with single id) \n        remote_foreign_ids_names = remote_foreign_ids_names.length ? remote_foreign_ids_names: [`${model.name.toLowerCase()}_id`]\n        model.relations[field_name] = { \n            decorator: field_many,\n            settings: {\n                remote_model: remote_model,\n                remote_foreign_ids_names: remote_foreign_ids_names\n            } \n        } \n        \n        // watch for remote object in the cache \n        observe(remote_model.cache, (remote_change: any) => {\n            let remote_obj\n            switch (remote_change.type) {\n                case 'add':\n                    remote_obj = remote_change.newValue\n                    remote_obj.disposers.set(`many ${field_name}` ,autorun(() => {\n                        let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                        if (obj) {\n                            const i = obj[field_name].indexOf(remote_obj)\n                            if (i == -1)\n                                runInAction(() => { obj[field_name].push(remote_obj) })\n                        }\n                    }))\n                    break\n                case 'delete':\n                    remote_obj = remote_change.oldValue\n                    if (remote_obj.disposers.get(`many ${field_name}`)) {\n                        remote_obj.disposers.get(`many ${field_name}`)()\n                        remote_obj.disposers.delete(`many ${field_name}`)\n                    }\n                    let obj =  model.cache.get(model.__id(remote_obj, remote_foreign_ids_names))\n                    if (obj) {\n                        const i = obj[field_name].indexOf(remote_obj)\n                        if (i > -1)\n                            runInAction(() => { obj[field_name].splice(i, 1); })\n                    } \n                    break\n            }\n        })\n    }\n}"],"names":["Query","constructor","adapter","base_cache","filters","order_by","page","page_size","Object","this","__base_cache","__adapter","makeObservable","items","__items","is_loading","__is_loading","is_ready","__is_ready","error","__error","destroy","disposer","__disposers","__id","__disposer_objects","async","shadowLoad","runInAction","objs","load","__load","e","ready","Promise","resolve","reject","autorun","reaction","dispose","loading","__is_matched","obj","key","__decorate","observable","action","QeuryBase","splice","length","push","super","observe","change","type","watch_obj","newValue","name","oldValue","i","indexOf","id","should","QueryBase","undefined","filter","Model","args","Map","static","Error","cache","has","set","delete","find","QueryPage","get","raw_obj","updateFromRaw","values","id_field_name","ids","keys","Array","from","id_separator","slice","model","__proto__","raw_data","field_name","fields","is_changed","__init_data","create","update","refresh_init_data","computed","Adapter","__create","__update","__delete","where","__find","updateCache","limit","offset","raw_objs","store","timeout","ms","setTimeout","LocalAdapter","store_name","init_local_data","data","delay","parseInt","max","Math","apply","field_name_id","sort","obj_a","obj_b","sort_by_field","field_ID","extendObservable","intercept","eject","err","ignore_error","inject","field_field","field_foreign","edit_mode","settings","relations","foreign_model","foreign_ids_names","foreign_obj","prev","new_foreign_obj","old_foreign_obj","id_name","obj_ids","one","field_one","remote_model","remote_foreign_ids_name","remote_foreign_ids_names","old_remote_obj","new_remote_obj","field_many","old_remote_objs","removed","new_remote_objs","added","cls","decorator","prototype","toLowerCase","remote_change","remote_obj","disposers","original","f","c"],"mappings":";;;;;;;;;;;;;;6gBAK8BA,EAsB1BC,YAAYC,EAAqBC,EAAiBC,EAAkBC,EAAqBC,EAAeC,GApB5FC,+FACAA,gGACAA,4FACAA,iGAOfA,oGACAA,iGACeA,sFAAe,KACfA,4FAA0B,IAC1BA,0FAA0B,IAC1BA,sFAAyB,KAErCA,0FAAc,KACdA,iGAAqB,KAGvBC,KAAKC,aAAeP,EACpBM,KAAKE,UAAeT,EACVE,IAAWK,KAAKL,QAAYA,GAC5BC,IAAWI,KAAKJ,SAAYA,GAC5BC,IAAQG,KAAKH,KAAYA,GACzBC,IAAWE,KAAKF,UAAYA,GAChCK,iBAAeH,MAtBfI,YAAgB,OAAOJ,KAAKK,QAC5BC,iBAAgB,OAAON,KAAKO,aAC5BC,eAAgB,OAAOR,KAAKS,WAC5BC,YAAgB,OAAOV,KAAKW,QAsBhCC,UACI,IAAI,IAAIC,KAAYb,KAAKc,YAAaD,IACtC,IAAI,IAAIE,KAAQf,KAAKgB,mBAAoBhB,KAAKgB,mBAAmBD,KAM7DE,aACJjB,KAAKO,cAAe,EACpB,UACUP,KAAKkB,qBAGXC,eAAY,IAAMnB,KAAKO,cAAe,KAMtCU,mBACJ,IACI,IAAIG,QAAapB,KAAKE,UAAUmB,KAAKrB,KAAKL,QAASK,KAAKJ,SAAUI,KAAKF,UAAWE,KAAKH,KAAKG,KAAKF,WACjGE,KAAKsB,OAAOF,GACZD,eAAY,IAAMnB,KAAKS,YAAa,IAExC,MAAMc,GAEF,MADAJ,eAAY,IAAMnB,KAAKW,QAAUY,IAC3BA,GAKdC,QACI,OAAO,IAAIC,SAAQ,CAACC,EAASC,KACzBC,WAASC,IACD7B,KAAKS,aACLoB,EAASC,UACTJ,EAAQ1B,KAAKS,mBAO7BsB,UACI,OAAO,IAAIN,SAAQ,CAACC,EAASC,KACzBC,WAASC,IACA7B,KAAKO,eACNsB,EAASC,UACTJ,GAAS1B,KAAKO,qBAM9ByB,aAAaC,GACT,IAAI,IAAIC,KAAOlC,KAAKL,QAChB,GAAIsC,EAAIC,IAAQlC,KAAKL,QAAQuC,GACzB,OAAO,EAGf,OAAO,GA5FCC,GAAXC,oEACWD,GAAXC,oEACWD,GAAXC,iEACWD,GAAXC,sEASWD,GAAXC,mEACWD,GAAXC,0EACWD,GAAXC,wEACWD,GAAXC,oEAuBOD,GAAPE,sHAYOF,GAAPE,kICzCgB9C,UAA+B+C,EAEhDhB,OAAOF,GACHD,eAAY,KACRnB,KAAKK,QAAQkC,OAAO,EAAGvC,KAAKK,QAAQmC,QACpCxC,KAAKK,QAAQoC,QAAQrB,MAI7B5B,YAAYC,EAAqBC,EAAiBC,EAAkBC,GAChE8C,MAAMjD,EAASC,EAAYC,EAASC,GAEpCI,KAAKqB,OAILrB,KAAKc,YAAY2B,KAAKZ,YAClB,KAAgB7B,KAAKL,WACrB,KAAQK,KAAKqB,WAIjBrB,KAAKc,YAAY2B,KAAKE,UAAQ3C,KAAKC,cAAe2C,IAI9C,GAHmB,OAAfA,EAAOC,MACP7C,KAAK8C,UAAUF,EAAOG,UAEP,UAAfH,EAAOC,KAAkB,CACzB,IAAI9B,EAAO6B,EAAOI,KACdf,EAAOW,EAAOK,SAClBjD,KAAKgB,mBAAmBD,YACjBf,KAAKgB,mBAAmBD,GAC/B,IAAImC,EAAIlD,KAAKI,MAAM+C,QAAQlB,IACjB,GAANiB,GACA/B,eAAY,KACRnB,KAAKI,MAAMmC,OAAOW,EAAG,WAMrC,IAAI,IAAKE,EAAInB,KAAQjC,KAAKC,aACtBD,KAAK8C,UAAUb,GAIfa,UAAUb,GACdjC,KAAKgB,mBAAmBiB,EAAIlB,MAAQa,WAChC,KACI,IAAIyB,EAASrD,KAAKgC,aAAaC,GAC3BiB,EAAIlD,KAAKI,MAAM+C,QAAQlB,GAEtBoB,IAAgB,GAANH,GAAS/B,eAAY,IAAMnB,KAAKI,MAAMqC,KAAKR,KAErDoB,IAAgB,GAANH,GAAS/B,eAAY,IAAMnB,KAAKI,MAAMmC,OAAOW,EAAG,eC7D1D3D,UAA+B+D,EAEhDhC,OAAOF,GACHD,eAAY,KACRnB,KAAKK,QAAQkC,OAAO,EAAGvC,KAAKK,QAAQmC,QACpCxC,KAAKK,QAAQoC,QAAQrB,MAe7B5B,YAAYC,EAAqBC,EAAiBC,EAAkBC,EAAqBC,EAAeC,GACpG4C,MAAMjD,EAASC,EAAYC,EAASC,QACnB2D,IAAdvD,KAAKH,OAAoBG,KAAKH,KAAO,QAClB0D,IAAnBvD,KAAKF,YAAyBE,KAAKF,UAAY,IAElDE,KAAKqB,OAGLrB,KAAKc,YAAY2B,KAAKZ,YAClB,KAAe,CACX2B,OAAkBxD,KAAKL,QACvBC,SAAkBI,KAAKJ,SACvBC,KAAkBG,KAAKH,KACvBC,UAAkBE,KAAKF,cAE3B,KAAQE,KAAKqB,kBChCHoC,EAiHlBjE,eAAgBkE,GAHhB3D,mGACAA,wFAAoB,IAAI4D,MA5EhBC,cAAc3B,GAElB,GAAiB,OAAbA,EAAIlB,KACJ,MAAM,IAAI8C,MAAM,0BACpB,GAAI7D,KAAK8D,MAAMC,IAAI9B,EAAIlB,MACnB,MAAM,IAAI8C,MAAM,mBAAmB5B,EAAIlB,+CAA+Cf,KAAKgD,UAE/FhD,KAAK8D,MAAME,IAAI/B,EAAIlB,KAAMkB,GAIrB2B,aAAa3B,GACjB,GAAiB,OAAbA,EAAIlB,KAAR,CAEA,IAAKf,KAAK8D,MAAMC,IAAI9B,EAAIlB,MACpB,MAAM,IAAI8C,MAAM,mBAAmB5B,EAAIlB,0CAA0Cf,KAAKgD,UAC1FhD,KAAK8D,MAAMG,OAAOhC,EAAIlB,OAK1B6C,kBAAkBjE,GACd,OAAOK,KAAKP,QAAQyE,KAAKvE,GAG7BiE,YAAYjE,EAAUC,GAClB,OAAO,IAAIL,EAAaS,KAAKP,QAASO,KAAK8D,MAAOnE,EAASC,GAG/DgE,gBAAgBJ,EAAS5D,EAAqBC,EAAeC,GACzD,OAAO,IAAIqE,EAAUnE,KAAKP,QAASO,KAAK8D,MAAON,EAAQ5D,EAAUC,EAAMC,GAI3E8D,WAAW7C,GACP,OAAOf,KAAK8D,MAAMM,IAAIrD,GAGlB6C,mBAAmBS,GACvB,IACIpC,EADAlB,EAAOf,KAAKe,KAAKsD,GAWrB,OATIrE,KAAK8D,MAAMC,IAAIhD,GACfI,eAAY,KACRc,EAAMjC,KAAK8D,MAAMM,IAAIrD,GACrBkB,EAAIqC,cAAcD,MAItBpC,EAAM,IAAUjC,KAAMqE,GAEnBpC,EAGX2B,oBAEI,IAAK,IAAI3B,KAAOjC,KAAK8D,MAAMS,SACvB,IAAK,IAAIC,KAAiBxE,KAAKyE,IAAIC,OAC/BzC,EAAIuC,GAAiB,KAKjCZ,YAAY3B,EAAKwC,GACb,IAAIrB,EAAK,QACGG,IAARkB,IAAmBA,EAAME,MAAMC,KAAK5E,KAAKyE,IAAIC,SACjD,IAAK,IAAIF,KAAiBC,EAAK,CAE3B,GAA2B,OAAvBxC,EAAIuC,SAAkDjB,IAAvBtB,EAAIuC,GACnC,OAAO,KACXpB,GAAM,GAAGnB,EAAIuC,KAAiBxE,KAAK6E,eAGvC,OADAzB,EAAKA,EAAG0B,MAAM,GAAK9E,KAAK6E,aAAmB,QACpCzB,EAQGrC,WACV,OAAOf,KAAK+E,MAAMhE,KAAKf,MAGvB+E,YACA,OAAa/E,KAAKR,YAAawF,UAI/BX,cACA,IAAIA,EAAerE,KAAKiF,SACxB,IAAI,IAAIT,KAAiBxE,KAAK+E,MAAMN,IAAIC,YACTnB,IAAxBvD,KAAKwE,KACJH,EAAQG,GAAiBxE,KAAKwE,IAItC,OADAH,EAAQtD,KAAOf,KAAKe,KACbsD,EAIPY,eACA,IAAIA,EAAgB,GACpB,IAAI,IAAIC,KAAclF,KAAK+E,MAAMI,YACL5B,IAArBvD,KAAKkF,KACJD,EAASC,GAAclF,KAAKkF,IAGpC,OAAOD,EAGPG,iBACA,IAAIA,GAAa,EACjB,IAAI,IAAIF,KAAclF,KAAK+E,MAAMI,OACzBnF,KAAKkF,IAAelF,KAAKqF,YAAYH,KACrCE,GAAa,GAGrB,OAAOA,EAGXnE,eAAiB,aAAajB,KAAK+E,MAAMtF,QAAQ6F,OAAOtF,MACxDiB,eAAiB,aAAajB,KAAK+E,MAAMtF,QAAQ8F,OAAOvF,MACxDiB,eAAiB,aAAajB,KAAK+E,MAAMtF,QAAQwE,OAAOjE,MACxDiB,aAAiB,OAAqB,OAAdjB,KAAKe,KAAgBf,KAAKsF,SAAWtF,KAAKuF,SAE1DC,yBACoBjC,IAArBvD,KAAKqF,cAA2BrF,KAAKqF,YAAc,IACtD,IAAK,IAAIH,KAAclF,KAAK+E,MAAMI,OAC9BnF,KAAKqF,YAAYH,GAAclF,KAAKkF,GAIpCZ,cAAcD,GAElB,IAAK,IAAIG,KAAiBxE,KAAK+E,MAAMN,IAAIC,YACNnB,IAA3Bc,EAAQG,IAAgCxE,KAAKwE,IAAkBH,EAAQG,KACvExE,KAAKwE,GAAiBH,EAAQG,IAItC,IAAI,IAAIU,KAAclF,KAAK+E,MAAMI,YACD5B,IAAxBc,EAAQa,KACRlF,KAAKkF,GAAcb,EAAQa,KAjLvCnF,wFAAsC,MAkH5BoC,GAATsD,uFA8COtD,GAAPE,kIAOOF,GAAPE,oIArIOF,GAAPE,0DAA0BoB,oDAWnBtB,GAAPE,0DAAyBoB,mDA2BlBtB,GAAPE,yFAAoCoB,gCCjFViC,EAY3BlG,YAAYuF,GAFZhF,6FAGIC,KAAK+E,MAAQA,EAGjB9D,aAAagB,GACT,IAAIoC,QAAgBrE,KAAK2F,SAAS1D,EAAIoC,SAGtC,OAFApC,EAAIqC,cAAcD,GAClBpC,EAAIuD,oBACGvD,EAGXhB,aAAagB,GACT,IAAIoC,QAAgBrE,KAAK4F,SAAS3D,EAAIoC,SAGtC,OAFApC,EAAIqC,cAAcD,GAClBpC,EAAIuD,oBACGvD,EAGXhB,aAAagB,SACWjC,KAAK6F,SAAS5D,EAAIoC,SACtC,IAAI,IAAIG,KAAiBxE,KAAK+E,MAAMN,IAAIC,OACpCzC,EAAIuC,GAAiB,KACzB,OAAOvC,EAGXhB,WAAW6E,GACP,IAAIzB,QAAgBrE,KAAK+F,OAAOD,GAChC,OAAO9F,KAAK+E,MAAMiB,YAAY3B,GAGlCpD,WAAW6E,EAAQlG,EAAWqG,EAAQC,GAClC,IAAIC,QAAiBnG,KAAKsB,OAAOwE,EAAOlG,EAAUqG,EAAOC,GACrD9E,EAAY,GAChB,IAAK,IAAIiD,KAAW8B,EAChB/E,EAAKqB,KAAKzC,KAAK+E,MAAMiB,YAAY3B,IAErC,OAAOjD,GC3CR,IAAIgF,EAAa,GAGxB,SAASC,EAAQC,GACb,OAAO,IAAI7E,SAAQC,GAAW6E,WAAW7E,EAAS4E,WAIjCE,UAAsCd,EAevDlG,YAAYuF,EAAY0B,GACpB/D,MAAMqC,GAdVhF,kGAGAA,6FAYIC,KAAKyG,WAAaA,GAA0B1B,EAAMC,UAAUhC,KAC5DoD,EAAMpG,KAAKyG,YAAc,GAX7BC,gBAAgBC,GACZ,IAAIvF,EAAO,GACX,IAAI,IAAIa,KAAO0E,EACXvF,EAAKpB,KAAK+E,MAAMhE,KAAKkB,IAAQA,EAEjCmE,EAAMpG,KAAKyG,YAAcrF,EAS7BH,eAAegB,GAGX,GAFIjC,KAAK4G,aAAaP,EAAQrG,KAAK4G,OAElB,OAAb3E,EAAIlB,KAAe,CAEnB,IAAI0D,EAAM,CAAC,GACX,IAAI,IAAIrB,KAAMrD,OAAO2E,KAAK0B,EAAMpG,KAAKyG,aACjChC,EAAIhC,KAAKoE,SAASzD,IAEtB,IAAI0D,EAAMC,KAAKD,IAAIE,MAAM,KAAMvC,GAC/B,IAAI,IAAIwC,KAAiBjH,KAAK+E,MAAMN,IAAIC,OACpCzC,EAAIgF,GAAiBH,EAAM,EAKnC,OAFA7E,EAAIlB,KAAOf,KAAK+E,MAAMhE,KAAKkB,GAC3BmE,EAAMpG,KAAKyG,YAAYzG,KAAK+E,MAAMhE,KAAKkB,IAAQA,EACxCA,EAGXhB,eAAegB,GAGX,OAFIjC,KAAK4G,aAAaP,EAAQrG,KAAK4G,OACnCR,EAAMpG,KAAKyG,YAAYxE,EAAIlB,MAAQkB,EAC5BA,EAGXhB,eAAegB,GAGX,OAFIjC,KAAK4G,aAAaP,EAAQrG,KAAK4G,cAC5BR,EAAMpG,KAAKyG,YAAYxE,EAAIlB,MAC3BkB,EAGXhB,aAAa6E,GAIT,OAHI9F,KAAK4G,aAAaP,EAAQrG,KAAK4G,OAErB7G,OAAOwE,OAAO6B,EAAMpG,KAAKyG,aAAa,GAIxDxF,aAAc6E,EAAQlG,EAAWqG,EAAQC,GACjClG,KAAK4G,aAAaP,EAAQrG,KAAK4G,OACnC,IAAIT,EAAW,GAEf,GAAIL,EACA,IAAI,IAAIzB,KAAWtE,OAAOwE,OAAO6B,EAAMpG,KAAKyG,mBAK5CN,EAAWpG,OAAOwE,OAAO6B,EAAMpG,KAAKyG,aAkBxC,OAdI7G,IACAuG,EAAWA,EAASe,MAAK,CAACC,EAAOC,KAE7B,IAAI,IAAIC,KAAiBzH,GAGzB,OAAO,WAKD2D,IAAV0C,QAAkC1C,IAAX2C,IACvBC,EAAWA,EAASrB,MAAMoB,EAAQA,EAAOD,IAEtCE,EAGXlF,oBAAoB6E,GAGhB,MAFW,GAECtD,QC/FpB,SAAS8E,EAAUrF,EAAMiD,GAErBqC,mBAAiBtF,EAAK,CAClBiD,CAACA,GAAa,OAIlBsC,YAAUvF,EAAKiD,GAAatC,IACxB,GAAwB,OAApBA,EAAOG,UAAyC,OAApBd,EAAIiD,GAChC,MAAM,IAAIrB,MAAM,+BAA+BqB,MAAejD,EAAIiD,SAAkBtC,EAAOG,YAC/F,GAAwB,OAApBd,EAAIiD,IAA4C,OAApBtC,EAAOG,SACnC,IACId,EAAI8C,MAAM0C,MAAMxF,GAEpB,MAAOyF,GACH,IAAIC,EAAe,mBAAmB1F,EAAIlB,uCAAuCkB,EAAI8C,MAAM/B,SAC3F,GAAI0E,EAAI1E,OAAS2E,EACb,MAAMD,EAGlB,OAAO9E,KAIXD,UAAQV,EAAKiD,GAAatC,IAEL,OAAbX,EAAIlB,MACJkB,EAAI8C,MAAM6C,OAAO3F,eCrCb4F,EAAY5F,EAAKiD,GAE7BqC,mBAAiBtF,EAAK,CAAEiD,CAACA,GAAajD,EAAIiD,KCH9C,SAAS4C,EAAc7F,EAAKiD,GACxB,IAAI6C,GAAY,EACZC,EAAW/F,EAAI8C,MAAMkD,UAAU/C,GAAY8C,SAC3CE,EAAoBF,EAASE,cAC7BC,EAAoBH,EAASG,kBAGjCZ,mBAAiBtF,EAAK,CAClBiD,CAACA,GAAa,OAIlBrD,YAEI,KACI,IAAIuB,EAAK8E,EAAcnH,KAAKkB,EAAKkG,GACjC,OAAO/E,EAAK8E,EAAcpE,MAAMM,IAAIhB,GAAM,QAG9C,CAACgF,EAAaC,EAAMxG,KAChBI,EAAIiD,GAAckD,GAA4B,QAKtDZ,YAAUvF,EAAKiD,GAAatC,IACxB,GAAwB,OAApBA,EAAOG,UAAuBH,EAAOG,SAASgC,OAASmD,EACvD,MAAM,IAAIrE,MAAM,iCAAiCqE,EAAclF,iBAEnE,OAAOJ,KAGXD,UAAQV,EAAKiD,GAAatC,IACtB,IAAI0F,EAAkB1F,EAAOG,SACzBwF,EAAkB3F,EAAOK,SAE7B,GAAIqF,IAAoBC,IAAmBR,EAA3C,CAGAA,GAAY,EACZ,IACI,GAAwB,OAApBnF,EAAOG,SAEP,IAAK,IAAIyF,KAAWL,EAChBlG,EAAIuG,GAAW,SAGlB,CAGD,IAAIC,EAAe9D,MAAMC,KAAKhC,EAAOG,SAASgC,MAAMN,IAAIC,QACxD,IAAK,IAAIxB,EAAI,EAAGA,EAAIiF,EAAkB3F,OAAQU,IAEtCjB,EAAIkG,EAAkBjF,KAAON,EAAOG,SAAS0F,EAAQvF,MACrDjB,EAAIkG,EAAkBjF,IAAON,EAAOG,SAAS0F,EAAQvF,KAGjE6E,GAAY,EAEhB,MAAMxG,GAEF,GAAwB,OAApBqB,EAAOK,SACP,IAASC,EAAI,EAAGA,EAAIiF,EAAkB3F,OAAQU,IAC1CjB,EAAIkG,EAAkBjF,IAAM,SAG/B,CACD,IAAIuF,EAAU7F,EAAOK,SAAS8B,MAAMN,IACpC,IAASvB,EAAI,EAAGA,EAAIiF,EAAkB3F,OAAQU,IAC1CjB,EAAIkG,EAAkBjF,IAAMN,EAAOK,SAASwF,EAAQvF,IAI5D,MADA6E,GAAY,EACNxG,EAINyG,EAASU,MACLH,IACAA,EAAgBP,EAASU,KAAO,MAEhCJ,IACAA,EAAgBN,EAASU,KAAOzG,QCjFhD,SAAS0G,EAAU1G,EAAYiD,GAE3B,IAAI6C,GAAY,EACZa,EAA0B3G,EAAI8C,MAAMkD,UAAU/C,GAAY8C,SAASY,aACnEC,EAA0B5G,EAAI8C,MAAMkD,UAAU/C,GAAY8C,SAASc,yBAGvEvB,mBAAiBtF,EAAK,CAClBiD,CAACA,GAAa,OAIlBsC,YAAUvF,EAAUiD,GAAatC,IAC7B,GAAwB,OAApBA,EAAOG,UAAuBH,EAAOG,SAASgC,QAAU6D,EACpD,MAAM,IAAI/E,MAAM,iCAAiC+E,EAAa5F,iBACtE,OAAOJ,KAIXD,UAAQV,EAAKiD,GAAatC,IACtB,IAAImG,EAAiBnG,EAAOK,SACxB+F,EAAiBpG,EAAOG,SAE5B,GAAIiG,IAAmBD,IAAkBhB,EAAzC,CAGAA,GAAY,EACZ,IAEI,GAAIgB,EACA,IAAK,IAAIP,KAAWK,EAChBE,EAAeP,GAAW,KAIlC,GAAIQ,EAAgB,CAChB,IAAIP,EAAe9D,MAAMC,KAAK3C,EAAI8C,MAAMN,IAAIC,QAC5C,IAAK,IAAIxB,EAAI,EAAGA,EAAI2F,EAAwBrG,OAAQU,IAE5C8F,EAAeH,EAAwB3F,KAAOjB,EAAIwG,EAAQvF,MAC1D8F,EAAeH,EAAwB3F,IAAMjB,EAAIwG,EAAQvF,KAGrE6E,GAAY,EAEhB,MAAMxG,SC7Cd,SAAS0H,EAAWhH,EAAYiD,GAE5B,IAAI6C,GAAY,EACc9F,EAAI8C,MAAMkD,UAAU/C,GAAY8C,SAASY,aACvE,IAAIC,EAA0B5G,EAAI8C,MAAMkD,UAAU/C,GAAY8C,SAASc,yBAGvEvB,mBAAiBtF,EAAK,CAClBiD,CAACA,GAAa,KAIlBsC,YAAUvF,EAAIiD,IAActC,GAajBA,IAIXD,UAAQV,EAAIiD,IAActC,IACtB,GAAoB,WAAhBA,EAAOC,KACP,OAEJ,IAAIqG,EAAkBtG,EAAOuG,QACzBC,EAAkBxG,EAAOyG,MAE7BtB,GAAY,EACZ,IAEI,IAAI,IAAIgB,KAAkBG,EACtB,IAAK,IAAIV,KAAWK,EAChBE,EAAeP,GAAW,KAElC,IAAIC,EAAe9D,MAAMC,KAAK3C,EAAI8C,MAAMN,IAAIC,QAC5C,IAAI,IAAIsE,KAAkBI,EACtB,IAAK,IAAIlG,EAAI,EAAGA,EAAI2F,EAAwBrG,OAAQU,IAE5C8F,EAAeH,EAAwB3F,KAAOjB,EAAIwG,EAAQvF,MAC1D8F,EAAeH,EAAwB3F,IAAOjB,EAAIwG,EAAQvF,KAGtE6E,GAAY,EAEhB,MAAMxG,sGH/CgB+H,EAAKpE,GAC/B,IAAIH,EAAQuE,EAAI9J,iBACK+D,IAAjBwB,EAAMI,SAAsBJ,EAAMI,OAAS,IAE/CJ,EAAMI,OAAOD,GAAc,CAAEqE,UAAW1B,uBC+EZK,KAAuBC,GAEnD,OADAD,EAAgBA,EAAclD,UACvB,SAAUsE,EAAUpE,GACvB,IAAIH,EAAQuE,EAAI9J,iBACQ+D,IAApBwB,EAAMkD,YAAyBlD,EAAMkD,UAAY,IAErDlD,EAAMkD,UAAU/C,GAAc,CAC1BqE,UAAWzB,EACXE,SAAU,CACNE,cAAeA,EAEfC,kBAAmBA,EAAkB3F,OAAS2F,EAAoB,CAAC,GAAGjD,0BFzD3DoE,EAAKpE,GAC5B,IAAIH,EAAQuE,EAAI9J,iBACE+D,IAAdwB,EAAMN,MAAmBM,EAAMN,IAAM,IAAId,KAC7CoB,EAAMN,IAAIT,IAAIkB,EAAY,CAAEqE,UAAWjC,wBDkEvC,OAAQgC,IACJ,IAAI7J,EAAU,IAAI+G,EAAa8C,GAC/BA,EAAItE,UAAUvF,QAAUA,oBKzCHmJ,KAAsBE,GAC/C,OAAO,SAAUQ,EAAUpE,GACvB,IAAIH,EAAQuE,EAAIE,UAAUhK,iBACF+D,IAApBwB,EAAMkD,YAAyBlD,EAAMkD,UAAY,IAErDa,EAA2BA,EAAyBtG,OAASsG,EAA0B,CAAC,GAAG/D,EAAM/B,KAAKyG,oBACtG1E,EAAMkD,UAAU/C,GAAc,CAC1BqE,UAAWN,EACXjB,SAAU,CACNY,aAAcA,EACdE,yBAA0BA,IAKlCnG,UAAQiG,EAAa9E,OAAQ4F,IACzB,IAAIC,EACJ,OAAQD,EAAc7G,MAClB,IAAK,MACD8G,EAAaD,EAAc3G,SAC3B4G,EAAWC,UAAU5F,IAAI,QAAQkB,IAActD,WAAQ,KACnD,IAAIK,EAAO8C,EAAMjB,MAAMM,IAAIW,EAAMhE,KAAK4I,EAAYb,IAClD,GAAI7G,EAAK,EAEK,GADAA,EAAIiD,GAAY/B,QAAQwG,IAE9BxI,eAAY,KAAQc,EAAIiD,GAAYzC,KAAKkH,WAGrD,MACJ,IAAK,SACDA,EAAaD,EAAczG,SACvB0G,EAAWC,UAAUxF,IAAI,QAAQc,OACjCyE,EAAWC,UAAUxF,IAAI,QAAQc,IAAjCyE,GACAA,EAAWC,UAAU3F,OAAO,QAAQiB,MAExC,IAAIjD,EAAO8C,EAAMjB,MAAMM,IAAIW,EAAMhE,KAAK4I,EAAYb,IAClD,GAAI7G,EAAK,CACL,MAAMiB,EAAIjB,EAAIiD,GAAY/B,QAAQwG,GAC9BzG,GAAK,GACL/B,eAAY,KAAQc,EAAIiD,GAAY3C,OAAOW,EAAG,8BPkFpD1D,GAClB,IAAIqK,EAAWrK,EAEfqK,EAAS/F,MAAQ1B,aAAW,IAAIuB,KAGhC,IAAImG,EAAU,YAAapG,GACvB,IAAIqG,EAAU,cAAcF,EAAWrK,eAAgBkE,GAAQhB,SAASgB,KACpEqG,EAAE/E,UAAY6E,EAElB,IAAI5H,EAAQ,IAAI8H,EACZhF,EAAQ9C,EAAI8C,MAGhB,GAFA5E,iBAAe8B,QAEGsB,IAAdwB,EAAMN,IACN,8CAA+CM,EAAM/B,OAGzD,IAAK,IAAIwB,KAAiBO,EAAMN,IAAIC,OAChCK,EAAMN,IAAIL,IAAII,GAAe+E,UAAUtH,EAAKuC,GAGhD,IAAK,IAAIU,KAAcH,EAAMI,OACzBJ,EAAMI,OAAOD,GAAYqE,UAAUtH,EAAKiD,GAG5C,IAAK,IAAIA,KAAcH,EAAMkD,UACzBlD,EAAMkD,UAAU/C,GAAYqE,UAAUtH,EAAKiD,GAsB/C,OAnBA/D,eAAY,KAER,GAAIuC,EAAK,GAAI,CACT,IAAIW,EAAUX,EAAK,GAEnB,IAAK,IAAIc,KAAiBO,EAAMN,IAAIC,YACDnB,IAA3Bc,EAAQG,KACRvC,EAAIuC,GAAiBH,EAAQG,IAIrC,IAAK,IAAIU,KAAcH,EAAMI,YACG5B,IAAxBc,EAAQa,KACRjD,EAAIiD,GAAcb,EAAQa,QAK1CjD,EAAIuD,oBACGvD,GAKX,OAFA6H,EAAE9E,UAAY6E,EACdC,EAAEN,UAAYK,EAASL,UAChBM,kBMtLiBlB,KAAsBE,GAE9C,OADAF,EAAeA,EAAa5D,UACrB,SAAUsE,EAAUpE,GACvB,IAAIH,EAAQuE,EAAIE,UAAUhK,iBACF+D,IAApBwB,EAAMkD,YAAyBlD,EAAMkD,UAAY,IAErDa,EAA2BA,EAAyBtG,OAASsG,EAA0B,CAAC,GAAG/D,EAAM/B,KAAKyG,oBACtG1E,EAAMkD,UAAU/C,GAAc,CAC1BqE,UAAWZ,EACXX,SAAU,CACNY,aAAcA,EACdE,yBAA0BA,IAKlCnG,UAAQiG,EAAa9E,OAAQ4F,IACzB,IAAIC,EACJ,OAAQD,EAAc7G,MAClB,IAAK,MACD8G,EAAaD,EAAc3G,SAC3B4G,EAAWC,UAAU5F,IAAI,OAAOkB,IAActD,WAAQ,KAClD,IAAIK,EAAO8C,EAAMjB,MAAMM,IAAIW,EAAMhE,KAAK4I,EAAYb,IAC9C7G,GAMAd,eAAY,KAAQc,EAAIiD,GAAcyE,SAG9C,MACJ,IAAK,SACDA,EAAaD,EAAczG,SACvB0G,EAAWC,UAAUxF,IAAI,OAAOc,OAChCyE,EAAWC,UAAUxF,IAAI,OAAOc,IAAhCyE,GACAA,EAAWC,UAAU3F,OAAO,OAAOiB,MAEvC,IAAIjD,EAAO8C,EAAMjB,MAAMM,IAAIW,EAAMhE,KAAK4I,EAAYb,IAC9C7G,GACAd,eAAY,KAAQc,EAAIiD,GAAc"}
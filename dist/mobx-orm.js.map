{"version":3,"file":"mobx-orm.js","sources":["../src/store.ts","../src/model.ts","../src/fields/id.ts","../src/fields/field.ts","../src/fields/foreign.ts","../src/fields/one.ts","../src/fields/many.ts","../src/fields/number.ts","../src/fields/float.ts","../src/fields/datetime.ts","../src/fields/boolean.ts"],"sourcesContent":["import { observable } from 'mobx'\n\n\ninterface FieldTypeDecorator {\n    (model_name: string, field_name: string, obj: Object): void\n}\n\ninterface ModelDescription {\n    fields: {\n        [field_name: string]: {\n            type        : undefined | string,\n            settings    : undefined | any,\n            serialize   : undefined | any,\n            deserialize : undefined | any\n        }\n    }\n    objects: {\n        [id: number]: object\n    }\n    unique: {\n        [field_name: string]: any\n    }\n    getNewId: ()=>number\n    save  : undefined | ((obj)=> any) \n    delete: undefined | ((obj)=> any)\n    load  : undefined | ((model_name, where, order_by, limit, offset) => any)\n}\n\n/*\nФункции хранилища:\n    Note: all functions return nothing, you can catch errors in exception\n\n    model \t\t\t\t\t\t\t\t(cls) - декоратор для класса, который мы хотим зарегистрировать как модель\n    registerModel \t\t\t\t(model_name) - register model in store if not registered yet\n    registerModelPk\t\t\t\t(model_name, fieldKey)\t-\n    registerModelField \t\t(model_name, fieldKey, fieldWrapper) \t\t\t\t-\n*/\n\nexport class Store {\n\n    debug      : boolean = false \n    models     : { [model_name: string]: ModelDescription   } = {}\n    field_types: { [type_name : string]: FieldTypeDecorator } = {}\n\n\n    registerModel(model_name) {\n        if (!this.models[model_name]) {\n            let _count_id = 0\n            this.models[model_name] = {\n                objects: {},\n                fields : {},\n                unique : {},\n                getNewId: () => {\n                    _count_id = _count_id + 1\n                    return _count_id\n                },\n                save  : undefined,\n                delete: undefined,\n                load  : undefined\n            }\n            this.models[model_name].objects = observable(this.models[model_name].objects)\n        }\n        else throw new Error(`Model \"${model_name}\" already registered.`)\n    }\n\n    registerFieldType(type, decorator) {\n        if (!this.field_types[type])\n            this.field_types[type] = decorator\n        else\n            throw new Error(`Field type \"${type}\" already registered.`)\n    }\n\n    registerModelField(model_name, type, field_name, settings = {}, serialize = null, deserialize = null) {\n        if (!this.models[model_name]) this.registerModel(model_name)\n        let model_description = this.models[model_name]\n\n        if (!model_description.fields[field_name])\n            model_description.fields[field_name] = { type: type, settings: settings, serialize: serialize, deserialize: deserialize }\n        else\n            throw `Field \"${field_name}\" on \"${model_name}\" already registered.`\n    }\n\n    // registerUniqueField(model_name, field_name) {\n    // \tif (!this.models[model_name]) this.registerModel(model_name)\n    // \tlet model_description = this.models[model_name]\n    // \tif (!model_description.unique[field_name]) {\n    //\n    // \t\tlet unique_set = new Set()\n    // \t\t//\n    // \t\tmodel_description.unique[field_name] = unique_set\n    // \t\t// inject/eject/update\n    // \t\tmodel_description.fields[field_name].onUpdate(({obj}) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for updating ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onInject((obj) => {\n    // \t\t\t// null can be many! just ignore it\n    // \t\t\tif (obj[field_name] === null) return\n    // \t\t\tif (unique_set.has(obj[field_name])) throw new Error(`Not unique value.`) // for inject ${model_name}.${field_name} to ${obj[field_name]}`)\n    // \t\t\telse unique_set.add(obj[field_name])\n    // \t\t})\n    // \t\tstore.models[model_name].onEject((obj) => {\n    // \t\t\tunique_set.delete(obj[field_name])\n    // \t\t})\n    // \t}\n    // \telse {\n    // \t\tthrow `Unique on field \"${field_name}\" on \"${model_name}\" already registered.`\n    // \t}\n    // }\n\n    inject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can inject only instance of \"${model_name}\"`)\n        if (model_description.objects[object.id])  throw new Error(`Object with id=\"${object.id}\" already exist in model \"${model_name}\".`)\n\n        model_description.objects[object.id] = object\n    }\n\n    eject(model_name, object) {\n        let model_description = this.models[model_name]\n        if (!(model_name in this.models))          throw new Error(`Model name \"${model_name} is not registered in the store`)\n        if (!object || !object.constructor)        throw new Error('object should be a object with constructor')\n        if (!object.id)                            throw new Error(`Object should have id!`)\n        if (object.constructor.name != model_name) throw new Error(`You can eject only instance of \"${model_name}\"`)\n        if (!model_description.objects[object.id]) throw new Error(`Object with id ${object.id} not exist in model \"${model_name}\"`)\n\n        delete model_description.objects[object.id]\n    }\n\n    clear() {\n        for (let model_name of Object.keys(this.models))\n            for (let obj of <any>Object.values(this.models[model_name].objects))\n                if(obj.delete)\n                    obj.delete()\n\n        this.models = {}\n    }\n\n    clearModel(model_name) {\n        for (let obj of <any>Object.values(this.models[model_name].objects))\n            if(obj.delete)\n                obj.delete()\n    }\n\n}\nlet store = new Store()\nexport default store\n\ndeclare let window\nwindow.mobx_orm_store = store\n","import store from './store'\n\n\nexport class Model {\n\n    static get(id: number): Model {\n        let model_name = this.prototype.constructor.name\n        return <Model>store.models[model_name].objects[id]\n    }\n\n    static all(): Model[] {\n        let model_name = this.prototype.constructor.name\n        return <Model[]>Object.values(store.models[model_name].objects)\n    }\n\n    static async load(where = {}, order_by = {}, limit = 0, offset = 0) {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.load) \n            return model_description.load(this, where, order_by, limit, offset)\n        else\n            throw Error(`load function is not defined for ${model_name}`) \n    }\n\n    static getFieldsMeta() {\n        let model_name = this.prototype.constructor.name\n        let model_description = store.models[model_name]\n        return model_description.fields\n    }\n\n    private readonly _init_data\n\n    constructor(init_data?) {\n        this._init_data = init_data\n    }\n\n    // если нет id, то создать его\n    // если нужна синхронизация с удаленным хранилищем, то:\n    //      если нет id - то создаем объект удаленно, оттуда и приходит обект с готовым id\n    //\t\t\tесли есть   - то обновляем удаленно\n    async save() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.save) \n            return model_description.save(this)\n        else {\n            let obj = <any>this\n            if (!obj.id)\n                obj.id = model_description.getNewId()\n\n            return Promise.resolve(obj)\n        }\n    }\n\n    async delete() {\n        let model_name = this.constructor.name\n        let model_description = store.models[model_name]\n        if (model_description.delete) \n            return model_description.delete(this)\n        else {\n            (<any>this).id = null\n            return Promise.resolve(this)\n        }\n    }\n}\n\n\n// Decorator\nexport function model(cls) {\n    // the new constructor behaviour\n    let f : any = function (...args) {\n        let c : any = function () { return cls.apply(this, args) }\n        c.__proto__ = cls.__proto__\n        c.prototype = cls.prototype\n\n        let model_name = cls.name\n        let model_description = store.models[model_name]\n\n        let obj  = new c()\n        let init_data = obj._init_data\n        delete obj._init_data\n\n        // save defaults from class declaration\n        for (let field_name in model_description.fields) {\n            if (obj[field_name] !== undefined && init_data[field_name] === undefined) {\n                init_data[field_name] = obj[field_name]\n            }\n        }\n\n        // apply decorators\n        for (let field_name in model_description.fields) {\n            let type = model_description.fields[field_name].type\n            store.field_types[type](model_name, field_name, obj)\n        }\n        \n        if (init_data)\n            for (let field_name in init_data)\n                obj[field_name] = init_data[field_name]\n\n        return obj\n    }\n    // copy static properties/methods\n    for (let prop_name of Object.getOwnPropertyNames(cls))\n        if(f[prop_name] == undefined)\n            f[prop_name] = cls[prop_name]\n\n    f.__proto__ = cls.__proto__\n    f.prototype = cls.prototype   // copy prototype so intanceof operator still works\n    return f                      // return new constructor (will override original)\n}\n","import { observable, observe, intercept } from 'mobx'\nimport store from '../store'\nimport field from './field';\n\n\nlet type = 'id'\n\n/*\n1. you can setup id only once!\nusing obj.id = x, new Obj({id: x}) or obj.save()\n\n2. save() has two behavior depend on id \n - id === undefined or null -> create object on remote storage and get it\n - id === some number       -> save object in remote storage \n\n3. if you want just load data to store then you can use this \nnew Obj({id: x, ...})\n*/\n\nexport function registerFieldId() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue != null)\n                if(obj.id != null)\n                    throw new Error(`You cannot change id.`)\n                else if (!Number.isInteger(change.newValue))\n                    throw new Error(`Id can be only integer or null.`)\n\n            if (obj.id && change.newValue == null)\n                store.eject (model_name, obj)\n\n            return change\n        })\n\n        // after changes\n        observe(obj, field_name, (change) => {\n            if (change.newValue)\n                store.inject(model_name,obj)\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterFieldId()\n\n\nexport default function id(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    if (field_name != 'id')\n        throw new Error(`id field should named by 'id'`)\n    store.registerModelField(model_name, type, field_name)\n\n    // register observable into mobx\n    observable(cls, field_name)\n}\n","import { observable } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'field'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function field(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","// import 'reflect-metadata'\nimport store from '../store'\nimport {intercept, observe, observable, autorun} from 'mobx'\n\n\nlet type = 'foreign'\n\nexport function registerForeign() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Computed\n        // watch \"foreign_id\" field\n        // e.i. update foreign obj when foreign id was changed\n        autorun(() => {\n            let foreign_obj = store.models[foreign_model_name].objects[obj[foreign_id_field_name]]\n            obj[field_name] = foreign_obj ? foreign_obj : null\n        })\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null && !(change.newValue.constructor && change.newValue.constructor.name == foreign_model_name))\n                throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n            if (change.newValue !== null && change.newValue.id === null)\n                throw new Error(`Object should have id!`)\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> A.b_id -> A.b -> A.b_id ...\n\n            try {\n                obj[foreign_id_field_name] = change.newValue === null ? null : change.newValue.id\n            }\n            catch(e) {\n                // rollback changes!\n                obj[foreign_id_field_name] = change.oldValue === null ? null : change.oldValue.id\n                throw e\n            }\n        })\n\n        // default value\n        if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterForeign()\n\n\nexport default function foreign(foreign_model_name: any, foreign_id_field_name?: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        store.registerModelField(model_name, type, field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name ? foreign_id_field_name : `${field_name}_id`\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n    }\n}\n","import store from '../store'\nimport {intercept, observe, observable} from 'mobx'\n\n\nexport function registerOne() {\n    store.registerFieldType('one', (model_name, field_name, obj) => {\n        let foreign_model_name    = store.models[model_name].fields[field_name].settings.foreign_model_name\n        let foreign_id_field_name = store.models[model_name].fields[field_name].settings.foreign_id_field_name\n\n        // Setter\n        // 1. checks before set new changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null) {\n                if (!(change.newValue.constructor && change.newValue.constructor.name === foreign_model_name))\n                    throw new Error(`You can set only instance of \"${foreign_model_name}\" or null`)\n                if (change.newValue.id === null)\n                    throw new Error(`Object should have id!`)\n            }\n            return change\n        })\n        // 2. after changes run trigger for \"change foreign_id\"\n        observe(obj, field_name, (change) => {\n            if (change.newValue === change.oldValue)\n                return  // it will help stop endless loop A.b -> B.a_id -> A.b -> B.a_id ...\n\n            let prev_old = null\n            let prev_new = null\n            try {\n                if (change.oldValue) {\n                    prev_old = change.oldValue[foreign_id_field_name]\n                    change.oldValue[foreign_id_field_name] = null\n                }\n                if (change.newValue) {\n                    prev_new = change.newValue[foreign_id_field_name]\n                    change.newValue[foreign_id_field_name] = obj.id\n                }\n            }\n            catch(e) {\n                // rollback changes!\n                if (change.newValue)\n                    change.newValue[foreign_id_field_name] = prev_new\n                if (change.oldValue)\n                    change.oldValue[foreign_id_field_name] = prev_old\n                throw e\n            }\n        })\n\n        // default value\n        obj[field_name] = null\n    })\n}\nregisterOne()\n\n\nexport default function one(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n\n        //\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name = foreign_model_name.constructor.name == 'Function' ? foreign_model_name.prototype.constructor.name : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'one', field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, field_name)\n\n        // сдедим за созданием объектов, для первого подсчета one\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type == 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[field_name] = obj\n        })\n\n        // следим за всеми foreign объектами\n        observe(store.models[foreign_model_name].objects, (change) => {\n            switch (change.type) {\n                // появился новый объект\n                case 'add':\n                    let new_object = store.models[model_name].objects[(<any>change).newValue[foreign_id_field_name]]\n                    if (new_object)\n                        new_object[field_name] = change.newValue\n\n                    // подписываемся на каждый объект\n                    observe(change.newValue, foreign_id_field_name, (field_change) => {\n                        // first delete old\n                        if (field_change.oldValue) {\n                            let object = store.models[model_name].objects[field_change.oldValue]\n                            object[field_name] = null\n                        }\n                        //\n                        if (field_change.newValue) {\n                            let obj = store.models[model_name].objects[field_change.newValue]\n                            if (obj)\n                                obj[field_name] = change.newValue\n                        }\n                    })\n                    break\n                // удалили объект\n                case 'remove':\n                    let old_object = store.models[model_name].objects[(<any>change).oldValue[foreign_id_field_name]]\n                    if (old_object)\n                            old_object[field_name] = null\n                    break\n            }\n        })\n    }\n}\n","import { observable, observe } from 'mobx'\nimport store from '../store'\n\n\nexport function registerMany() {\n    store.registerFieldType('many', (model_name, field_name, obj) => {\n        // default value\n        obj[field_name] = []\n    })\n}\nregisterMany()\n\n\nexport default function many(foreign_model_name: any, foreign_id_field_name: string) {\n    return function (cls: any, many_field_name: string) {\n\n        // It can be wrong name \"Function\" because we wrapped class in decorator before.\n        let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n        // detect class name\n        if (typeof foreign_model_name === 'function')\n            foreign_model_name\n                = foreign_model_name.constructor.name == 'Function'\n                ? foreign_model_name.prototype.constructor.name\n                : foreign_model_name.constructor.name\n\n        if (!store.models[model_name])         store.registerModel(model_name)\n        if (!store.models[foreign_model_name]) store.registerModel(foreign_model_name)\n        store.registerModelField(model_name, 'many', many_field_name, {\n            foreign_model_name   : foreign_model_name,\n            foreign_id_field_name: foreign_id_field_name\n        })\n\n        // register into mobx\n        observable(cls, many_field_name)\n\n        // watch for creation of new objects for first calculation of \"many\"\n        observe(store.models[model_name].objects, (change) => {\n            if (change.type === 'add')\n                for (let obj of Object.values(store.models[foreign_model_name].objects))\n                    if (obj[foreign_id_field_name] == change.newValue.id)\n                        change.newValue[many_field_name].push(obj)\n        })\n\n        // watch for all foreign objects\n        observe(store.models[foreign_model_name].objects, (change: any) => {\n            let foreign_object   : any\n            let object_with_many : any\n            switch (change.type) {\n                // new object was added \n                case 'add':\n                    foreign_object = change.newValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} start`)\n                        object_with_many[many_field_name].push(foreign_object)\n                        if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} add ${foreign_object.id} finish`)\n                    }\n\n                    observe(foreign_object, foreign_id_field_name, (field_change) => {\n                        if (field_change.newValue) {\n                            let object_with_many_id = field_change.newValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} start`)\n                                object_with_many[many_field_name].push(foreign_object)\n                                if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} add ${foreign_object.id} finish`)\n                            }\n                        }\n                        if (field_change.oldValue) {\n                            let object_with_many_id = field_change.oldValue\n                            let object_with_many = store.models[model_name].objects[object_with_many_id]\n                            if (object_with_many) {\n                                let index = object_with_many[many_field_name].indexOf(foreign_object)\n                                if (index > -1) {\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} start`)\n                                    object_with_many[many_field_name].splice(index, 1)\n                                    if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many_id} remove ${foreign_object.id} finish`)\n                                }\n                            }\n                        }\n                    })\n                    break\n                // object was removed \n                case 'remove':\n                    foreign_object = change.oldValue\n                    object_with_many = store.models[model_name].objects[foreign_object[foreign_id_field_name]]\n                    if (object_with_many) {\n                        let index = object_with_many[many_field_name].indexOf(foreign_object)\n                        if (index > -1) {\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} start`)\n                            object_with_many[many_field_name].splice(index, 1)\n                            if(store.debug) console.log(`many ${model_name}.${many_field_name} of ${object_with_many.id} remove ${foreign_object.id} finish`)\n                        }\n                    }\n                    break\n            }\n        })\n    }\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'number'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (!(change.newValue === Number(change.newValue) && change.newValue % 1 === 0))\n                    throw new Error(`Field can be only integer or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'float'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                if (change.newValue !== Number(change.newValue))\n                    throw new Error(`Field can be only float or null.`)\n            return change\n        })\n        // default value\n        // if (obj[field_name] === undefined) obj[field_name] = null\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\nimport { isNoop } from '@babel/types';\n\n\nlet type = 'datetime'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null) {\n                if(typeof change.newValue === 'string' || change.newValue instanceof String) {\n                    change.newValue = Date.parse(<any>change.newValue)\n                    if (!isNaN(change.newValue))\n                        change.newValue = new Date(change.newValue)\n                }\n                if (!(change.newValue instanceof Date)) \n                    throw new Error(`Field can be only Date or null.`)\n            }\n            return change\n        })\n    })\n}\nregisterField()\n\n\nexport default function datetime(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name === 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name, {},\n        (obj) => { return new Date(obj)     },\n        (obj) => { return obj.toISOString() }\n    )\n    // register into mobx\n    observable(cls, field_name)\n}\n","import { observable, intercept } from 'mobx'\nimport store from '../store'\n\n\nlet type = 'boolean'\n\nexport function registerField() {\n    store.registerFieldType(type, (model_name, field_name, obj) => {\n\n        // before changes\n        intercept(obj, field_name, (change) => {\n            if (change.newValue !== null)\n                change.newValue = Boolean(change.newValue)\n            return change\n        })\n    })\n}\nregisterField()\n\n\nexport default function number(cls: any, field_name: string) {\n    // It can be wrong name \"Function\" because we wrapped class in decorator before.\n    let model_name = cls.constructor.name == 'Function' ? cls.prototype.constructor.name : cls.constructor.name\n    store.registerModelField(model_name, type, field_name)\n    // register into mobx\n    observable(cls, field_name)\n}\n"],"names":["store","this","Store","model_name","models","Error","_count_id_1","objects","fields","unique","getNewId","save","undefined","delete","load","observable","type","decorator","field_types","field_name","settings","serialize","deserialize","registerModel","model_description","object","constructor","id","name","_a","Object","keys","_i","_c","values","_b","obj","window","mobx_orm_store","init_data","_init_data","Model","prototype","where","order_by","limit","offset","Promise","resolve","registerFieldType","intercept","change","newValue","Number","isInteger","eject","observe","inject","foreign_model_name","foreign_id_field_name","autorun","foreign_obj","oldValue","e","prev_old","prev_new","String","Date","parse","isNaN","Boolean","cls","registerModelField","toISOString","many_field_name","push","foreign_object","object_with_many","debug","console","log","field_change","object_with_many_id","object_with_many_1","object_with_many_2","index","indexOf","splice","f","args","c","apply","__proto__","getOwnPropertyNames","prop_name","new_object","old_object"],"mappings":"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"}
########################################################################################################################
Все возможные события


store 	- inject
				- eject
				
Note: Store have events "inject/eject" for each model.
Note: Model have no events! "Create" event is not make sense.

object 	- update

field 	- update

filter  - add
				- remove
				- reorder
				- update
				
Event   - это много раз повторяющиеся события, например inject в store
Promise - это ТОЛЬКО РАЗ выполненное/завершенное действие, оно ни как не может повториться, например create или delete!
Ты ведь не думаешь что один и тот же объект можно создать/удалить дважды?

Особый режим загрузки/выгрузки для store.
Для фронтенда любой inject/eject (не в состоянии режима загрузки!)
это равносильно create/delete! 

Если хочеться подписаться на удаление объекта, то подписывайся на eject в моделе! И там уже жди свой объект.
Не надо усложнять дополнительным subscribe.delete на объекте.

-----------------------
может быть:

1. store
	- inject
	- eject

Пример использования!!! внутри декоратора  
У нас там только имя модели и мы ни как не можем напрямую использовать класс.
store.onEject('<model_name>', function(obj) {...})

2. model
  - inject
  - eject 
  
Хочу что бы было так:
User.subscribe.eject (function(user) {...})
А может так?
User.onEject(function(user) {...})
Неполучиться!!! т.к. нам нужно подписываться внутри декораторов!
А там у нас лишь имя модели! т.е. получиться только
store.onEject('<model_name>', function(obj) {...})
но в остальных местах мы может использовать и тот вариант
а красив ли он? да! если мы не хотим ни чего знать про store! а только про class

Что с after/before ?
Только если мы хотим перехватить, что делать категорически нельзя!
Если ошибка, то просто кидай исключение.
  
3. object
  - update
  - delete
  Note: delete тоже самое что и model.eject, только более прицельно
  Note: нет смысла в create событии, вместо него смотри на store.inject
  
4. field
  - update
  
5. filter
  - add
  - remove 
  - reorder
  - update  
  
Вариант с onInject лучше чем subscribe.inject, т.к. короче и более привычен среди других программистов.

Так что же с вариантами after/before? он усложняем все, но дает больше контроля!
Как вариант:
onInject = onAfterInject
onAfterInject
onBeforeInject
тут у нас и есть простой вариант и сложный, выбирай какой хочешь явно
или используй по умолчанию самый часто используемый!!!
Мне нравиться эта идея!
По умоланию мы всегда используем after! т.к. мы реагируем всегда на законченное действие!
??? может before не имеет смысла?

Вариант after/before усложняет код и замедляет его, может его лучше не использовать?
Нужно попробовать, а люди которые хотят его использовать, должны использовать другую версию!
т.е. должена быть lite версия с супер простым кодом и быстрым выполнением, 
и другая версия с полным фаршем.
Для начала нужно сделать lite версию.

Почему событие before плохо!
- появляется НЕЯВНАЯ зависимость от НЕОПРЕДЕЛЕННОГО кода
т.е. лучше полностью отказаться от after!!!

########################################################################################################################
